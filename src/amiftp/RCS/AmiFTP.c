head	1.815;
access;
symbols;
locks
	lilja:1.815
	lilja:0.651; strict;
comment	@ * @;


1.815
date	96.12.14.12.13.03;	author lilja;	state Exp;
branches;
next	1.795;

1.795
date	96.09.28.13.32.58;	author lilja;	state Exp;
branches;
next	1.736;

1.736
date	96.08.17.18.17.57;	author lilja;	state Exp;
branches;
next	1.730;

1.730
date	96.08.02.21.57.32;	author lilja;	state Exp;
branches;
next	1.720;

1.720
date	96.07.27.23.43.40;	author lilja;	state Exp;
branches;
next	1.713;

1.713
date	96.07.25.22.53.54;	author lilja;	state Exp;
branches;
next	1.710;

1.710
date	96.07.25.00.21.30;	author lilja;	state Exp;
branches;
next	1.692;

1.692
date	96.07.20.00.28.38;	author lilja;	state Exp;
branches;
next	1.630;

1.630
date	96.07.07.20.10.48;	author lilja;	state Exp;
branches;
next	1.625;

1.625
date	96.07.04.17.50.58;	author lilja;	state Exp;
branches;
next	1.595;

1.595
date	96.06.18.23.19.14;	author lilja;	state Exp;
branches;
next	1.587;

1.587
date	96.06.14.13.23.25;	author lilja;	state Exp;
branches;
next	1.586;

1.586
date	96.06.13.11.07.48;	author lilja;	state Exp;
branches;
next	1.585;

1.585
date	96.06.13.00.03.21;	author lilja;	state Exp;
branches;
next	1.541;

1.541
date	96.06.04.21.43.36;	author lilja;	state Exp;
branches;
next	1.531;

1.531
date	96.05.28.00.17.52;	author lilja;	state Exp;
branches;
next	1.430;

1.430
date	96.04.14.13.21.26;	author lilja;	state Exp;
branches;
next	1.401;

1.401
date	96.03.28.13.52.44;	author lilja;	state Exp;
branches;
next	1.265;

1.265
date	96.03.08.18.01.38;	author lilja;	state Exp;
branches;
next	1.200;

1.200
date	96.02.20.00.19.28;	author lilja;	state Exp;
branches;
next	1.184;

1.184
date	96.02.14.23.27.00;	author lilja;	state Exp;
branches;
next	1.173;

1.173
date	96.02.14.19.06.27;	author lilja;	state Exp;
branches;
next	1.152;

1.152
date	96.02.12.23.26.47;	author lilja;	state Exp;
branches;
next	1.150;

1.150
date	96.02.11.16.38.55;	author lilja;	state Exp;
branches;
next	1.124;

1.124
date	96.02.10.15.46.32;	author lilja;	state Exp;
branches;
next	0.1332;

0.1332
date	95.12.17.13.21.38;	author lilja;	state Exp;
branches;
next	0.1302;

0.1302
date	95.12.09.20.15.21;	author lilja;	state Exp;
branches;
next	0.1300;

0.1300
date	95.12.08.20.24.52;	author lilja;	state Exp;
branches;
next	0.857;

0.857
date	95.10.24.18.41.14;	author lilja;	state Exp;
branches;
next	0.827;

0.827
date	95.10.23.21.01.35;	author lilja;	state Exp;
branches;
next	0.814;

0.814
date	95.10.15.15.22.12;	author lilja;	state Exp;
branches;
next	0.807;

0.807
date	95.10.13.12.51.19;	author lilja;	state Exp;
branches;
next	0.774;

0.774
date	95.10.07.00.18.25;	author lilja;	state Exp;
branches;
next	0.757;

0.757
date	95.09.30.16.00.45;	author lilja;	state Exp;
branches;
next	0.728;

0.728
date	95.09.30.10.27.47;	author lilja;	state Exp;
branches;
next	0.723;

0.723
date	95.09.29.16.48.36;	author lilja;	state Exp;
branches;
next	0.685;

0.685
date	95.09.22.20.13.06;	author lilja;	state Exp;
branches;
next	0.671;

0.671
date	95.09.20.10.15.33;	author lilja;	state Exp;
branches;
next	0.651;

0.651
date	95.09.17.11.06.43;	author lilja;	state Exp;
branches;
next	0.623;

0.623
date	95.09.16.10.54.30;	author lilja;	state Exp;
branches;
next	0.588;

0.588
date	95.09.12.16.24.08;	author lilja;	state Exp;
branches;
next	0.567;

0.567
date	95.09.11.17.15.13;	author lilja;	state Exp;
branches;
next	0.563;

0.563
date	95.09.10.20.59.20;	author lilja;	state Exp;
branches;
next	0.541;

0.541
date	95.09.06.12.36.41;	author lilja;	state Exp;
branches;
next	0.486;

0.486
date	95.08.26.11.48.42;	author lilja;	state Exp;
branches;
next	0.425;

0.425
date	95.07.24.18.19.29;	author lilja;	state Exp;
branches;
next	0.413;

0.413
date	95.07.23.13.03.53;	author lilja;	state Exp;
branches;
next	0.388;

0.388
date	95.07.16.13.14.48;	author lilja;	state Exp;
branches;
next	0.371;

0.371
date	95.06.30.19.18.41;	author lilja;	state Exp;
branches;
next	0.350;

0.350
date	95.06.22.19.23.19;	author lilja;	state Exp;
branches;
next	0.345;

0.345
date	95.06.15.23.29.18;	author lilja;	state Exp;
branches;
next	0.326;

0.326
date	95.06.13.12.52.15;	author lilja;	state Exp;
branches;
next	0.322;

0.322
date	95.06.12.23.14.26;	author lilja;	state Exp;
branches;
next	0.312;

0.312
date	95.06.09.18.13.36;	author lilja;	state Exp;
branches;
next	0.305;

0.305
date	95.06.08.16.45.30;	author lilja;	state Exp;
branches;
next	0.303;

0.303
date	95.06.08.15.30.02;	author lilja;	state Exp;
branches;
next	0.284;

0.284
date	95.06.06.21.42.35;	author lilja;	state Exp;
branches;
next	;


desc
@Callbacks for mainwindow
@


1.815
log
@Fixed the proxy-port settings.
Replaced % with @@ since the proxy actually seems to work with other
ftpproxies.
Fixed the Height/Width save-problem.
@
text
@/* RCS Id: $Id: AmiFTP.c 1.795 1996/09/28 13:32:58 lilja Exp $
   Locked version: $Revision: 1.795 $
*/

#include "AmiFTP.h"
#include "gui.h"

extern char *connected_host;
extern struct MsgPort *AppPort;
extern struct CLIArguments *cliargs;

ULONG lsecs,lmics;

void parse_url(char *url, char *site, char *dir, char *userid, int *port)
{
    char *ptr,*ptr1;

    if (strncmp(url,"ftp://",6)==0) { /* URL-type [userid@@]site[:port]path*/
	ptr=url+6;
    }
    else
      ptr=url;

    if (strchr(ptr,'@@')) {
	strncpy(userid, ptr, strchr(ptr, '@@')-ptr);
	ptr=strchr(ptr,'@@');
	ptr++;
    }
    ptr1=site;
    while (*ptr!=0 && *ptr!=':' && *ptr!='/') {
	*ptr1=*ptr;
	ptr++;
	ptr1++;
    }
    if (*ptr==':') {
	ptr++;
	*port=atol(ptr);
	while (*ptr!=0 && isdigit(*ptr))
	  ptr++;
    }
    if (*ptr) {
	ptr++;
	if (*ptr)
	  strcpy(dir, ptr);
    }
}

void ftpWindow()
{
    ULONG rexxsignal,mainwinsignal,gotsignal,appsignal;
    int running=1;
    extern Object *ARexx_Object;
    extern BOOL ARexxQuitBit;
    extern struct List DropUploadList;

    NewList(&DropUploadList);

    if (!CurrentState.Iconified) {
	if (!OpenFTPWindow(FALSE)) {
	    Printf("failed to open window\n");
	    return;
	}
    }
    else {
	if ((ULONG)OpenFTPWindow(TRUE)!=1) {
	    Printf("failed\n");
	    return;
	}
    }
    if (cliargs && TCPStack)
      if (cliargs->site) {
	  struct SiteNode sn,*sn1=NULL;
	  struct Node *lbn;

	  LockWindow(MainWin_Object);
	  memset(&sn,0,sizeof(sn));
	  for (lbn=GetHead(&SiteList);lbn;lbn=GetSucc(lbn)) {
	      GetListBrowserNodeAttrs(lbn,
				      LBNA_UserData, &sn1,
				      TAG_DONE);
	      if ((stricmp((char *)cliargs->site, sn1->sn_Node.ln_Name)==0)&&
		  (strlen(sn1->sn_Node.ln_Name)==strlen((char *)cliargs->site)))
		break;
	  }
	  if (!lbn) {
	      char site[100], dirpath[255], userid[30];
	      int port=0;

	      memset(site,0,100);
	      memset(dirpath,0,255);
	      memset(userid,0,30);
	      parse_url(cliargs->site, site, dirpath, userid, &port);
	      sn.sn_SiteAddress=(char *)site;
	      sn.sn_Node.ln_Name=(char *)site;
	      sn.sn_RemoteDir=dirpath[0]?dirpath:NULL;
	      sn.sn_LoginName=userid[0]?userid:NULL;
	      sn.sn_Anonymous=userid[0]?0:1;
	      sn.sn_Proxy=MainPrefs.mp_DefaultProxy;
	      sn.sn_Port=port==0?ftp_port:port;
	      UnlockWindow(MainWin_Object);
	      ConnectSite(&sn, 0);
	  }
	  else {
	      UnlockWindow(MainWin_Object);
	      ConnectSite(sn1, 0);
	  }
      }
    GetAttr(AREXX_SigMask, ARexx_Object, &rexxsignal);
    appsignal=1L<<AppPort->mp_SigBit;

    while (running) {
	fd_set rs;
	int res;

	FD_ZERO(&rs);
	if (cin!=-1)
	  FD_SET(cin, &rs);

	GetAttr(WINDOW_SigMask, MainWin_Object, &mainwinsignal);
	gotsignal=rexxsignal|SIGBREAKF_CTRL_C|AG_Signal|mainwinsignal|appsignal;
	if (TCPStack)
	  res=tcp_waitselect(cin==-1?0:cin+1, &rs, NULL, NULL, NULL, &gotsignal);
	else
	  gotsignal=Wait(rexxsignal|SIGBREAKF_CTRL_C|AG_Signal|mainwinsignal|appsignal);

	if (gotsignal) {
	    if (gotsignal&SIGBREAKF_CTRL_C)
	      break;
	    if (gotsignal&(mainwinsignal|appsignal)) {
		if (HandleMainWindowIDCMP(TRUE))
		  running=FALSE;
	    }
	    if (gotsignal&rexxsignal) {
		ARexxQuitBit=FALSE;
		CA_HandleRexx(ARexx_Object);
		if (ARexxQuitBit)
		  running=FALSE;
	    }
	    if (gotsignal&AG_Signal)
	      HandleAmigaGuide();
	}
	else {
	    if (MainWindow)
	      LockWindow(MainWin_Object);
	    timeout_disconnect();
	    if (MainWindow)
	      UnlockWindow(MainWin_Object);
	}
    }

    if (connected) {
	quit_ftp();
    }

    CloseMainWindow();
}

int Parent_clicked(void)
{
    struct List *head;

    if (!TCPStack)
      return 1;

    LockWindow(MainWin_Object);
    if (!change_remote_dir("..", 0)) {
	if (head=LookupCache(CurrentState.CurrentRemoteDir)) {
	    SetGadgetAttrs(MG_List[MG_ListView], MainWindow, NULL,
			   LISTBROWSER_Labels, ~0,
			   TAG_DONE);
	    FileList=head;
	    if (SetGadgetAttrs(MG_List[MG_ListView], MainWindow, NULL,
			       LISTBROWSER_Labels, FileList,
			       LISTBROWSER_AutoFit, TRUE,
			       LISTBROWSER_ColumnInfo, &columninfo,
			       LISTBROWSER_Selected, -1,
			       LISTBROWSER_MakeVisible, 0,
			       TAG_DONE))
	      RefreshGList(MG_List[MG_ListView], MainWindow, NULL, 1);
	}
	else if (head=read_remote_dir()) {
	    AddCacheEntry(head, CurrentState.CurrentRemoteDir);
	    SetGadgetAttrs(MG_List[MG_ListView], MainWindow, NULL,
			   LISTBROWSER_Labels, ~0,
			   TAG_DONE);
	    FileList=head;
	    if (SetGadgetAttrs(MG_List[MG_ListView], MainWindow, NULL,
			       LISTBROWSER_Labels, FileList,
			       LISTBROWSER_AutoFit, TRUE,
			       LISTBROWSER_ColumnInfo, &columninfo,
			       LISTBROWSER_Selected, -1,
			       LISTBROWSER_MakeVisible, 0,
			       TAG_DONE))
	      RefreshGList(MG_List[MG_ListView], MainWindow, NULL, 1);
	}
    }
    UpdateMainButtons(MB_NONESELECTED);
    UnlockWindow(MainWin_Object);
    return 1;
}

int Get_clicked(void)
{
    struct Node *node;
    ULONG sel;

    if (!TCPStack)
      return 1;

    for (node=ListHead(FileList);ListEnd(node);node=ListNext(node)) {
	GetListBrowserNodeAttrs(node,
				LBNA_Selected, &sel, TAG_DONE);
	if (sel) break;
    }
    if (node) {
	LockWindow(MainWin_Object);
	if (CurrentState.ADTMode)
	  DownloadFile(FileList, MainPrefs.mp_PreserveAminetDir?"T:":NULL,
		       TransferMode, 0);
	else
	  DownloadFile(FileList, NULL, TransferMode, 0);
	UnlockWindow(MainWin_Object);
    }
    return 1;
}

int DLPath_clicked(void)
{
    if (DLPath(MainWin_Object, &CurrentState.CurrentDLDir[0], 
	       &CurrentState.CurrentDLDir[0])) {
	UpdateLocalDir(CurrentState.CurrentDLDir);
    }
    return 1;
}

int DLPathString_clicked(void)
{
    strncpy(CurrentState.CurrentDLDir, GetString(MG_List[MG_DLString]), 255);
    UpdateWindowTitle();

    return 1;
}

int Put_clicked(void)
{
    struct List UploadList;
    struct Node *node;
    int i;
    struct FileRequester *FileRequester;
    static ULONG put_tags[]={
	ASL_Window, NULL,
	ASLFR_PrivateIDCMP, TRUE,
	ASLFR_SleepWindow, FALSE,
	ASLFR_InitialDrawer, NULL,
	ASLFR_RejectIcons, TRUE,
	ASLFR_TitleText, NULL,
	ASLFR_DoMultiSelect, TRUE,
	ASLFR_DoPatterns, TRUE,
	TAG_END
      };
    char DummyBuffer[1024];

    if (!TCPStack)
      return 1;

    put_tags[1]=(unsigned long)MainWindow;
    put_tags[7]=(unsigned long)CurrentState.CurrentDLDir;
    put_tags[11]=(unsigned long)GetAmiFTPString(Str_SelectULFiles);

    NewList(&UploadList);

    FileRequester=AllocAslRequest(ASL_FileRequest, NULL);
    if (!FileRequester)
      return 1;

    LockWindow(MainWin_Object);

    if (i=AslRequest(FileRequester, (struct TagItem *)put_tags)) {
#define MAX_FILENAME_LENGTH 1024
	for (i=0;i<FileRequester->rf_NumArgs;i++) {
	    if (FileRequester->fr_ArgList[i].wa_Lock) {
		if (!NameFromLock(FileRequester->fr_ArgList[i].wa_Lock,DummyBuffer,MAX_FILENAME_LENGTH))
		  DummyBuffer[0]=0;
	    }
	    else
	      strcpy(DummyBuffer, FileRequester->fr_Drawer);

	    if (FileRequester->fr_ArgList[i].wa_Name) {
		if (!AddPart(DummyBuffer,FileRequester->fr_ArgList[i].wa_Name,MAX_FILENAME_LENGTH))
		  DummyBuffer[0]=0;
	    }

	    if (DummyBuffer[0]) {
		struct FileInfoBlock fib;
		BPTR lock;
		struct dirlist *entry;

		lock=Lock(DummyBuffer, SHARED_LOCK);
		if (lock) {
		    Examine(lock, &fib);
		    UnLock(lock);
		}

		if (entry=new_direntry(DummyBuffer, NULL, NULL, NULL,
				       S_IFREG, fib.fib_Size)) {
		    if (node=AllocListBrowserNode(1,
						  LBNA_UserData, entry,
						  LBNA_Column, 0,
						  LBNCA_Text, entry->name,
						  LBNA_Selected, TRUE,
						  TAG_DONE)) {
			node->ln_Name=(void *)entry;
			AddTail(&UploadList, node);
		    }
		    else free_direntry(entry);
		}
	    }
	    else {
	    }
	}
    }
    else {
	FreeAslRequest(FileRequester);
	UnlockWindow(MainWin_Object);
	return 1;
    }
    FreeAslRequest(FileRequester);

    if (!EmptyList(&UploadList))
      UploadFile(&UploadList, NULL, TransferMode);
    free_dirlist(&UploadList);

    UnlockWindow(MainWin_Object);

    return 1;
}

int Connect_clicked(void)
{
    struct SiteNode *sn;

    if (!TCPStack)
      return 1;

    LockWindow(MainWin_Object);
    if((sn=OpenSiteListWindow(TRUE))) {
	UnlockWindow(MainWin_Object);
	ConnectSite(sn, 0);
	if (connected)
	  strncpy(CurrentState.LastLVSite, sn->sn_Node.ln_Name, 60);
    }
    else
      UnlockWindow(MainWin_Object);

    return 1;
}

int Reconnect(void)
{
    if (!TCPStack)
      return 1;

    geta4();

    if (CurrentState.CurrentSite[0]==0)
      return 1;

    if (CurrentState.LastLVSite[0]) {
	struct SiteNode *sn;
	struct Node *node;
	node=FindName(&SiteList, CurrentState.LastLVSite);
	if (node) {
	    struct SiteNode sn1;
	    GetListBrowserNodeAttrs(node, LBNA_UserData, &sn, TAG_DONE);
	    if (sn) {
		CopyMem(sn, &sn1, sizeof(struct SiteNode));
		sn1.sn_RemoteDir=strdup(CurrentState.CurrentRemoteDir);
		sn1.sn_LocalDir=CurrentState.CurrentDLDir;
		ConnectSite(&sn1,0);
		if (sn1.sn_RemoteDir)
		  free(sn1.sn_RemoteDir);
		strncpy(CurrentState.LastLVSite, sn->sn_Node.ln_Name, 60);
	    }
	}
    }
    else {
	struct SiteNode sn;
	memset(&sn,0,sizeof(struct SiteNode));
	sn.sn_RemoteDir=strdup(CurrentState.CurrentRemoteDir);
	sn.sn_LocalDir=CurrentState.CurrentDLDir;
	sn.sn_Node.ln_Name=CurrentState.CurrentSite;
	sn.sn_SiteAddress=sn.sn_Node.ln_Name;
	sn.sn_Port=ftp_port;
	sn.sn_Proxy=MainPrefs.mp_DefaultProxy;
	ConnectSite(&sn, 0);
	if (sn.sn_RemoteDir)
	  free(sn.sn_RemoteDir);
    }

    return 1;
}

int Disconnect_clicked(void)
{
    if (!TCPStack)
      return 1;

    quit_ftp();
    UpdateMainButtons(MB_DISCONNECTED);
    return 1;
}

char *NameToReadme(char *foo, int readmelen)
{
    char *bar=malloc(strlen(foo)+10);
    if (bar) {
	strcpy(bar, foo);
	strcpy(bar+strlen(bar)-readmelen, ".readme");
	return bar;
    }
    return NULL;
}

int View_clicked(BOOL Readme)
{
    struct dirlist *curr;
    struct Node *node;
    ULONG sel;

    if (!TCPStack)
      return 1;

    for (node=ListHead(FileList);ListEnd(node);node=ListNext(node)) {
	GetListBrowserNodeAttrs(node,
				LBNA_Selected, &sel, TAG_DONE);
	if (sel) break;
    }
    if (node) {
	LockWindow(MainWin_Object);
	curr=(void *)node->ln_Name;
	if (Readme) {
	    char *readmename;

	    if (curr->readmelen) {
		if (readmename=NameToReadme(curr->name, curr->readmelength)) {
		    struct List tlist;
		    struct Node *tmpnode;
		    struct dirlist tmpentry;
		    char fname[200];

		    strmfp(fname,curr->owner, readmename);
		    NewList(&tlist);
		    memset(&tmpentry, 0, sizeof(tmpentry));
		    tmpnode=AllocListBrowserNode(1,
						 LBNA_Column, 0,
						 LBNCA_Text, fname,
						 LBNA_Selected, TRUE,
						 TAG_DONE);
		    if (tmpnode) {
			tmpentry.name=fname;
			tmpentry.size=curr->readmelen;
			tmpnode->ln_Name=(char *)&tmpentry;
			tmpentry.mode=S_IFREG;
			AddTail(&tlist, tmpnode);
			if (!DownloadFile(&tlist, "T:", TransferMode, 0)) {
			    strmfp(fname, "T:", readmename);
			    ViewFile(fname);
			}
		    }
		    free(readmename);
		}
	    }
	} else
	/* Check for link */
	if (S_ISLNK(curr->mode)) {
	    char *name;
	    name = linkname(curr->name);
	    if (name) {
		char loc_name[200];
		struct List tlist;
		struct Node *tmpnode;
		struct dirlist tmpentry;
		CopyMem(curr, &tmpentry, sizeof(struct dirlist));
		NewList(&tlist);
		tmpnode=AllocListBrowserNode(1,
					     LBNA_Column, 0,
					     LBNCA_Text, curr->name,
					     LBNA_Selected, TRUE,
					     TAG_DONE);
		if (tmpnode) {
		    tmpnode->ln_Name=(void *)curr;
		    AddTail(&tlist, tmpnode);
		    if (!DownloadFile(&tlist, "T:", TransferMode, 0)) {
			DetachToolList();
			SetListBrowserNodeAttrs(node, LBNA_Selected, FALSE,
						TAG_DONE);
			AttachToolList(FALSE);
			strmfp(loc_name, "T:", name);
			ViewFile(loc_name);
		    }
		    FreeListBrowserNode(tmpnode);
		}
		free(name);
	    }
	}
	else if (curr->mode&0x4000) {/* Check for file or dir */
	    ShowErrorReq(GetAmiFTPString(Str_CannotDLDirs));
	}
	else {
	    char loc_name[200];
	    struct List tlist;
	    struct Node *tmpnode;
	    NewList(&tlist);
	    if (tmpnode=AllocListBrowserNode(1,
					     LBNA_Column, 0,
					     LBNCA_Text, curr->name,
					     LBNA_Selected, TRUE,
					     TAG_DONE)) {
		tmpnode->ln_Name=(void *)curr;
		AddTail(&tlist,tmpnode);
		if (!DownloadFile(&tlist, "T:", TransferMode, 0)) {
		    DetachToolList();
		    SetListBrowserNodeAttrs(node, LBNA_Selected, FALSE, TAG_DONE);
		    AttachToolList(FALSE);
		    strmfp(loc_name, "T:", curr->name);
		    ViewFile(loc_name);
		}
		FreeListBrowserNode(tmpnode);
	    }
	}
	sel=0;
	for (node=ListHead(FileList);ListEnd(node);node=ListNext(node)) {
	    GetListBrowserNodeAttrs(node,
				    LBNA_Selected, &sel, TAG_DONE);
	    if (sel) break;
	}
	if (sel)
	  UpdateMainButtons(MB_FILESELECTED);
	else
	  UpdateMainButtons(MB_NONESELECTED);
	UnlockWindow(MainWin_Object);
    }
    return 1;
}

void ViewFile(const char *file)
{
    struct Node *node;
    char *str=MainPrefs.mp_ViewCommand;
    char buffer[200];
    char *t=&buffer[0];

    node=malloc(sizeof(struct Node));
    if (node) {
	memset(node, 0, sizeof(struct Node));
	node->ln_Name=strdup(file);
	if (node->ln_Name) {
	    AddTail(&TempList, node);
	}
	else
	  free(node);
    }

    while (*str) {
	if (*str!='%') {
	    *t++ = *str++;
	    continue;
	}
	str+=2;
	switch(str[-1]) {
	  case 'F': 
	    t+=sprintf(t, "\"%s\"", file);
	    break;
	  case 'P':
	    t+=sprintf(t, "\"%s\"", opts[OPT_SCREEN]?(char *)opts[OPT_SCREEN]:"Workbench"); /* Fix this */
	    break;
	  default:
	    *t++=str[-2];
	    *t++=str[-1];
	    break;
	}
    }
    *t=0;
    //		    Printf("Launching '%s'\n",buffer);
    SystemTags(buffer, SYS_Input, NULL, SYS_Output, NULL, SYS_Asynch, TRUE,
	       TAG_DONE);
}

int Site_clicked(void)
{
    if (!TCPStack)
      return 1;

    if (!strlen(GetString(MG_List[MG_SiteName]))) {
	Disconnect_clicked();
	CurrentState.CurrentSite[0]=0;
	return 1;
    }

    {
	struct SiteNode sn;
	char site[100], dirpath[255], userid[30];
	int port=0;

	memset(site, 0, 100);
	memset(dirpath, 0, 255);
	memset(userid, 0, 30);
	memset(&sn, 0, sizeof(sn));

	parse_url(GetString(MG_List[MG_SiteName]), site, dirpath, userid, &port);
	sn.sn_Node.ln_Name=(char *)site;
	sn.sn_SiteAddress=(char *)site;
	sn.sn_Port=port==0?ftp_port:port;
	sn.sn_Proxy=MainPrefs.mp_DefaultProxy;
	sn.sn_Anonymous=userid[0]?0:1;
	sn.sn_LoginName=userid[0]?userid:NULL;
	sn.sn_RemoteDir=dirpath[0]?dirpath:NULL;

	ConnectSite(&sn,0);
	CurrentState.LastLVSite[0]=0;
    }

    return 1;
}

int Dir_clicked(void)
{
    struct List *head;

    if (!TCPStack)
      return 1;

    LockWindow(MainWin_Object);
    if (!change_remote_dir(GetString(MG_List[MG_DirName]), 0)) {
	RemoveCacheEntry(CurrentState.CurrentRemoteDir);
	if (head=read_remote_dir()) {
	    AddCacheEntry(head, CurrentState.CurrentRemoteDir);
	    SetGadgetAttrs(MG_List[MG_ListView], MainWindow, NULL,
			   LISTBROWSER_Labels, ~0,
			   TAG_DONE);
	    FileList=head;
	    if (SetGadgetAttrs(MG_List[MG_ListView], MainWindow, NULL,
			       LISTBROWSER_Labels, FileList,
			       LISTBROWSER_AutoFit, TRUE,
			       LISTBROWSER_ColumnInfo, &columninfo,
			       LISTBROWSER_Selected, -1,
			       LISTBROWSER_MakeVisible, 0,
			       TAG_DONE))
	      RefreshGList(MG_List[MG_ListView], MainWindow, NULL, 1);
	    UpdateMainButtons(MB_NONESELECTED);
	}
	UpdateWindowTitle();
	UnlockWindow(MainWin_Object);
    }
    else {
	UpdateRemoteDir(CurrentState.CurrentRemoteDir);
	UnlockWindow(MainWin_Object);
	RemoteCDFailed();
    }
    return 1;
}

void RemoteCDFailed(void)
{
    if (MainWindow)
      if (timedout)
	ShowErrorReq(GetAmiFTPString(Str_CDFailedTimedout));
      else
	ShowErrorReq(GetAmiFTPString(Str_CDFailed));
    if (timedout)
      quit_ftp();
}

void __stdargs ShowErrorReq(char *str,...)
{
    va_list ap;
    static ULONG tags[]={
	RTEZ_ReqTitle, NULL,
	RT_Window, NULL,
	RT_LockWindow, TRUE,
	RT_ReqPos, REQPOS_CENTERWIN,
	TAG_END
    };
    extern BOOL SilentMode;

    if (!MainWindow)
      return;

    if (SilentMode)
      return;

    tags[1]=(ULONG)GetAmiFTPString(Str_AmiFTPError);
    tags[3]=(ULONG)MainWindow;
    va_start(ap, str);
    rtEZRequestA(str, GetAmiFTPString(Str_OK), NULL, ap, (struct TagItem *)tags);
    va_end(ap);
}

char *GetPassword(char *user,char *passbuf)
{
    extern struct Window *ConnectWindow; /* Fix this: Bug in reqtools */
    static ULONG tags[]={
	RT_Window, NULL,
	RT_LockWindow, TRUE,
	RTGS_Invisible, TRUE,
	RTGS_TextFmt, NULL,
	RTGS_TextFmtArgs, NULL,
	RTGS_Flags, GSREQF_CENTERTEXT,
	RT_ReqPos, REQPOS_CENTERWIN,
	TAG_END
    };

    tags[1]=(ULONG)ConnectWindow;
    tags[7]=(ULONG)GetAmiFTPString(Str_PasswordEntry);
    tags[9]=(ULONG)&user;

    if (rtGetStringA(passbuf, 24, GetAmiFTPString(Str_PasswordRequest), NULL,
		     (struct TagItem *)tags))
      return passbuf;
    else
      return NULL;
}

extern char *infotext;
UWORD mapping[4];
#include "icons/AmiFTPbrsh.c"
Object *AboutWin_Object;

int About(void)
{
    Object *AboutLayout;
    struct Window *AboutWindow;
    struct Image *l;

    mapping[0]=DrawInfo->dri_Pens[BACKGROUNDPEN];
    mapping[1]=DrawInfo->dri_Pens[SHADOWPEN];
    mapping[2]=DrawInfo->dri_Pens[SHINEPEN];
    mapping[3]=DrawInfo->dri_Pens[FILLPEN];

    AboutLayout=LayoutObject,
                  GA_TextAttr, AmiFTPAttrF,
                  GA_DrawInfo, DrawInfo,
                  LAYOUT_DeferLayout, TRUE,
                  LAYOUT_SpaceOuter, TRUE,
                  LAYOUT_Orientation, LAYOUT_ORIENT_VERT,

                  StartHGroup,
                    LAYOUT_AddImage, l=LabelObject,
                      LABEL_Mapping, mapping,
                      LABEL_Image, &im,
                    LabelEnd,
                    CHILD_MinWidth, im.Width,
                    CHILD_MinHeight, im.Height,
                    CHILD_WeightedWidth, 0,
                    CHILD_WeightedHeight, 0,

                    LAYOUT_AddImage, l=LabelObject,
                      LABEL_DrawInfo, DrawInfo,
                      IA_Font, AmiFTPAttrF,
                      LABEL_Justification, LJ_LEFT,
                      LABEL_Text, infotext,
                      LABEL_Text, CurrentState.RexxPort,
                      LABEL_Text, "\n",
                      LABEL_Text, GetAmiFTPString(Str_Translator),
                    LabelEnd,
                    CHILD_MinWidth, l->Width,
                    CHILD_MinHeight, l->Height,
                    CHILD_WeightedWidth, 0,
                    CHILD_WeightedHeight, 0,
                  EndGroup,
                End;

    if (!AboutLayout)
      return 1;

    AboutWin_Object=WindowObject,
                      WA_Title, GetAmiFTPString(Str_AboutAmiFTP),
                      WA_PubScreen, Screen,
                      WA_Top, MainWindow->TopEdge,
                      WA_Left, MainWindow->LeftEdge,
                      WA_DepthGadget, TRUE,
                      WA_DragBar, TRUE,
                      WA_CloseGadget, TRUE,
                      WA_Activate, TRUE,
                      WA_SmartRefresh, TRUE,
                      WA_IDCMP, IDCMP_RAWKEY,
                      WINDOW_ParentGroup, AboutLayout,
                    EndWindow;
    if (!AboutWin_Object) {
	DisposeObject(AboutLayout);
	return 1;
    }

    LockWindow(MainWin_Object);

    if (AboutWindow=CA_OpenWindow(AboutWin_Object)) {
	ULONG aboutwin,mainwin,mask,done=FALSE;

	GetAttr(WINDOW_SigMask, MainWin_Object, &mainwin);
	GetAttr(WINDOW_SigMask, AboutWin_Object, &aboutwin);
	while (!done) {
	    mask=Wait(aboutwin|mainwin|AG_Signal|SIGBREAKF_CTRL_C);
	    if (mask&SIGBREAKF_CTRL_C)
	      done=TRUE;
	    if (mask&mainwin)
	      HandleMainWindowIDCMP(FALSE);
	    if (mask&AG_Signal)
	      HandleAmigaGuide();
	    if (mask&aboutwin) {
		ULONG result;
		UWORD code=NULL;
		while ((result=CA_HandleInput(AboutWin_Object, &code))!=WMHI_LASTMSG) {
		    switch (result&WMHI_CLASSMASK) {
		      case WMHI_CLOSEWINDOW:
			done=TRUE;
			break;
		      case WMHI_RAWKEY:
			if (code==69) /* Escape-key */
			  done=TRUE;
			else if (code==95) /* HELP-key */
			  SendAGMessage(AG_ABOUTWIN);
			break;
		    }
		}
	    }
	}
    }
    DisposeObject(AboutWin_Object);
    UnlockWindow(MainWin_Object);
    return 1;
}

int SavePrefs(void)
{
    extern char *ConfigName;

    if (ConfigChanged || CurrentState.LeftEdge!=MainWindow->LeftEdge || CurrentState.TopEdge!=MainWindow->TopEdge) {
	LockWindow(MainWin_Object);
	MainPrefs.mp_Height=MainWindow->Height-MainWindow->BorderTop-MainWindow->BorderBottom;
	MainPrefs.mp_Width=MainWindow->Width-MainWindow->BorderLeft-MainWindow->BorderRight;
	MainPrefs.mp_TopEdge=MainWindow->TopEdge+Screen->ViewPort.DyOffset;
	MainPrefs.mp_LeftEdge=MainWindow->LeftEdge+Screen->ViewPort.DxOffset;
	MainPrefs.mp_SortMode=SortMode;
	WriteConfigFile(ConfigName);
	UnlockWindow(MainWin_Object);
	ConfigChanged=FALSE;
    }
    return 1;
}

static ULONG prefs_tags[]={
    ASL_Window, NULL,
    ASLFR_PrivateIDCMP, TRUE,
    ASLFR_SleepWindow, TRUE,
    ASLFR_InitialDrawer, NULL,
    ASLFR_InitialFile, NULL,
    ASLFR_RejectIcons, TRUE,
    ASLFR_TitleText, NULL,
    ASLFR_DoSaveMode, NULL,
    TAG_END
};

int SavePrefsAs(void)
{
    struct FileRequester *FileRequester;
    char tmp[150];

    memset(tmp, 0, 150);
    CopyMem(ConfigName, tmp, (ULONG)PathPart(ConfigName)-(ULONG)ConfigName);

    prefs_tags[1]=(unsigned long)MainWindow;
    prefs_tags[7]=(unsigned long)tmp;
    prefs_tags[9]=(unsigned long)FilePart(ConfigName);
    prefs_tags[13]=(unsigned long)GetAmiFTPString(Str_SelectSettingsFile);
    prefs_tags[15]=(unsigned long)TRUE;

    FileRequester=AllocAslRequest(ASL_FileRequest, NULL);
    if (!FileRequester)
      return 1;
    if (AslRequest(FileRequester, (struct TagItem *)prefs_tags)) {
	strcpy(tmp, FileRequester->fr_Drawer);
	AddPart(tmp, FileRequester->fr_File, sizeof(tmp));
	if (ConfigName)
	  free(ConfigName);
	ConfigName=strdup(tmp);
	MainPrefs.mp_Height=MainWindow->Height-MainWindow->BorderTop-MainWindow->BorderBottom;
	MainPrefs.mp_Width=MainWindow->Width-MainWindow->BorderLeft-MainWindow->BorderRight;
	MainPrefs.mp_TopEdge=MainWindow->TopEdge+Screen->ViewPort.DyOffset;
	MainPrefs.mp_LeftEdge=MainWindow->LeftEdge+Screen->ViewPort.DxOffset;
	MainPrefs.mp_SortMode=SortMode;
	WriteConfigFile(ConfigName);
	ConfigChanged=FALSE;
    }
    FreeAslRequest(FileRequester);

    return 1;
}

int LoadPrefs(void)
{
    struct FileRequester *FileRequester;
    char tmp[150];

    memset(tmp, 0, 150);
    CopyMem(ConfigName, tmp, (ULONG)PathPart(ConfigName)-(ULONG)ConfigName);

    prefs_tags[1]=(unsigned long)MainWindow;
    prefs_tags[7]=(unsigned long)tmp;
    prefs_tags[9]=(unsigned long)FilePart(ConfigName);
    prefs_tags[13]=(unsigned long)GetAmiFTPString(Str_SelectSettingsFile);
    prefs_tags[15]=(unsigned long)FALSE;

    FileRequester=AllocAslRequest(ASL_FileRequest, NULL);
    if (!FileRequester)
      return 1;
    if (AslRequest(FileRequester, (struct TagItem *)prefs_tags)) {
	strcpy(tmp, FileRequester->fr_Drawer);
	AddPart(tmp, FileRequester->fr_File, sizeof(tmp));
	if (ConfigName)
	  free(ConfigName);
	ConfigName=strdup(tmp);
	FreeSiteList(&SiteList);
	NewList(&SiteList);
	if (MainPrefs.mp_LocalDir) {free(MainPrefs.mp_LocalDir);MainPrefs.mp_LocalDir=NULL;}
	if (MainPrefs.mp_AnonymousPW) {free(MainPrefs.mp_AnonymousPW);MainPrefs.mp_AnonymousPW=NULL;}
	if (MainPrefs.mp_LoginName) {free(MainPrefs.mp_LoginName);MainPrefs.mp_LoginName=NULL;}
	if (MainPrefs.mp_DefaultSite) {free(MainPrefs.mp_DefaultSite);MainPrefs.mp_DefaultSite=NULL;}
	if (MainPrefs.mp_ProxyServer) {free(MainPrefs.mp_ProxyServer);MainPrefs.mp_ProxyServer=NULL;}
	if (MainPrefs.mp_ViewCommand) {free(MainPrefs.mp_ViewCommand);MainPrefs.mp_ViewCommand=NULL;}
	ReadConfigFile(ConfigName);
	MenuNeedsUpdate=TRUE;
	ConfigChanged=FALSE;
    }
    FreeAslRequest(FileRequester);
    return 1;
}
@


1.795
log
@Stuff.
@
text
@d1 2
a2 2
/* RCS Id: $Id: AmiFTP.c 1.736 1996/08/17 18:17:57 lilja Exp lilja $
   Locked version: $Revision: 1.736 $
d839 2
a840 2
	MainPrefs.mp_Height=MainWindow->Height;
	MainPrefs.mp_Width=MainWindow->Width;
d886 1
a886 1
	MainPrefs.mp_Height=MainWindow->Height-MainWindow->BorderTop-MainWindow->BorderBottom;;
@


1.736
log
@Transferwindow progressbar freaked out if the file was too big. now fixed.
Other stuff fixed.
@
text
@d1 2
a2 2
/* RCS Id: $Id: AmiFTP.c 1.730 1996/08/02 21:57:32 lilja Exp lilja $
   Locked version: $Revision: 1.730 $
d100 1
d103 4
a106 3
	  else
	    ConnectSite(sn1, 0);
	  UnlockWindow(MainWin_Object);
d175 1
d190 1
d294 19
a312 2
		if (node=(struct Node *)AllocMem(sizeof(struct Node), MEMF_ANY|MEMF_CLEAR)) {
		    if (node->ln_Name=strdup(DummyBuffer)) {
d315 1
a315 5
		    else {
			FreeMem(node, sizeof(struct Node));
		    }
		}
		else {
d317 2
d331 1
a331 4
    while (node=RemHead(&UploadList)) {
	free(node->ln_Name);
	FreeMem(node, sizeof(struct Node));
    }
d645 1
@


1.730
log
@AmiFTP starts even if no TCP/IP-stack is running.
No 'please insert inet:...' when starting.
Still has to fix the ARexx stuff to cope with no stack running.
@
text
@d1 2
a2 2
/* RCS Id: $Id: AmiFTP.c 1.720 1996/07/27 23:43:40 lilja Exp lilja $
   Locked version: $Revision: 1.720 $
d121 2
a122 1
	gotsignal=Wait(gotsignal);
@


1.720
log
@Select by pattern added.
DLPath()-function added to save some bytes (200 :).
@
text
@d1 2
a2 2
/* RCS Id: $Id: AmiFTP.c 1.713 1996/07/25 22:53:54 lilja Exp lilja $
   Locked version: $Revision: 1.713 $
d70 1
a70 1
    if (cliargs)
d119 3
a121 1
	res=tcp_waitselect(cin==-1?0:cin+1, &rs, NULL, NULL, NULL, &gotsignal);
d159 3
d202 3
d258 3
d325 3
d343 2
d388 3
d413 3
d574 3
d612 3
@


1.713
log
@Fixed 'AmiFTP ftp://ftp.boo.bar/'. Now using GetHead() etc instead of
ListHead()-functions.
@
text
@d1 2
a2 2
/* RCS Id: $Id: AmiFTP.c 1.710 1996/07/25 00:21:30 lilja Exp lilja $
   Locked version: $Revision: 1.710 $
d216 2
a217 28
    struct FileRequester *DirRequester;
    static ULONG dlpath_tags[]={
	ASL_Window, NULL,
	ASLFR_PrivateIDCMP, TRUE,
	ASLFR_SleepWindow, TRUE,
	ASLFR_InitialDrawer, NULL,
	ASLFR_DrawersOnly, TRUE,
	ASLFR_RejectIcons, TRUE,
	ASLFR_TitleText, NULL,
	ASLFR_InitialLeftEdge, NULL,
	ASLFR_InitialTopEdge, NULL,
	TAG_END
      };

    dlpath_tags[1]=(unsigned long)MainWindow;
    dlpath_tags[7]=(unsigned long)&CurrentState.CurrentDLDir[0];
    dlpath_tags[13]=(unsigned long)GetAmiFTPString(Str_SelectDLPath);
    dlpath_tags[15]=MainWindow->LeftEdge;
    dlpath_tags[17]=MainWindow->TopEdge;

    DirRequester=AllocAslRequest(ASL_FileRequest, NULL);
    if (!DirRequester)
      return 1;

    LockWindow(MainWin_Object);

    if (AslRequest(DirRequester, (struct TagItem *)dlpath_tags)) {
	strncpy(CurrentState.CurrentDLDir, DirRequester->rf_Dir, 255);
a219 4
    FreeAslRequest(DirRequester);

    UnlockWindow(MainWin_Object);

@


1.710
log
@Fontprefs seems to work ok, except in PrefsWindow.
@
text
@d1 2
a2 2
/* RCS Id: $Id: AmiFTP.c 1.692 1996/07/20 00:28:38 lilja Exp lilja $
   Locked version: $Revision: 1.692 $
d74 1
d77 1
a77 1
	  for (lbn=ListHead(&SiteList);ListEnd(lbn);lbn=ListNext(lbn)) {
d88 1
@


1.692
log
@Speedbar and buttons configurable.
@
text
@d1 2
a2 2
/* RCS Id: $Id: AmiFTP.c 1.630 1996/07/07 20:10:48 lilja Exp lilja $
   Locked version: $Revision: 1.630 $
d342 1
d344 1
d349 2
@


1.630
log
@Added items in the menu to duplicate the buttons.
@
text
@d1 2
a2 2
/* RCS Id: $Id: AmiFTP.c 1.625 1996/07/04 17:50:58 lilja Exp lilja $
   Locked version: $Revision: 1.625 $
d273 1
d817 2
a818 2
	MainPrefs.mp_Height=MainWindow->Height-MainWindow->BorderTop-MainWindow->BorderBottom;
	MainPrefs.mp_Width=MainWindow->Width-MainWindow->BorderLeft-MainWindow->BorderRight;
d864 1
a864 1
	MainPrefs.mp_Height=MainWindow->Height-MainWindow->BorderTop-MainWindow->BorderBottom;
@


1.625
log
@Cleaned up the code a bit.
Rename ftpwin.h to AmiFTP.h and ftpwin.c to AmiFTP.c.
Created Menu.c and moved all menu-functions there.
@
text
@d1 2
a2 2
/* RCS Id: $Id: ftpwin.c 1.595 1996/06/18 23:19:14 lilja Exp lilja $
   Locked version: $Revision: 1.595 $
d190 1
a190 1
int Get_Clicked(void)
@


1.595
log
@Fixed something.
,
@
text
@d1 2
a2 2
/* RCS Id: $Id: ftpwin.c 1.587 1996/06/14 13:23:25 lilja Exp lilja $
   Locked version: $Revision: 1.587 $
d5 1
a5 1
#include "ftpwin.h"
a6 2
#include <dos/dostags.h>
#include <workbench/workbench.h>
d25 1
a25 1
	strncpy(userid,ptr,strchr(ptr,'@@')-ptr);
d44 1
a44 1
	  strcpy(dir,ptr);
a45 12
#if 0
    else { /* site[:path] Should fix this so [name@@]site[path]*/
	ptr=url;
	ptr1=strchr(ptr,':');
	if (ptr1) {
	    strcpy(dir,ptr1+1);
	    strncpy(site,ptr,ptr1-ptr);
	}
	else
	  strcpy(site,ptr);
    }
#endif
d78 1
a78 1
				      LBNA_UserData,&sn1,
d80 2
a81 1
	      if ((stricmp((char *)cliargs->site,sn1->sn_Node.ln_Name)==0)&&(strlen(sn1->sn_Node.ln_Name)==strlen((char *)cliargs->site)))
d90 1
a90 1
	      parse_url(cliargs->site,site,dirpath,userid,&port);
d98 1
a98 1
	      ConnectSite(&sn,0);
d101 1
a101 1
	    ConnectSite(sn1,0);
d104 1
a104 1
    GetAttr(AREXX_SigMask,ARexx_Object,&rexxsignal);//rexxsignal=1L<<RexxPort->mp_SigBit;
d113 1
a113 1
	  FD_SET(cin,&rs);
d118 1
a118 1
//	gotsignal=Wait(rexxsignal|SIGBREAKF_CTRL_C|AG_Signal|mainwinsignal|appsignal);
d156 1
a156 1
    if (!change_remote_dir("..",0)) {
d158 3
a160 1
	    SetGadgetAttrs(MG_List[MG_ListView],MainWindow,NULL,LISTBROWSER_Labels,~0,TAG_DONE);
d162 7
a168 6
	    if (SetGadgetAttrs(MG_List[MG_ListView],MainWindow,NULL,
			       LISTBROWSER_Labels,FileList,
			       LISTBROWSER_AutoFit,TRUE,
			       LISTBROWSER_Selected,-1,
			       LISTBROWSER_MakeVisible,0,TAG_DONE))
	      RefreshGList(MG_List[MG_ListView],MainWindow,NULL,1);
d171 4
a174 2
	    AddCacheEntry(head,CurrentState.CurrentRemoteDir);
	    SetGadgetAttrs(MG_List[MG_ListView],MainWindow,NULL,LISTBROWSER_Labels,~0,TAG_DONE);
d176 7
a182 6
	    if (SetGadgetAttrs(MG_List[MG_ListView],MainWindow,NULL,
			       LISTBROWSER_Labels,FileList,
			       LISTBROWSER_AutoFit,TRUE,
			       LISTBROWSER_Selected,-1,
			       LISTBROWSER_MakeVisible,0,TAG_DONE))
	      RefreshGList(MG_List[MG_ListView],MainWindow,NULL,1);
a189 1

d197 1
a197 1
				LBNA_Selected,&sel,TAG_DONE);
d203 2
a204 1
	  DownloadFile(FileList, MainPrefs.mp_PreserveAminetDir?"T:":NULL,TransferMode,0);
d206 1
a206 1
	  DownloadFile(FileList,NULL,TransferMode,0);
d210 1
a210 1
}    
d216 9
a224 9
	ASL_Window,NULL,
	ASLFR_PrivateIDCMP,TRUE,
	ASLFR_SleepWindow,TRUE,
	ASLFR_InitialDrawer,NULL,
	ASLFR_DrawersOnly,TRUE,
	ASLFR_RejectIcons,TRUE,
	ASLFR_TitleText,NULL,
	ASLFR_InitialLeftEdge,NULL,
	ASLFR_InitialTopEdge,NULL,
d234 1
a234 1
    DirRequester=AllocAslRequest(ASL_FileRequest,NULL);
d240 2
a241 2
    if (AslRequest(DirRequester,(struct TagItem *)dlpath_tags)) {
	strncpy(CurrentState.CurrentDLDir,DirRequester->rf_Dir,255);
d253 1
a253 1
    strncpy(CurrentState.CurrentDLDir,GetString(MG_List[MG_DLString]),255);
d266 7
a272 7
	ASL_Window,NULL,
	ASLFR_PrivateIDCMP,TRUE,
	ASLFR_SleepWindow,FALSE,
	ASLFR_InitialDrawer,NULL,
	ASLFR_RejectIcons,TRUE,
	ASLFR_TitleText,NULL,
	ASLFR_DoMultiSelect,TRUE,
d283 1
a283 1
    FileRequester=AllocAslRequest(ASL_FileRequest,NULL);
d289 1
a289 1
    if (i=AslRequest(FileRequester,(struct TagItem *)put_tags)) {
d297 1
a297 1
	      strcpy(DummyBuffer,FileRequester->fr_Drawer);
d305 1
a305 1
		if (node=(struct Node *)AllocMem(sizeof(struct Node),MEMF_ANY|MEMF_CLEAR)) {
d307 1
a307 1
			AddTail(&UploadList,node);
d310 1
a310 1
			FreeMem(node,sizeof(struct Node));
d326 1
a326 1
      UploadFile(&UploadList,NULL,TransferMode);
d329 1
a329 1
	FreeMem(node,sizeof(struct Node));
d342 1
a342 1
	ConnectSite(sn,0);
d344 1
a344 1
	  strncpy(CurrentState.LastLVSite,sn->sn_Node.ln_Name,60);
d361 1
a361 1
	node=FindName(&SiteList,CurrentState.LastLVSite);
d364 1
a364 1
	    GetListBrowserNodeAttrs(node,LBNA_UserData,&sn,TAG_DONE);
d366 1
a366 1
		CopyMem(sn,&sn1,sizeof(struct SiteNode));
d372 1
a372 1
		strncpy(CurrentState.LastLVSite,sn->sn_Node.ln_Name,60);
d385 1
a385 1
	ConnectSite(&sn,0);
a392 1

d404 1
a404 1
	strcpy(bar,foo);
d419 1
a419 1
				LBNA_Selected,&sel,TAG_DONE);
d427 1
d429 1
a429 1
		if (readmename=NameToReadme(curr->name,curr->readmelength)) {
d435 1
a435 1
		    strmfp(fname,curr->owner,readmename);
d437 1
a437 1
		    memset(&tmpentry,0,sizeof(tmpentry));
d439 3
a441 3
						 LBNA_Column,0,
						 LBNCA_Text,fname,
						 LBNA_Selected,TRUE,
d448 3
a450 3
			AddTail(&tlist,tmpnode);
			if (!DownloadFile(&tlist,"T:",TransferMode,0)) {
			    strmfp(fname,"T:",readmename);
d467 1
a467 1
		CopyMem(curr,&tmpentry,sizeof(struct dirlist));
d470 3
a472 3
					     LBNA_Column,0,
					     LBNCA_Text,curr->name,
					     LBNA_Selected,TRUE,
d476 2
a477 2
		    AddTail(&tlist,tmpnode);
		    if (!DownloadFile(&tlist,"T:",TransferMode,0)) {
d479 2
a480 1
			SetListBrowserNodeAttrs(node,LBNA_Selected,FALSE,TAG_DONE);
d482 1
a482 1
			strmfp(loc_name,"T:",name);
d499 3
a501 3
					     LBNA_Column,0,
					     LBNCA_Text,curr->name,
					     LBNA_Selected,TRUE,
d505 1
a505 1
		if (!DownloadFile(&tlist,"T:",TransferMode,0)) {
d507 1
a507 1
		    SetListBrowserNodeAttrs(node,LBNA_Selected,FALSE,TAG_DONE);
d509 1
a509 1
		    strmfp(loc_name,"T:",curr->name);
d518 1
a518 1
				    LBNA_Selected,&sel,TAG_DONE);
d539 1
a539 1
	memset(node,0,sizeof(struct Node));
d542 1
a542 1
	    AddTail(&TempList,node);
d556 1
a556 1
	    t+=sprintf(t,"\"%s\"", file);
d559 1
a559 1
	    t+=sprintf(t,"\"%s\"", opts[OPT_SCREEN]?(char *)opts[OPT_SCREEN]:"Workbench"); /* Fix this */
d569 2
a570 1
    SystemTags(buffer,SYS_Input,NULL,SYS_Output,NULL,SYS_Asynch,TRUE,TAG_DONE);
d586 4
a589 4
	memset(site,0,100);
	memset(dirpath,0,255);
	memset(userid,0,30);
	memset(&sn,0,sizeof(sn));
d612 1
a612 1
    if (!change_remote_dir(GetString(MG_List[MG_DirName]),0)) {
d615 4
a618 2
	    AddCacheEntry(head,CurrentState.CurrentRemoteDir);
	    SetGadgetAttrs(MG_List[MG_ListView],MainWindow,NULL,LISTBROWSER_Labels,~0,TAG_DONE);
d620 5
a624 5
	    if (SetGadgetAttrs(MG_List[MG_ListView],MainWindow,NULL,
			       LISTBROWSER_Labels,FileList,
			       LISTBROWSER_AutoFit,TRUE,
			       LISTBROWSER_Selected,-1,
			       LISTBROWSER_MakeVisible,0,
d626 1
a626 1
	      RefreshGList(MG_List[MG_ListView],MainWindow,NULL,1);
d655 4
a658 4
	RTEZ_ReqTitle,NULL,
	RT_Window,NULL,
	RT_LockWindow,TRUE,
	RT_ReqPos,REQPOS_CENTERWIN,
d671 2
a672 2
    va_start(ap,str);
    rtEZRequestA(str,GetAmiFTPString(Str_OK),NULL,ap,(struct TagItem *)tags);
d680 7
a686 7
	RT_Window,NULL,
	RT_LockWindow,TRUE,
	RTGS_Invisible,TRUE,
	RTGS_TextFmt,NULL,
	RTGS_TextFmtArgs,NULL,
	RTGS_Flags,GSREQF_CENTERTEXT,
	RT_ReqPos,REQPOS_CENTERWIN,
d694 2
a695 1
    if (rtGetStringA(passbuf,24,GetAmiFTPString(Str_PasswordRequest),NULL,(struct TagItem *)tags))
a711 1
    geta4();
d718 5
a722 5
                  GA_TextAttr,AmiFTPAttrF,
                  GA_DrawInfo,DrawInfo,
                  LAYOUT_DeferLayout,TRUE,
                  LAYOUT_SpaceOuter,TRUE,
                  LAYOUT_Orientation,LAYOUT_ORIENT_VERT,
d725 3
a727 3
                    LAYOUT_AddImage,l=LabelObject,
                      LABEL_Mapping,mapping,
                      LABEL_Image,&im,
d729 13
a741 13
                    CHILD_MinWidth,im.Width,
                    CHILD_MinHeight,im.Height,
                    CHILD_WeightedWidth,0,
                    CHILD_WeightedHeight,0,

                    LAYOUT_AddImage,l=LabelObject,
                      LABEL_DrawInfo,DrawInfo,
                      IA_Font,AmiFTPAttrF,
                      LABEL_Justification,LJ_LEFT,
                      LABEL_Text,infotext,
                      LABEL_Text,CurrentState.RexxPort,
                      LABEL_Text,"\n",
                      LABEL_Text,GetAmiFTPString(Str_Translator),
d743 4
a746 4
                    CHILD_MinWidth,l->Width,
                    CHILD_MinHeight,l->Height,
                    CHILD_WeightedWidth,0,
                    CHILD_WeightedHeight,0,
d754 9
a762 9
                      WA_Title,GetAmiFTPString(Str_AboutAmiFTP),
                      WA_PubScreen,Screen,
                      WA_Top,MainWindow->TopEdge,
                      WA_Left,MainWindow->LeftEdge,
                      WA_DepthGadget,TRUE,
                      WA_DragBar,TRUE,
                      WA_CloseGadget,TRUE,
                      WA_Activate,TRUE,
                      WA_SmartRefresh,TRUE,
d776 2
a777 2
	GetAttr(WINDOW_SigMask,MainWin_Object,&mainwin);
	GetAttr(WINDOW_SigMask,AboutWin_Object,&aboutwin);
d789 1
a789 1
		while ((result=CA_HandleInput(AboutWin_Object,&code))!=WMHI_LASTMSG) {
a809 38
int AddToSitelist(void)
{
    struct SiteNode *sn;

    geta4();
    
    if (CurrentState.CurrentSite[0]==0)
      return 1;

    sn=AllocMem(sizeof(struct SiteNode),MEMF_CLEAR);
    if (sn) {
	sn->sn_Node.ln_Name=strdup(CurrentState.CurrentSite);
	if (!sn->sn_Node.ln_Name) {
	    FreeMem(sn,sizeof(struct SiteNode));
	    return 1;
	}
	sn->sn_SiteAddress=strdup(CurrentState.CurrentSite);
	if (!sn->sn_Node.ln_Name) {
	    free(sn->sn_Node.ln_Name);
	    FreeMem(sn,sizeof(struct SiteNode));
	    return 1;
	}
	sn->sn_RemoteDir=strdup(CurrentState.CurrentRemoteDir);
	if (!sn->sn_RemoteDir) {
	    free(sn->sn_Node.ln_Name);
	    free(sn->sn_SiteAddress);
	    FreeMem(sn,sizeof(struct SiteNode));
	    return 1;
	}
	sn->sn_Port=21;
	sn->sn_Proxy=MainPrefs.mp_DefaultProxy;
	sn->sn_Anonymous=1;
	AddLBNTail(&SiteList,sn);
	ConfigChanged=TRUE;
    }
    return 1;
}

d813 1
a813 1
    geta4();
d829 8
a836 8
    ASL_Window,NULL,
    ASLFR_PrivateIDCMP,TRUE,
    ASLFR_SleepWindow,TRUE,
    ASLFR_InitialDrawer,NULL,
    ASLFR_InitialFile,NULL,
    ASLFR_RejectIcons,TRUE,
    ASLFR_TitleText,NULL,
    ASLFR_DoSaveMode,NULL,
d844 3
a846 3
    geta4();
    memset(tmp,0,150);
    CopyMem(ConfigName,tmp,(ULONG)PathPart(ConfigName)-(ULONG)ConfigName);
d854 1
a854 1
    FileRequester=AllocAslRequest(ASL_FileRequest,NULL);
d857 3
a859 3
    if (AslRequest(FileRequester,(struct TagItem *)prefs_tags)) {
	strcpy(tmp,FileRequester->fr_Drawer);
	AddPart(tmp,FileRequester->fr_File,sizeof(tmp));
d880 3
a882 3
    geta4();
    memset(tmp,0,150);
    CopyMem(ConfigName,tmp,(ULONG)PathPart(ConfigName)-(ULONG)ConfigName);
d890 1
a890 1
    FileRequester=AllocAslRequest(ASL_FileRequest,NULL);
d893 3
a895 3
    if (AslRequest(FileRequester,(struct TagItem *)prefs_tags)) {
	strcpy(tmp,FileRequester->fr_Drawer);
	AddPart(tmp,FileRequester->fr_File,sizeof(tmp));
a911 60
    return 1;
}

int menu_LogWindow(struct MenuItem *menuitem)
{
    geta4();

    if (menuitem) {
	if (menuitem->Flags&CHECKED)
	  OpenLogWindow();
	else
	  CloseLogWindow();
    }
    
    return 1;
}

int ToggleDotFiles(struct MenuItem *menuitem)
{
    struct Node *node;
    ULONG attr;

    geta4();
    if (CurrentState.ADTMode)
      return 1;

    if (menuitem) {
	if (menuitem->Flags&CHECKED) {
	    if (FileList) {
		DetachToolList();
		for (node=ListHead(FileList);ListEnd(node);node=ListNext(node)) {
		    SetListBrowserNodeAttrs(node,LBNA_Flags,LBFLG_CUSTOMPENS,TAG_DONE);
		}
		AttachToolList(FALSE);
	    }
	    MainPrefs.mp_Showdotfiles=TRUE;
	}
	else {
	    if (FileList) {
		DetachToolList();
		for (node=ListHead(FileList);ListEnd(node);node=ListNext(node)) {
		    struct dirlist *n=(struct dirlist *)node->ln_Name;
		    if (n->name[0]=='.') {
			SetListBrowserNodeAttrs(node,
						LBNA_Flags,LBFLG_CUSTOMPENS|LBFLG_HIDDEN,
						LBNA_Selected,FALSE,TAG_DONE);
		    }
		}
		AttachToolList(FALSE);
		GetAttr(LISTBROWSER_Selected,MG_List[MG_ListView],&attr);
		if (attr) {
		    UpdateMainButtons(MB_FILESELECTED);
		}
		else {
		    UpdateMainButtons(MB_NONESELECTED);
		}
	    }
	    MainPrefs.mp_Showdotfiles=FALSE;
	}
    }
@


1.587
log
@Added RCS-variables to source-files.
@
text
@d1 2
a2 2
/* RCS Id: $Id$
   Locked version: $Revision$
d156 1
a156 2
    if (DEBUG)
      kprintf("Disconnecting\n");
d160 1
a160 2
    if (DEBUG)
      kprintf("Calling closewin\n");
a161 2
    if (DEBUG)
      kprintf("Window closed\n");
a314 1
//			kprintf("%s added to upload queue\n",node->ln_Name);
d332 1
a332 1
    if (!EmptyList(&UploadList) && !CurrentState.ADTMode)
a334 1
//	kprintf("Removing %s from upload queue\n",node->ln_Name);
@


1.586
log
@quit-bug probably fixed. Moved quit_ftp()-call from main.c to ftpwin.c
right before closing the window.
@
text
@d1 2
a2 2
/* ftpwin.c
   Code should work with v38
@


1.585
log
@Changed the parsing of the command line site.
ESC now closes all windows but connect- and transferwindow.
RETURN connects to the current site.
Using the Exec-list functions/macros.
New windowtitle, now with # of files selected and more.
@
text
@d157 5
@


1.541
log
@Fixed bug in UnlockWindow().
@
text
@d22 23
a44 17
	if (strchr(ptr,'@@')) {
	    strncpy(userid,ptr,strchr(ptr,'@@')-ptr);
	    ptr=strchr(ptr,'@@');
	    ptr++;
	}
	ptr1=site;
	while (*ptr!=0 && *ptr!=':' && *ptr!='/') {
	    *ptr1=*ptr;
	    ptr++;
	    ptr1++;
	}
	if (*ptr==':') {
	    ptr++;
	    *port=atol(ptr);
	    while (*ptr!=0 && isdigit(*ptr))
	      ptr++;
	}
d48 2
a49 1
    else { /* site[:path] */
d59 1
a65 1
    extern ULONG IDCMPHookFunc(void);
a69 4
    IDCMPHook.h_Entry=(HOOKFUNC)IDCMPHookFunc;
    IDCMPHook.h_SubEntry=NULL;
    IDCMPHook.h_Data=NULL;
    
d90 1
a90 1
	  for (lbn=GetHead(&SiteList);lbn;lbn=GetSucc(lbn)) {
d202 1
a202 1
    for (node=GetHead(FileList);node;node=GetSucc(node)) {
d260 2
d332 1
a332 1
    if (GetHead(&UploadList) && !CurrentState.ADTMode)
d426 1
a426 1
    for (node=GetHead(FileList);node;node=GetSucc(node)) {
d523 1
a523 1
	for (node=GetHead(FileList);node;node=GetSucc(node)) {
d589 6
d596 5
a600 3
	sn.sn_Node.ln_Name=GetString(MG_List[MG_SiteName]);
	sn.sn_SiteAddress=sn.sn_Node.ln_Name;
	sn.sn_Port=ftp_port;
d602 4
a605 1
	sn.sn_Anonymous=1;
d631 1
d633 1
d767 1
a768 2
                      WINDOW_IDCMPHook,&IDCMPHook,
                      WINDOW_IDCMPHookBits,IDCMP_RAWKEY,
d798 6
d984 1
a984 1
		for (node=GetHead(FileList);node;node=GetSucc(node)) {
d994 1
a994 1
		for (node=GetHead(FileList);node;node=GetSucc(node)) {
@


1.531
log
@Lots of stuff
@
text
@d125 1
a125 1
	GetAttr(WINDOW_SigMask,MainWin_Object,&mainwinsignal);
d127 1
a127 1
	res=tcp_waitselect(cin==-1?0:cin+1,&rs,NULL,NULL,NULL,&gotsignal);
@


1.430
log
@Fixed name/date-sorting in ADT-mode.
@
text
@d61 2
d66 2
d146 2
a147 1
	    LockWindow(MainWin_Object);
d149 2
a150 1
	    UnlockWindow(MainWin_Object);
d153 2
d156 2
d327 1
a327 1
    if (GetHead(&UploadList))
d839 1
d886 1
@


1.401
log
@Started on improving the functionnames.
Added Aminet-mode, not 100% finished yet.
Reworked the prefs-window, not everything is finished.
Started using listbrowser v41-functions.
Added parsing of URL-like commandline.
@
text
@a249 1

a562 1

@


1.265
log
@Groups added. Bugs fixed.
@
text
@d16 38
d91 11
a101 2
	      sn.sn_SiteAddress=(char *)cliargs->site;
	      sn.sn_Node.ln_Name=(char *)cliargs->site;
d103 1
a103 1
	      sn.sn_Port=ftp_port;
d114 7
d122 23
a144 13

	gotsignal=Wait(rexxsignal|SIGBREAKF_CTRL_C|AG_Signal|mainwinsignal|appsignal);
	if (gotsignal&SIGBREAKF_CTRL_C)
	  break;
	if (gotsignal&(mainwinsignal|appsignal)) {
	    if (HandleMainWindowIDCMP(TRUE))
	      running=FALSE;
	}
	if (gotsignal&rexxsignal) {
	    ARexxQuitBit=FALSE;
	    CA_HandleRexx(ARexx_Object);
	    if (ARexxQuitBit)
	      running=FALSE;
a145 2
	if (gotsignal&AG_Signal)
	  HandleAmigaGuide();
d196 4
a199 1
	DownloadFile(FileList,NULL,TransferMode,0);
d395 10
d406 1
a406 1
int View_clicked(void)
d420 32
d944 2
@


1.200
log
@GETATTR-hit fixed.
@
text
@a269 1
    LockWindow(MainWin_Object);
a274 1
    UnlockWindow(MainWin_Object);
a286 2
    LockWindow(MainWin_Object);

a318 2
    UnlockWindow(MainWin_Object);

d466 1
a466 1
    LockWindow(MainWin_Object);
d478 1
a478 1
    UnlockWindow(MainWin_Object);
d839 2
a840 2
	if (FileList) {
	    if (menuitem->Flags&CHECKED) {
a845 1
		MainPrefs.mp_Showdotfiles=TRUE;
d847 4
a850 1
	    else {
a867 1
		MainPrefs.mp_Showdotfiles=FALSE;
d869 1
@


1.184
log
@Hopefully fixed upload/download bug with refreshglist()
@
text
@d122 1
a122 1
int Get_Clicked()
d137 1
d422 1
a422 1
int ViewFile(const char *file)
d857 1
a857 1
		    struct dirlist *n=(struct Node *)node->ln_Name;
@


1.173
log
@bugversion
@
text
@d118 1
a118 1
    return(1);
d163 1
a163 1
      return(1);
d175 1
a175 1
    return(1);
d181 1
a181 1
    return(1);
d211 1
a211 1
      return(1);
d234 1
a234 1
			kprintf("%s added to upload queue\n",node->ln_Name);
d248 1
a248 1
	return(1);
d255 1
a255 1
	kprintf("Removing %s from upload queue\n",node->ln_Name);
d262 1
a262 1
    return(1);
d277 1
a277 1
    return(1);
d286 1
a286 1
      return(1);
d324 1
a324 1
    return(1);
d332 1
a332 1
    return(1);
d418 1
a418 1
    return(1);
d469 1
a469 1
	return(1);
d484 1
a484 1
    return(1);
d513 1
a513 1
    return(1);
d571 1
a571 1
      return(passbuf);
d573 1
a573 1
      return(NULL);
d627 1
a627 1
      return(1);
d645 1
a645 1
	return (1);
d678 1
a678 1
    return (1);
d688 1
a688 1
      return (1);
d695 1
a695 1
	    return (1);
d701 1
a701 1
	    return (1);
d708 1
a708 1
	    return (1);
d716 1
a716 1
    return (1);
d733 1
a733 1
    return(1);
d764 1
a764 1
      return(1);
d780 1
a780 1
    return(1);
d799 1
a799 1
      return(1);
d819 1
a819 1
    return(1);
d833 1
a833 1
    return (1);
d875 1
a875 1
    return (1);
@


1.152
log
@ARexx viewcommand tried to view the wrong file.
@
text
@d92 1
a92 3
    geta4();

    LockWindow(MainWindow);
d117 1
a117 1
    UnlockWindow(MainWindow);
a153 1
    geta4();
a179 1
    geta4();
d194 1
a194 1
	ASLFR_SleepWindow,TRUE,
d201 1
a216 1
	char DummyBuffer[1024];
a220 1
		    
d224 1
d229 1
d234 1
d255 1
a268 2
    geta4();

a329 2
    geta4();

a465 3

    geta4();

a489 1
    geta4();
@


1.150
log
@Iconify while transferring added.
Nicer update of fuelgauge.
@
text
@a355 1
//	kprintf("pling\n");Delay(25);
a360 4
		char buffer[200];
		char *str=MainPrefs.mp_ViewCommand;
		char *t=&buffer[0];

a373 1
//		AddTail(&tlist,&tmpentry);
d379 1
a379 34
			{
			    struct Node *node;
			    node=malloc(sizeof(struct Node));
			    if (node) {
				memset(node,0,sizeof(struct Node));
				node->ln_Name=strdup(loc_name);
				if (node->ln_Name) {
				    AddTail(&TempList,node);
				}
				else
				  free(node);
			    }
			}
			while (*str) {
			    if (*str!='%') {
				*t++ = *str++;
				continue;
			    }
			    str+=2;
			    switch(str[-1]) {
			      case 'F': 
				t+=sprintf(t,"\"%s\"", loc_name);
				break;
			      case 'P':
				t+=sprintf(t,"\"%s\"", opts[OPT_SCREEN]?(char *)opts[OPT_SCREEN]:"Workbench"); /* Fix this */
				break;
			      default:
				*t++=str[-2];
				*t++=str[-1];
				break;
			    }
			}
			*t=0;
			SystemTags(buffer,SYS_Input,NULL,SYS_Output,NULL,SYS_Asynch,TRUE,TAG_END);
a390 3
	    char buffer[200];
	    char *str=MainPrefs.mp_ViewCommand;
	    char *t=&buffer[0];
a392 1
//	    kprintf("plong %ld\n",__LINE__);Delay(50);
a400 2
//	    AddTail(&tlist,&tmpentry);
//		kprintf("plnk %ld\n",__LINE__);Delay(50);
d406 1
a406 36
//		    Printf("curr->name: '%s'\nloc_name: '%s'\n",curr->name,loc_name);
		    {
			struct Node *node;
			node=malloc(sizeof(struct Node));
			if (node) {
			    memset(node,0,sizeof(struct Node));
			    node->ln_Name=strdup(loc_name);
			    if (node->ln_Name) {
				AddTail(&TempList,node);
			    }
			    else
			      free(node);
			}
		    }
		    while (*str) {
			if (*str!='%') {
			    *t++ = *str++;
			    continue;
			}
			str+=2;
			switch(str[-1]) {
			  case 'F': 
			    t+=sprintf(t,"\"%s\"", loc_name);
			    break;
			  case 'P':
			    t+=sprintf(t,"\"%s\"", opts[OPT_SCREEN]?(char *)opts[OPT_SCREEN]:"Workbench"); /* Fix this */
			    break;
			  default:
			    *t++=str[-2];
			    *t++=str[-1];
			    break;
			}
		    }
		    *t=0;
//		    Printf("Launching '%s'\n",buffer);
		    SystemTags(buffer,SYS_Input,NULL,SYS_Output,NULL,SYS_Asynch,TRUE,TAG_DONE);
@


1.124
log
@AmiTCP and AS225r2 support in the same binary.
ARexx-command VIEW added.
New option to SETATTR, QUIET.
SETATTR LOCALDIR didn't update the download dir-gadget.
GETATTR STEM=bar didn't work since bar is in lowercase.
Enforcer hits when trying to open AmiFTP on a non-existing screen removed.
Moved 'Show dot-files?' to the Settings-menu.
Icelandic and Spanish catalogs added.
@
text
@a17 1
    APTR wlock;
d43 1
a43 2
	  if (MainWindow)
	    wlock=rtLockWindow(MainWindow);
d61 1
a61 2
	  if (MainWindow)
	    rtUnlockWindow(MainWindow,wlock);
a90 1
    APTR wlock;
d94 1
a94 1
    wlock=rtLockWindow(MainWindow);
d119 1
a119 1
    rtUnlockWindow(MainWindow,wlock);
d124 1
a124 1
int __asm __saveds Get_Clicked(register __a0 Object *obj, register __a1 struct IntuiMessage *msg)
a127 3
    APTR wlock;

    geta4();
d135 1
a135 1
//	wlock=rtLockWindow(MainWindow);
d137 1
a137 1
//	rtUnlockWindow(MainWindow,wlock);
a138 2
    Printf("Tjo\n");
    Delay(50);
a155 2
    APTR wlock;

d168 1
a168 1
    wlock=rtLockWindow(MainWindow);
d176 1
a176 1
    rtUnlockWindow(MainWindow,wlock);
a204 2
    APTR wlock;
    geta4();
d216 1
a216 1
    wlock=rtLockWindow(MainWindow);
d249 1
a249 1
	rtUnlockWindow(MainWindow,wlock);
d261 1
a261 1
    rtUnlockWindow(MainWindow,wlock);
a268 1
    APTR wlock;
d272 1
a272 1
    wlock=rtLockWindow(MainWindow);
d278 1
a278 1
    rtUnlockWindow(MainWindow,wlock);
a284 1
    APTR wlock;
d291 1
a291 1
    wlock=rtLockWindow(MainWindow);
d325 1
a325 1
    rtUnlockWindow(MainWindow,wlock);
a345 3
    APTR wlock;

    geta4();
d353 1
a353 1
	wlock=rtLockWindow(MainWindow);
d501 1
a501 1
	rtUnlockWindow(MainWindow,wlock);
a550 1
    APTR wlock;
d559 1
a559 1
    wlock=rtLockWindow(MainWindow);
d571 1
a571 1
    rtUnlockWindow(MainWindow,wlock);
a577 1
    APTR wlock;
d580 1
a580 1
    wlock=rtLockWindow(MainWindow);
d595 1
a595 1
	rtUnlockWindow(MainWindow,wlock);
d599 1
a599 1
	rtUnlockWindow(MainWindow,wlock);
d737 2
d766 1
d813 1
a813 2
	APTR wlock;
	wlock=rtLockWindow(MainWindow);
d819 1
a819 1
	rtUnlockWindow(MainWindow,wlock);
@


0.1332
log
@Release 1.0
AmiFTP doesn't need amigaguide.library in order to start.
@
text
@d22 2
a27 1

d66 1
a66 1
    rexxsignal=1L<<RexxPort->mp_SigBit;
d80 4
a83 1
	    running=HandleRexxMsg();
d142 1
a142 1
	wlock=rtLockWindow(MainWindow);
d144 1
a144 1
	rtUnlockWindow(MainWindow,wlock);
d146 2
d524 43
d646 1
d651 3
d703 1
a706 1
                  HAlign(LALIGN_CENTER),
a707 1
//                  LAYOUT_BevelStyle,BVS_THIN,
a709 1
//                    LAYOUT_VertAlignment,LALIGN_CENTER,
d721 1
d726 1
a726 1
                      GetAmiFTPString(Str_Translator)?LABEL_Text:TAG_IGNORE,GetAmiFTPString(Str_Translator),
d943 41
@


0.1302
log
@Connecting to a site from the commandline now works.
@
text
@d658 1
d711 3
a713 1
	    mask=Wait(aboutwin|mainwin|AG_Signal);
@


0.1300
log
@Added Reload-gadget.
Added Sort-gadget to sitelist-window.
AmiFTP now show the correct size of links during transfer.
@
text
@d53 1
a53 1
	  if (!sn1) {
d56 1
@


0.857
log
@Log-window function working. Only thing missing a to control it from ARexx.
@
text
@a10 2
extern long lvord;
extern BOOL ShowFiles;
d18 2
d21 6
a26 14
    APTR wlock;
    ULONG gotsignal,mainwinsignal=0,rexxsignal,appsignal;
    extern ULONG AG_Signal;
    struct AppIcon *ai=NULL;
    struct DiskObject *dobj;
    ULONG gd;

    gd = dobj = GetDiskObject("AmiFTP");
    if (!dobj) {
	gd=dobj=GetDiskObject("PROGDIR:AmiFTP");
	if (!dobj)
	  dobj = GetDefDiskObject(WBTOOL);
    }
    CurrentState.Height=MainPrefs.mp_Height;
d28 4
a31 2
	if(OpenFTPWindow())
	  return;
d34 4
a37 1
	ai=AddAppIcon(0,0,"AmiFTP",AppPort,NULL,dobj,NULL);
a38 2
    ShowFiles=FALSE; 
    FileList=NULL;
d40 26
a65 21
      if (cliargs->site)
	if (mainWin) {
	    wlock=rtLockWindow(mainWin);
	    {
		struct SiteNode sn,*sn1;
		memset(&sn,0,sizeof(sn));
		for (sn1=(struct SiteNode *)GetHead(&SiteList);sn1;sn1=(struct SiteNode *)GetSucc((struct Node *)sn1))
		  if ((stricmp((char *)cliargs->site,sn1->sn_Node.ln_Name)==0)&&(strlen(sn1->sn_Node.ln_Name)==strlen((char *)cliargs->site)))
		    break;
		if (!sn1) {
		    sn.sn_SiteAddress=(char *)cliargs->site;
		    sn.sn_Node.ln_Name=(char *)cliargs->site;
		    sn.sn_Port=ftp_port;
		    ConnectSite(&sn,0);
		}
		else
		  ConnectSite(sn1,0);
	    }
	if (mainWin)
	  rtUnlockWindow(mainWin,wlock);
    }
a66 4
    if (mainWin)
      mainwinsignal=1<<mainWin->UserPort->mp_SigBit;
    rexxsignal=1<<RexxPort->mp_SigBit;
    appsignal=1<<AppPort->mp_SigBit;
d68 8
a75 9
	gotsignal=Wait(mainwinsignal|rexxsignal|appsignal|AG_Signal|SIGBREAKF_CTRL_C);
	if (gotsignal&mainwinsignal) {
	    running=HandleFTPIDCMP();
	    if (running==2 && dobj && !ai) {
		CloseFTPWindow();
		mainWin=NULL;
		mainwinsignal=0;
		ai=AddAppIcon(0,0,"AmiFTP",AppPort,NULL,dobj,NULL);
	    }
a78 30
	    if (running==2 && dobj && !ai) {
		CloseFTPWindow();
		mainWin=NULL;
		mainwinsignal=0;
		ai=AddAppIcon(0,0,"AmiFTP",AppPort,NULL,dobj,NULL);
	    }
	}
	if (!mainwinsignal && mainWin)
	  mainwinsignal=1<<mainWin->UserPort->mp_SigBit;
	if (mainwinsignal && !mainWin)
	  mainwinsignal=0;
	if (gotsignal&SIGBREAKF_CTRL_C)
	  running=0;
	if (gotsignal&appsignal) {
	    struct AppMessage *amsg;
	    while(amsg = (struct AppMessage *)GetMsg(AppPort)) {
		if (amsg->am_Type==AMTYPE_APPICON && amsg->am_NumArgs==0 && amsg->am_ArgList==NULL) {
		    ReplyMsg((struct Message *)amsg);
		    if (!OpenFTPWindow()) {
			RemoveAppIcon(ai);
			ai=NULL;
			mainwinsignal=1<<mainWin->UserPort->mp_SigBit;
		    }
		} 
		else
		  ReplyMsg((struct Message *)amsg);
	    }
	}
	if (gotsignal&AG_Signal) {
	    HandleAmigaGuide();
d80 2
d83 1
a83 8
    if (mainWin)
      CloseFTPWindow();

    if (ai)
      RemoveAppIcon(ai);
    if (gd)
      FreeDiskObject(dobj);
    mainWin=0;
d91 3
a93 1
    wlock=rtLockWindow(mainWin);
d95 10
a104 2
	if (head=LookupCache(CurrentState.CurrentRemoteDir))
	  FileList=head;
d107 1
d109 6
a115 3
	DetachToolList();
	AttachToolList();
	RefreshWinGad();
d118 1
a118 1
    rtUnlockWindow(mainWin,wlock);
d122 2
a123 1
int File_clicked(void)
d125 2
d129 6
a134 115
    if (lvord == mainMsg.Code && DoubleClick(lsecs,lmics,mainMsg.Seconds,mainMsg.Micros)) {
	struct dirlist *curr;
	struct List *head;
	long i;
	for (curr=(struct dirlist *)GetHead(FileList),i=0;curr;curr=(struct dirlist *)GetSucc((struct Node *)curr),i++)
	  if (i>=lvord)break;
	if (curr) {
	    wlock=rtLockWindow(mainWin);
	    /* Check for link */
	    if (S_ISLNK(curr->mode)) {
		char *name;
		name = linkname(curr->name);

		if (name) {
		    if (change_remote_dir(name,0)==ENOTDIR) {
			struct dirlist tmp;
			struct List tlist;
			CopyMem(curr,&tmp,sizeof(struct dirlist));
			NewList(&tlist);
			AddTail(&tlist,&tmp);
			DownloadFile(&tlist,NULL,TransferMode,0);
		    }
		    else {
			if (head=LookupCache(CurrentState.CurrentRemoteDir)) {
			    DetachToolList();
			    RefreshWinGad();
			    FileList=head;
			    AttachToolList();
			    RefreshWinGad();
			    ShowFiles=TRUE;
			    UpdateMainButtons(MB_NONESELECTED);
			    lvord=-1;
			}
			else if (head=read_remote_dir()) {
			    DetachToolList();
			    RefreshWinGad();
			    AddCacheEntry(head,CurrentState.CurrentRemoteDir);
			    FileList=head;
			    AttachToolList();
			    RefreshWinGad();
			    ShowFiles=TRUE;
			    UpdateMainButtons(MB_NONESELECTED);
			    lvord=-1;
			    
			}
			else
			  ShowErrorReq(GetAmiFTPString(Str_ErrorReadingDir));
		    }
		    free(name);
		}
	    }
	    /* Check for file or dir */
	    else if (curr->mode&0x4000) {
		if (!change_remote_dir(curr->name,0)) {
		    if (head=LookupCache(CurrentState.CurrentRemoteDir)) {
			DetachToolList();
			RefreshWinGad();
			FileList=head;
			AttachToolList();
			RefreshWinGad();
			ShowFiles=TRUE;
			UpdateMainButtons(MB_NONESELECTED);
			lvord=-1;
		    }
		    else if(head=read_remote_dir()) {
			DetachToolList();
			RefreshWinGad();
			AddCacheEntry(head,CurrentState.CurrentRemoteDir);
			FileList=head;
			AttachToolList();
			RefreshWinGad();
			ShowFiles=TRUE;
			UpdateMainButtons(MB_NONESELECTED);
			lvord=-1;
		    }
		    else
		      ShowErrorReq(Str_ErrorReadingDir);
		}
		else {
		    RemoteCDFailed();
		}
	    }
	    else {
		if (mainMsg.Qualifier&(IEQUALIFIER_LSHIFT|IEQUALIFIER_RSHIFT))
		  DownloadFile(FileList,NULL,TransferMode,0);
		else {
		    struct dirlist tmp;
		    struct List tlist;
		    CopyMem(curr,&tmp,sizeof(struct dirlist));
		    NewList(&tlist);
		    AddTail(&tlist,&tmp);
		    DownloadFile(&tlist,NULL,TransferMode,0);
		}
	    }
	    rtUnlockWindow(mainWin,wlock);
	}
    }
    else {
	if (mainMsg.Code!=-1) {
	    struct dirlist *curr,*head;
	    long i;
	    GT_SetGadgetAttrs(mainGadgets[GD_Files_LV],mainWin,NULL,GTLV_Labels,~0,GTLV_Selected,~0,TAG_DONE);
	    for (curr=(struct dirlist *)GetHead(FileList),i=0;curr;curr=(struct dirlist *)GetSucc((struct Node *)curr),i++)
	      if (i>=mainMsg.Code)break;
	    if (mainMsg.Qualifier&(IEQUALIFIER_LSHIFT|IEQUALIFIER_RSHIFT)) {
		curr->dl_Node.ln_Type=curr->dl_Node.ln_Type==0?1:0;
	    }
	    else {
		head=curr;
		for (curr=(struct dirlist *)GetHead(FileList);curr;curr=(struct dirlist *)GetSucc((struct Node *)curr)) curr->dl_Node.ln_Type=0;
		head->dl_Node.ln_Type=1;
	    }
	    GT_SetGadgetAttrs(mainGadgets[GD_Files_LV],mainWin,NULL,GTLV_Labels,FileList,GTLV_Selected,~0,TAG_DONE);
	}
	UpdateMainButtons(MB_FILESELECTED);
d136 2
a137 20
    lvord=mainMsg.Code;

    lsecs=mainMsg.Seconds;
    lmics=mainMsg.Micros;

    return(1);
}

int Get_clicked(void)
{
    struct dirlist *curr;
    long i;
    APTR wlock;

    if (lvord == -1 )
      return(1);
    for (curr=(struct dirlist *)GetHead(FileList),i=0;curr;curr=(struct dirlist *)GetSucc((struct Node *)curr),i++)
      if (i>=lvord)break;
    if (curr) {
	wlock=rtLockWindow(mainWin);
d139 1
a139 22
	/* Check for link
	if (S_ISLNK(curr->mode)) {
	    char *name;
	    name = linkname(curr->name);
	    if (name) {
		struct dirlist tmp;
		struct List tlist;
		CopyMem(curr,&tmp,sizeof(struct dirlist));
		NewList(&tlist);
		AddTail(&tlist,&tmp);
		DownloadFile(&tlist,NULL,TransferMode,0);
		free(name);
	    }
	}
	else
	if (curr->mode&0x4000) {
	    ShowErrorReq(GetAmiFTPString(Str_CannotDLDirs));
	}
	else {
	    DownloadFile(FileList,NULL,TransferMode,0);
	}*/
	rtUnlockWindow(mainWin,wlock);
d160 3
a162 1
    dlpath_tags[1]=(unsigned long)mainWin;
d165 2
a166 2
    dlpath_tags[15]=mainWin->LeftEdge;
    dlpath_tags[17]=mainWin->TopEdge;
d172 1
a172 1
    wlock=rtLockWindow(mainWin);
d180 1
a180 1
    rtUnlockWindow(mainWin,wlock);
d187 2
a188 1
    strncpy(CurrentState.CurrentDLDir,GetString(mainGadgets[GD_DLPathName]),255);
d210 1
d212 1
a212 1
    put_tags[1]=(unsigned long)mainWin;
d222 1
a222 1
    wlock=rtLockWindow(mainWin);
d255 1
a255 1
	rtUnlockWindow(mainWin,wlock);
d267 1
a267 1
    rtUnlockWindow(mainWin,wlock);
d277 3
a279 1
    wlock=rtLockWindow(mainWin);
d285 1
a285 1
    rtUnlockWindow(mainWin,wlock);
d294 2
d299 1
a299 1
    wlock=rtLockWindow(mainWin);
d303 3
a305 2
	sn=(struct SiteNode *)FindName(&SiteList,CurrentState.LastLVSite);
	if (sn) {
d307 10
a316 6
	    CopyMem(sn,&sn1,sizeof(struct SiteNode));
	    sn1.sn_RemoteDir=strdup(CurrentState.CurrentRemoteDir);
	    sn1.sn_LocalDir=CurrentState.CurrentDLDir;
	    ConnectSite(&sn1,0);
	    if (sn1.sn_RemoteDir)
	      free(sn1.sn_RemoteDir);
a317 1
	strncpy(CurrentState.LastLVSite,sn->sn_Node.ln_Name,60);
d333 1
a333 1
    rtUnlockWindow(mainWin,wlock);
d341 2
d352 2
a353 1
    long i;
d356 10
a365 6
    if (lvord == -1 )
      return(1);
    for (curr=(struct dirlist *)GetHead(FileList),i=0;curr;curr=(struct dirlist *)GetSucc((struct Node *)curr),i++)
      if (i>=lvord)break;
    if (curr) {
	wlock=rtLockWindow(mainWin);
d367 1
d378 1
d382 75
a456 1
		AddTail(&tlist,&tmpentry);
d458 5
a462 1
		    strmfp(loc_name,"T:",name);
d496 2
a497 1
		    SystemTags(buffer,SYS_Input,NULL,SYS_Output,NULL,SYS_Asynch,TRUE,TAG_END);
d499 1
a499 1
		free(name);
d502 5
a506 2
	else if (curr->mode&0x4000) {/* Check for file or dir */
	    ShowErrorReq(GetAmiFTPString(Str_CannotDLDirs));
d508 5
a512 50
	else {
	    char loc_name[200];
	    char buffer[200];
	    char *str=MainPrefs.mp_ViewCommand;
	    char *t=&buffer[0];
	    struct List tlist;
	    struct dirlist tmpentry;
	    CopyMem(curr,&tmpentry,sizeof(struct dirlist));
	    NewList(&tlist);
	    AddTail(&tlist,&tmpentry);
	    if (!DownloadFile(&tlist,"T:",TransferMode,0)) {
		strmfp(loc_name,"T:",curr->name);
		{
		    struct Node *node;
		    node=malloc(sizeof(struct Node));
		    if (node) {
			memset(node,0,sizeof(struct Node));
			node->ln_Name=strdup(loc_name);
			if (node->ln_Name) {
			    AddTail(&TempList,node);
			}
			else
			  free(node);
		    }
		}
		while (*str) {
		    if (*str!='%') {
			*t++ = *str++;
			continue;
		    }
		    str+=2;
		    switch(str[-1]) {
		      case 'F': 
			t+=sprintf(t,"\"%s\"", loc_name);
			break;
		      case 'P':
			t+=sprintf(t,"\"%s\"", opts[OPT_SCREEN]?(char *)opts[OPT_SCREEN]:"Workbench"); /* Fix this */
			break;
		      default:
			*t++=str[-2];
			*t++=str[-1];
			break;
		    }
		}
		*t=0;
		    
		SystemTags(buffer,SYS_Input,NULL,SYS_Output,NULL,SYS_Asynch,TRUE,TAG_DONE);
	    }
	}
	rtUnlockWindow(mainWin,wlock);
d521 3
a523 1
    if (!strlen(GetString(mainGadgets[GD_SiteName]))) {
d528 1
a528 1
    wlock=rtLockWindow(mainWin);
d532 1
a532 1
	sn.sn_Node.ln_Name=GetString(mainGadgets[GD_SiteName]);
d540 1
a540 1
    rtUnlockWindow(mainWin,wlock);
d548 1
d550 2
a551 2
    wlock=rtLockWindow(mainWin);
    if (!change_remote_dir(GetString(mainGadgets[GD_DirName]),0)) {
a553 2
	    DetachToolList();
	    RefreshWinGad();
d555 1
d557 7
a563 3
	    AttachToolList();
	    RefreshWinGad();
	    ShowFiles=TRUE;
d565 1
d569 1
a571 1
    rtUnlockWindow(mainWin,wlock);
d577 1
a577 1
    if (mainWin)
d597 1
a597 1
    if (!mainWin)
d601 1
a601 1
    tags[3]=(ULONG)mainWin;
d609 1
a609 1
    extern struct Window *connect_Win; /* Fix this: Bug in reqtools */
d621 1
a621 1
    tags[1]=(ULONG)connect_Win;
d632 3
d638 91
a728 14
    static ULONG tags[]={
	RTEZ_ReqTitle,NULL,
	RT_Window,NULL,
	RT_ReqPos,REQPOS_TOPLEFTWIN,
	RT_LockWindow,TRUE,
	TAG_DONE
    };
    char *trans[2];
    trans[0]=CurrentState.RexxPort;
    trans[1]=GetAmiFTPString(Str_Translator);
    tags[1]=(ULONG)GetAmiFTPString(Str_AboutAmiFTP);
    tags[3]=(unsigned long)mainWin;
    rtEZRequestA(infotext,GetAmiFTPString(Str_OK),NULL,&trans,(struct TagItem *)tags);
    return(1);
d734 2
d763 1
a763 1
	AddTail(&SiteList,sn);
d772 2
a773 1
    if (ConfigChanged || CurrentState.LeftEdge!=mainWin->LeftEdge || CurrentState.TopEdge!=mainWin->TopEdge) {
d775 5
a779 4
	wlock=rtLockWindow(mainWin);
	MainPrefs.mp_Height=mainWin->Height;
	MainPrefs.mp_TopEdge=mainWin->TopEdge+myScn->ViewPort.DyOffset;
	MainPrefs.mp_LeftEdge=mainWin->LeftEdge+myScn->ViewPort.DxOffset;
d781 1
a781 1
	rtUnlockWindow(mainWin,wlock);
d803 1
d807 1
a807 1
    prefs_tags[1]=(unsigned long)mainWin;
d822 4
a825 5
	if (DEBUG)
	  Printf("Writing config\n");
	MainPrefs.mp_Height=mainWin->Height;
	MainPrefs.mp_TopEdge=mainWin->TopEdge+myScn->ViewPort.DyOffset;
	MainPrefs.mp_LeftEdge=mainWin->LeftEdge+myScn->ViewPort.DxOffset;
a826 2
	if (DEBUG)
	  Printf("Config written\n");
d830 1
a830 1
    if (DEBUG) Printf("Returning from SavePrefsAs()\n");
d838 1
d842 1
a842 1
    prefs_tags[1]=(unsigned long)mainWin;
d873 1
a873 1
int menu_LogWindow(void)
d875 2
a876 2
    extern struct Menu *menu;
    struct MenuItem *menuitem=ItemAddress(menu,mainMsg.Code);
@


0.827
log
@Add Current to sitelist added.
More rtLockWindow()'s
Leeching seems to work, but is not finished yet.
@
text
@d895 15
@


0.814
log
@Added default download-dir.
@
text
@d329 1
d340 3
d348 3
d377 1
d388 3
d422 1
d433 3
a435 1
    
d457 2
d461 3
d491 3
d660 1
a661 1
	wlock=rtLockWindow(mainWin);
a671 1
	rtUnlockWindow(mainWin,wlock);
d677 1
d755 36
@


0.807
log
@Added AmigaGuide on-line help.
@
text
@d357 1
a357 1
    struct Node *node,*next;
d505 1
a505 1
		int res;
d537 1
a537 1
			    t+=sprintf(t,"\"%s\"", opts[OPT_SCREEN]?opts[OPT_SCREEN]:"Workbench"); /* Fix this */
@


0.774
log
@Now handles filenames up to 128 chars, atleast in DownloadFile().
@
text
@d23 1
d72 1
a72 1
	gotsignal=Wait(mainwinsignal|rexxsignal|appsignal|SIGBREAKF_CTRL_C);
d111 3
@


0.757
log
@Slightly improved timedout-control.
View handles spaces in filenames now (added a pair of \")
@
text
@d9 1
a9 1
//#include "AppIcon.image"
d14 2
d43 18
a60 14
    if (opts[OPT_SITE]) {
	if (mainWin)
	  wlock=rtLockWindow(mainWin);
	{
	    struct SiteNode sn,*sn1;
	    memset(&sn,0,sizeof(sn));
	    for (sn1=(struct SiteNode *)GetHead(&SiteList);sn1;sn1=(struct SiteNode *)GetSucc((struct Node *)sn1))
	      if ((stricmp((char *)opts[OPT_SITE],sn1->sn_Node.ln_Name)==0)&&(strlen(sn1->sn_Node.ln_Name)==strlen((char *)opts[OPT_SITE])))
		break;
	    if (!sn1) {
		sn.sn_SiteAddress=(char *)opts[OPT_SITE];
		sn.sn_Node.ln_Name=(char *)opts[OPT_SITE];
		sn.sn_Port=ftp_port;
		ConnectSite(&sn,0);
a61 3
	    else
	      ConnectSite(sn1,0);
	}
a63 1
	
d114 1
a114 1
//    FreeMem(image1.ImageData,imagememsize);
a132 2
/*	    free_dirlist(FileList);
	    free(FileList);*/
a183 2
/*			    free_dirlist(FileList);
			    free(FileList);*/
a214 2
/*			free_dirlist(FileList);
			free(FileList);*/
a230 1
		//		    stackch();
a387 1
//		Printf("wa_Name: '%s'...",FileRequester->fr_ArgList[i].wa_Name);
a394 1
//			Printf("added\n");
a396 1
//			Printf("not added (not enough mem)\n");
a400 1
//		    Printf("not added (not enough memory\n");
a402 1
//	    else Printf("Not added\n");
d633 1
a633 1
//    stackch();
a636 10
/*	if (head=LookupCache(CurrentState.CurrentRemoteDir)) {
	    DetachToolList();
	    RefreshWinGad();
	    FileList=head;
	    AttachToolList();
	    RefreshWinGad();
	    ShowFiles=TRUE;
	    UpdateMainButtons(MB_NONESELECTED);
	    lvord=-1;
	}*/
a639 2
/*	    free_dirlist(FileList);
	    free(FileList);*/
a651 1
//    stackch();
@


0.728
log
@Save settings also saves the window position.
@
text
@d540 1
a540 1
			    t+=sprintf(t,"%s", loc_name);
d543 1
a543 1
			    t+=sprintf(t,"%s", opts[OPT_SCREEN]?opts[OPT_SCREEN]:"Workbench"); /* Fix this */
d593 1
a593 1
			t+=sprintf(t,"%s", loc_name);
d596 1
a596 1
			t+=sprintf(t,"%s", opts[OPT_SCREEN]?(char *)opts[OPT_SCREEN]:"Workbench"); /* Fix this */
d685 2
@


0.723
log
@AmiFTP adds .i if the ARexx-port is present.
@
text
@d31 1
a31 7
/*    dobj->do_Gadget.Width  = image1.Width;
    dobj->do_Gadget.Height = image1.Height;
    dobj->do_Gadget.GadgetRender = &image1;
    imagememsize = (image1.Width * image1.Height * image1.Depth)/8;
    image1.ImageData=(USHORT *)AllocMem(imagememsize,MEMF_CHIP);
    CopyMem(imageData1,image1.ImageData,imagememsize);
*/
d81 1
a81 1
	    if (running==2 && dobj) {
d758 3
d804 3
@


0.685
log
@Links were viewed twice.
Workaround for V39 GTNM_Number/Justification bug.
@
text
@d78 1
a78 1
	    if (running==2 && dobj) {
d749 3
a751 1
    char *trans=GetAmiFTPString(Str_Translator);
@


0.671
log
@"View" on links downloaded it twice.
@
text
@d749 1
d752 1
a752 1
    rtEZRequestA(infotext,GetAmiFTPString(Str_OK),NULL,NULL,(struct TagItem *)tags);
@


0.651
log
@Abort-gadget was ghosted after the first transfer, fixed.
Upload loop would continue even if there was an error.
@
text
@d563 1
a563 2
	/* Check for file or dir */
	if (curr->mode&0x4000) {
d567 19
a585 22
		char loc_name[200];
		char buffer[200];
		char *str=MainPrefs.mp_ViewCommand;
		char *t=&buffer[0];
		struct List tlist;
		struct dirlist tmpentry;
		CopyMem(curr,&tmpentry,sizeof(struct dirlist));
		NewList(&tlist);
		AddTail(&tlist,&tmpentry);
		if (!DownloadFile(&tlist,"T:",TransferMode,0)) {
		    strmfp(loc_name,"T:",curr->name);
		    {
			struct Node *node;
			node=malloc(sizeof(struct Node));
			if (node) {
			    memset(node,0,sizeof(struct Node));
			    node->ln_Name=strdup(loc_name);
			    if (node->ln_Name) {
				AddTail(&TempList,node);
			    }
			    else
			      free(node);
d587 2
d590 18
a607 18
		    while (*str) {
			if (*str!='%') {
			    *t++ = *str++;
			    continue;
			}
			str+=2;
			switch(str[-1]) {
			  case 'F': 
			    t+=sprintf(t,"%s", loc_name);
			    break;
			  case 'P':
			    t+=sprintf(t,"%s", opts[OPT_SCREEN]?(char *)opts[OPT_SCREEN]:"Workbench"); /* Fix this */
			    break;
			  default:
			    *t++=str[-2];
			    *t++=str[-1];
			    break;
			}
d609 2
a610 1
		    *t=0;
d612 2
a613 2
		    SystemTags(buffer,SYS_Input,NULL,SYS_Output,NULL,SYS_Asynch,TRUE,TAG_DONE);
		}
@


0.623
log
@Added menuitem TransferMode->Binary/ASCII
@
text
@d394 1
d399 1
d407 1
d409 7
a415 2
		    else
		      FreeMem(node,sizeof(struct Node));
d418 1
@


0.588
log
@The GUI now handles proportional fonts. Only the main listview is fixed font.
@
text
@d174 1
a174 1
			DownloadFile(&tlist,NULL,1,0);
d243 1
a243 1
		  DownloadFile(FileList,NULL,1,0);
d250 1
a250 1
		    DownloadFile(&tlist,NULL,1,0);
d295 1
a295 1
	DownloadFile(FileList,NULL,1,0);
d306 1
a306 1
		DownloadFile(&tlist,NULL,1,0);
d315 1
a315 1
	    DownloadFile(FileList,NULL,1,0);
d419 1
a419 1
      UploadFile(&UploadList,NULL,1);
d514 1
a514 1
		if (!DownloadFile(&tlist,"T:",1,0)) {
d568 1
a568 1
		if (!DownloadFile(&tlist,"T:",1,0)) {
@


0.567
log
@Fixed busy loop caused by badly timed SetMenuStrip() (In the NextSelect-loop)
@
text
@a74 1
	Printf("Waiting for signals\n");
@


0.563
log
@AmiFTP now works with AS225r2 and hopefully with mlink.
Fixes concerning the locale.
@
text
@d75 1
a830 1
	BuildMenu();
d838 1
a838 1
	BuildMenu();
@


0.541
log
@Forgot to set ConfigChanged=FALSE when saving the config
Added more hotkeys.
@
text
@d741 1
a741 1
    tags[1]=(ULONG)"About AmiFTP";
d743 1
a743 1
    rtEZRequestA(infotext,"OK",NULL,NULL,(struct TagItem *)tags);
d751 2
d754 1
d794 2
d797 2
d802 1
a843 1

@


0.486
log
@Recursive getting of directory trees implemented.
Password/Anonymous-gadget added in SiteConfiguration Window
Layout fixes.
@
text
@d750 4
a753 2
    if (ConfigChanged || CurrentState.LeftEdge!=mainWin->LeftEdge || CurrentState.TopEdge!=mainWin->TopEdge)
      WriteConfigFile(ConfigName);
d792 1
d831 1
@


0.425
log
@Add Settingsmenu with Load/Save settings.
Added Edit hostlist to the settingsmenu.
Changed the search order for the prefs-file.
@
text
@d169 6
a174 1
			DownloadFile(curr,NULL,NULL,1,0);
d243 9
a251 3
		  DownloadFile(curr,NULL,FileList,1,0);
		else
		  DownloadFile(curr,NULL,NULL,1,0);
d295 2
a296 1
	/* Check for link */
d301 6
a306 1
		DownloadFile(curr,NULL,NULL,1,0);
d311 1
a311 1
	if (curr->mode&0x4000) { /* Check for file or dir */
d315 2
a316 2
	    DownloadFile(curr,NULL,FileList,1,0);
	}
d509 6
a514 1
		if (!DownloadFile(curr,"T:",NULL,1,0)) {
d563 6
a568 1
		if (!DownloadFile(curr,"T:",NULL,1,0)) {
d629 1
d784 1
a784 1
	strcpy(FileRequester->fr_Drawer,tmp);
d812 1
a812 1
	strcpy(FileRequester->fr_Drawer,tmp);
@


0.413
log
@Added password-gadget.
@
text
@a409 1
extern struct SiteNode *OpenSiteListWindow(void);
d417 1
a417 1
    if((sn=OpenSiteListWindow())) {
d724 78
@


0.388
log
@send/recv-request re-written
Layoutbug in connect-window fixed
@
text
@d307 18
a324 6
    ULONG tags[]={ASL_Window,NULL,ASLFR_PrivateIDCMP,TRUE,ASLFR_SleepWindow,TRUE,ASLFR_InitialDrawer,NULL,ASLFR_DrawersOnly,TRUE,ASLFR_RejectIcons,TRUE,ASLFR_TitleText,NULL,ASLFR_InitialLeftEdge,NULL,ASLFR_InitialTopEdge,NULL,TAG_END};
    tags[1]=(unsigned long)mainWin;
    tags[7]=(unsigned long)&CurrentState.CurrentDLDir[0];
    tags[13]=(unsigned long)GetAmiFTPString(Str_SelectDLPath);
    tags[15]=mainWin->LeftEdge;
    tags[17]=mainWin->TopEdge;
d329 1
a329 1
    if (AslRequest(DirRequester,(struct TagItem *)tags)) {
d343 1
d350 14
a363 4
    ULONG tags[]={ASL_Window,NULL,ASLFR_PrivateIDCMP,TRUE,ASLFR_SleepWindow,TRUE,ASLFR_InitialDrawer,NULL,ASLFR_RejectIcons,TRUE,ASLFR_TitleText,NULL,ASLFR_DoMultiSelect,TRUE,TAG_END};
    tags[1]=(unsigned long)mainWin;
    tags[7]=(unsigned long)CurrentState.CurrentDLDir;
    tags[11]=(unsigned long)GetAmiFTPString(Str_SelectULFiles);
d370 1
a370 1
    if (i=AslRequest(FileRequester,(struct TagItem *)tags)) {
d661 8
a668 2
    ULONG tags[]={RTEZ_ReqTitle,NULL,RT_Window,NULL,RT_LockWindow,TRUE,RT_ReqPos,REQPOS_CENTERWIN,TAG_END};
    tags[1]=(ULONG)GetAmiFTPString(Str_AmiFTPError);
d672 1
d682 16
a697 9
    if (rtGetString(passbuf,24,GetAmiFTPString(Str_PasswordRequest),NULL,
		    RT_Window,connect_Win,
		    RT_LockWindow,TRUE,
		    RTGS_Invisible,TRUE,
		    RTGS_TextFmt,GetAmiFTPString(Str_PasswordEntry),
		    RTGS_TextFmtArgs,&user,
		    RTGS_Flags,GSREQF_CENTERTEXT,
		    RT_ReqPos,REQPOS_CENTERWIN,
		    TAG_END))
d707 8
a714 5
    ULONG tags[]={RTEZ_ReqTitle,(ULONG)"About AmiFTP",
		    RT_Window,NULL,
		    RT_ReqPos,REQPOS_TOPLEFTWIN,
		    RT_LockWindow,TRUE,
		    TAG_DONE};
@


0.371
log
@Localized source.
@
text
@d380 1
a380 4
    node=GetHead(&UploadList);
    while (node) {
	next=GetSucc(node);
	Remove(node);
a382 1
	node=next;
@


0.350
log
@Fixed "Get"-ing links (forgot an else)
@
text
@d27 3
a29 1
	dobj = GetDefDiskObject(WBTOOL);
d197 1
a197 1
			  ShowErrorReq("Error reading dir\n");
d229 1
a229 1
		      ShowErrorReq("Error reading dir\n");
d295 1
a295 1
	    ShowErrorReq("Cannot download entire directories!\n");
d310 1
a310 1
    tags[13]=(unsigned long)"Select download path";
d340 1
a340 1
    tags[11]=(unsigned long)"Select file(s) to upload";
d516 1
a516 1
	    ShowErrorReq("Cannot download entire directories!\n");
d634 1
a634 1
	ShowErrorReq("Remote CD failed:\nConnection timed out");
d636 1
a636 1
	ShowErrorReq("Remote CD failed.");
d642 2
a643 2
    ULONG tags[]={RTEZ_ReqTitle,(ULONG)"AmiFTP error",RT_Window,NULL,RT_LockWindow,TRUE,RT_ReqPos,REQPOS_CENTERWIN,TAG_END};

d649 1
a649 1
    rtEZRequestA(str,"OK",NULL,ap,(struct TagItem *)tags);
d655 3
a657 2
    if (rtGetString(passbuf,24,"AmiFTP Password request",NULL,
		    RT_Window,mainWin,
d660 1
a660 1
		    RTGS_TextFmt,"Enter password for user:\n%s",
@


0.345
log
@Upload via ARexx now works
Entering a remotedir in stringgadget results in re-reading it
@
text
@d291 2
a292 2
	/* Check for file or dir */
	if (curr->mode&0x4000) {
@


0.326
log
@Links are now parsed to linkname and (link)
Upload via ARexx should be finished now
@
text
@d596 2
a597 1
	if (head=LookupCache(CurrentState.CurrentRemoteDir)) {
d606 2
a607 2
	}
	else if (head=read_remote_dir()) {
@


0.322
log
@Dir-cache added.
Delete added.
@
text
@d377 1
a377 1
      UploadFile(&UploadList);
d521 1
a521 1
		if (!DownloadFile(curr,"T:",NULL,1),0) {
@


0.312
log
@Changed Put() to get a filelist.
@
text
@d131 6
a136 3
	if (head=read_remote_dir()) {
	    free_dirlist(FileList);
	    free(FileList);
d167 1
a167 1
			DownloadFile(curr,NULL,NULL,1);
d170 1
a170 1
			if (head=read_remote_dir()) {
d173 13
a185 2
			    free_dirlist(FileList);
			    free(FileList);
d203 1
a203 1
		    if(head=read_remote_dir()) {
d206 13
a218 2
			free_dirlist(FileList);
			free(FileList);
d236 1
a236 1
		  DownloadFile(curr,NULL,FileList,1);
d238 1
a238 1
		  DownloadFile(curr,NULL,NULL,1);
d287 1
a287 1
		DownloadFile(curr,NULL,NULL,1);
d296 1
a296 1
	    DownloadFile(curr,NULL,FileList,1);
d472 1
a472 1
		if (!DownloadFile(curr,"T:",NULL,1)) {
d521 1
a521 1
		if (!DownloadFile(curr,"T:",NULL,1)) {
d596 11
a606 1
	if (head=read_remote_dir()) {
d609 3
a611 2
	    free_dirlist(FileList);
	    free(FileList);
@


0.305
log
@Added some casts to avoid compiler warnings
@
text
@d306 56
a361 1
    UploadFile();
@


0.303
log
@Added Delete();
Added Tag/Untag all;
@
text
@a23 1
    int imagememsize=0;
d51 2
a52 2
	    for (sn1=GetHead(&SiteList);sn1;sn1=GetSucc(sn1))
	      if ((stricmp(opts[OPT_SITE],sn1->sn_Node.ln_Name)==0)&&(strlen(sn1->sn_Node.ln_Name)==strlen(opts[OPT_SITE])))
d55 2
a56 2
		sn.sn_SiteAddress=opts[OPT_SITE];
		sn.sn_Node.ln_Name=opts[OPT_SITE];
d153 1
a153 1
	for (curr=GetHead(FileList),i=0;curr;curr=GetSucc(curr),i++)
d223 1
a223 1
	    for (curr=GetHead(FileList),i=0;curr;curr=GetSucc(curr),i++)
d230 1
a230 1
		for (curr=GetHead(FileList);curr;curr=GetSucc(curr)) curr->dl_Node.ln_Type=0;
d247 1
a247 1
    struct dirlist *curr,*head;
d253 1
a253 1
    for (curr=GetHead(FileList),i=0;curr;curr=GetSucc(curr),i++)
d281 3
a283 3
    tags[1]=mainWin;
    tags[7]=&CurrentState.CurrentDLDir[0];
    tags[13]="Select download path";
d290 1
a290 1
    if (AslRequest(DirRequester,tags)) {
a312 1
    struct dirlist *head;
d333 1
a333 1
	sn=FindName(&SiteList,CurrentState.LastLVSite);
d372 1
a372 1
    struct dirlist *curr,*head;
d378 1
a378 1
    for (curr=GetHead(FileList),i=0;curr;curr=GetSucc(curr),i++)
d467 1
a467 1
			    t+=sprintf(t,"%s", opts[OPT_SCREEN]?opts[OPT_SCREEN]:"Workbench"); /* Fix this */
a488 2
    struct dirlist *head;

d584 1
a584 1
    tags[3]=mainWin;
d594 1
@


0.284
log
@First RCS version.
@
text
@d596 1
a596 1
    if (ConfigChanged)
@
