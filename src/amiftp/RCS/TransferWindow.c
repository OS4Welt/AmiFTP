head	1.803;
access;
symbols;
locks
	lilja:1.803
	lilja:0.667; strict;
comment	@ * @;


1.803
date	96.11.30.21.14.49;	author lilja;	state Exp;
branches;
next	1.795;

1.795
date	96.09.28.13.32.58;	author lilja;	state Exp;
branches;
next	1.736;

1.736
date	96.08.17.18.17.57;	author lilja;	state Exp;
branches;
next	1.625;

1.625
date	96.07.04.17.50.58;	author lilja;	state Exp;
branches;
next	1.595;

1.595
date	96.06.18.23.19.14;	author lilja;	state Exp;
branches;
next	1.587;

1.587
date	96.06.14.13.23.25;	author lilja;	state Exp;
branches;
next	1.585;

1.585
date	96.06.13.00.03.21;	author lilja;	state Exp;
branches;
next	1.539;

1.539
date	96.06.01.14.40.45;	author lilja;	state Exp;
branches;
next	1.531;

1.531
date	96.05.28.00.17.52;	author lilja;	state Exp;
branches;
next	1.430;

1.430
date	96.04.14.13.21.26;	author lilja;	state Exp;
branches;
next	1.401;

1.401
date	96.03.28.13.52.44;	author lilja;	state Exp;
branches;
next	1.265;

1.265
date	96.03.08.18.01.38;	author lilja;	state Exp;
branches;
next	1.200;

1.200
date	96.02.20.00.19.28;	author lilja;	state Exp;
branches;
next	1.184;

1.184
date	96.02.14.23.27.00;	author lilja;	state Exp;
branches;
next	1.173;

1.173
date	96.02.14.19.06.27;	author lilja;	state Exp;
branches;
next	1.150;

1.150
date	96.02.11.16.38.55;	author lilja;	state Exp;
branches;
next	1.124;

1.124
date	96.02.10.15.46.32;	author lilja;	state Exp;
branches;
next	0.1343;

0.1343
date	96.01.20.17.34.39;	author lilja;	state Exp;
branches;
next	0.1332;

0.1332
date	95.12.17.13.21.38;	author lilja;	state Exp;
branches;
next	0.1300;

0.1300
date	95.12.08.20.24.52;	author lilja;	state Exp;
branches;
next	0.863;

0.863
date	95.10.28.17.17.56;	author lilja;	state Exp;
branches;
next	0.859;

0.859
date	95.10.24.20.36.39;	author lilja;	state Exp;
branches;
next	0.827;

0.827
date	95.10.23.21.01.35;	author lilja;	state Exp;
branches;
next	0.814;

0.814
date	95.10.15.15.22.12;	author lilja;	state Exp;
branches;
next	0.807;

0.807
date	95.10.13.12.51.19;	author lilja;	state Exp;
branches;
next	0.774;

0.774
date	95.10.07.00.18.25;	author lilja;	state Exp;
branches;
next	0.710;

0.710
date	95.09.24.18.20.34;	author lilja;	state Exp;
branches;
next	0.700;

0.700
date	95.09.24.00.57.34;	author lilja;	state Exp;
branches;
next	0.692;

0.692
date	95.09.23.15.20.29;	author lilja;	state Exp;
branches;
next	0.685;

0.685
date	95.09.22.20.13.06;	author lilja;	state Exp;
branches;
next	0.671;

0.671
date	95.09.20.10.15.33;	author lilja;	state Exp;
branches;
next	0.667;

0.667
date	95.09.18.10.34.24;	author lilja;	state Exp;
branches;
next	0.656;

0.656
date	95.09.17.11.32.29;	author lilja;	state Exp;
branches;
next	0.651;

0.651
date	95.09.17.11.06.43;	author lilja;	state Exp;
branches;
next	0.623;

0.623
date	95.09.16.10.54.30;	author lilja;	state Exp;
branches;
next	0.588;

0.588
date	95.09.12.16.24.08;	author lilja;	state Exp;
branches;
next	0.563;

0.563
date	95.09.10.20.59.20;	author lilja;	state Exp;
branches;
next	0.544;

0.544
date	95.09.08.14.11.28;	author lilja;	state Exp;
branches;
next	0.534;

0.534
date	95.09.03.18.34.27;	author lilja;	state Exp;
branches;
next	0.531;

0.531
date	95.09.01.17.25.42;	author lilja;	state Exp;
branches;
next	0.486;

0.486
date	95.08.26.11.48.42;	author lilja;	state Exp;
branches;
next	0.388;

0.388
date	95.07.16.13.14.48;	author lilja;	state Exp;
branches;
next	0.371;

0.371
date	95.06.30.19.18.41;	author lilja;	state Exp;
branches;
next	0.345;

0.345
date	95.06.15.23.29.18;	author lilja;	state Exp;
branches;
next	0.336;

0.336
date	95.06.15.11.53.20;	author lilja;	state Exp;
branches;
next	0.326;

0.326
date	95.06.13.12.52.15;	author lilja;	state Exp;
branches;
next	0.322;

0.322
date	95.06.12.23.14.26;	author lilja;	state Exp;
branches;
next	0.312;

0.312
date	95.06.09.18.13.36;	author lilja;	state Exp;
branches;
next	0.305;

0.305
date	95.06.08.16.45.30;	author lilja;	state Exp;
branches;
next	0.284;

0.284
date	95.06.06.21.42.35;	author lilja;	state Exp;
branches;
next	;


desc
@Code for up/downloading gui
@


1.803
log
@Added 'Overwrite all'-option.
@
text
@/* RCS Id: $Id: TransferWindow.c 1.795 1996/09/28 13:32:58 lilja Exp $
   Locked version: $Revision: 1.795 $
*/

#include "AmiFTP.h"
#include "gui.h"

BOOL AskGetDir(void);
int GetDir(char *remote_parent, char *local_parent, char *name, char *localname);
void UpdateTransTitle(struct Node *node);

struct Window *TransferWindow;
Object *TransferLayout;
Object *TransferWin_Object;

struct Window *OpenTransferWindow(void);
void CloseTransferWindow(void);

enum {
    TG_RemoteFile=0, TG_LocalFile, TG_CPS, TG_ETA,
    TG_Gauge, TG_Abort,
    NumGadgets_TG};

struct Gadget *TG_List[NumGadgets_TG];
ULONG fuelargs[]={0,0};
static int OverwriteAll=0;

int DownloadFile(struct List *flist, const char *localname, const int binary,
		 const int move)
{
    ULONG wait,signal,mainsignal,done=FALSE;
    int result=1;
    struct dirlist *curr;
    struct Node *node;
    char localfile[MAXPATHLEN+1];
    BOOL aborted=FALSE;

    settype(binary);
    fuelargs[0]=fuelargs[1]=0;
    OverwriteAll=0;

    if (MainWindow)
      if (!OpenTransferWindow())
	return TRANS_GUI;

    for (node=ListHead(flist);ListEnd(node);node=ListNext(node)) {
	ULONG sel=0;
	GetListBrowserNodeAttrs(node, LBNA_Selected, &sel, TAG_DONE);
	if (sel) {
	    static char tmp[1024];
	    curr=(void *)node->ln_Name;
	    aborted=0;
	    UpdateTransTitle(node);
	    switch(curr->mode & S_IFMT) {
	      case S_IFDIR:
		if (AskGetDir()) {
		    if (result=GetDir(CurrentState.CurrentRemoteDir,
					  CurrentState.CurrentDLDir,curr->name,
					  curr->name)) {
			goto out;
		    }
		    if (result==TRSF_OK) {
			if (flist==FileList)
			  LBEditNode(MG_List[MG_ListView],MainWindow,NULL,
				     node,LBNA_Selected,FALSE,TAG_DONE);
			else
			  SetListBrowserNodeAttrs(node, LBNA_Selected, FALSE,
						  TAG_DONE);
		    }

		}
		break;
	      case S_IFREG:
		memset(localfile,0,sizeof(localfile));
		if (!localname) {
		    stcgfn(tmp,curr->name);
		    strmfp(localfile,CurrentState.CurrentDLDir,tmp);
		}
		else {
		    if (localname[strlen(localname)-1]=='/'||localname[strlen(localname)-1]==':') {
			strcpy(localfile,localname);
			stcgfn(localfile+strlen(localfile),curr->name);
		    }
		    else {
			if (getfa(localname)==1) {
			    strcpy(localfile,localname);
			    strcat(localfile,"/");
			    stcgfn(localfile+strlen(localfile),curr->name);
			}
			else {
			    if (index(localname,'/')||index(localname,':'))
			      strcpy(localfile,localname);
			    else
			      strmfp(localfile,CurrentState.CurrentDLDir,localname);
			}
		    }
		}
		if (curr->adt) {
		    char aname[35];
		    sprintf(aname,"%s/%s",curr->owner,curr->name);
		    result=get_file(aname, localfile, curr->size);
		    if (result==TRSF_OK && MainPrefs.mp_GetReadme) {
			char *readme=NameToReadme(curr->name, curr->readmelength);
			char lname[64];
			sprintf(aname, "%s/%s", curr->owner, readme);
			strmfp(lname, CurrentState.CurrentDLDir, readme);
			result=get_file(aname, lname, curr->readmelen);
		    }
		}
		else {
		    result=get_file(curr->name, localfile, curr->size);
		}
		if (result==TRSF_OK) {
		    if (flist==FileList)
		      LBEditNode(MG_List[MG_ListView], MainWindow, NULL,
				 node, LBNA_Selected, FALSE, TAG_DONE);
		    else
		      SetListBrowserNodeAttrs(node, LBNA_Selected, FALSE, TAG_DONE);
		 }
		else if (result==TRSF_ABORTED)
		  goto out;
		break;
	      case S_IFLNK:
		{
		    char *name;
		    name=linkname(curr->name);
		    if (name) {
			memset(localfile,0,sizeof(localfile));
			if (!localname) {
			    stcgfn(tmp,name);
			    strmfp(localfile, CurrentState.CurrentDLDir, tmp);
			}
			else {
			    if (localname[strlen(localname)-1]=='/'||
				localname[strlen(localname)-1]==':') {
				strcpy(localfile, localname);
				stcgfn(localfile+strlen(localfile), name);
			    }
			    else {
				if (getfa(localname)==1) {
				    strcpy(localfile, localname);
				    strcat(localfile,"/");
				    stcgfn(localfile+strlen(localfile), name);
				}
				else {
				    if (index(localname, '/') ||
					index(localname, ':'))
				      strcpy(localfile, localname);
				    else
				      strmfp(localfile, CurrentState.CurrentDLDir,
					     localname);
				}
			    }
			}
			result=get_file(name, localfile, curr->size);
			if (result==TRSF_BADFILE) {
			    if (AskGetDir()) {
				if (result==GetDir(CurrentState.CurrentRemoteDir,CurrentState.CurrentDLDir,name,name)!=TRSF_OK) {
				    free(name);
				    goto out;
				}
			    }
			    if (flist==FileList)
			      LBEditNode(MG_List[MG_ListView], MainWindow, NULL,
					 node, LBNA_Selected, FALSE, TAG_DONE);
			    else
			      SetListBrowserNodeAttrs(node, LBNA_Selected, FALSE,
						      TAG_DONE);
			}
			else if (result==TRSF_OK) {
			    if (flist==FileList)
			      LBEditNode(MG_List[MG_ListView], MainWindow, NULL,
					 node, LBNA_Selected, FALSE, TAG_DONE);
			    else
			      SetListBrowserNodeAttrs(node, LBNA_Selected, FALSE,
						      TAG_DONE);
			}
			else if (result==TRSF_ABORTED)
			  goto out;
			free(name);
		    }
		}
		break;
	    }
	}
    }
    UpdateTransTitle(0);
    for (node=ListHead(flist);ListEnd(node);node=ListNext(node)) {
	ULONG t=0;
	GetListBrowserNodeAttrs(node, LBNA_Selected, &t, TAG_DONE);
	if (t) {
	    break;
	}
    }
    if (node==0 && flist==FileList) {
	UpdateMainButtons(MB_NONESELECTED);
    }
    UpdateWindowTitle();
  out:
    if (result==TRSF_OK || result==TRSF_ABORTED) {
	if (result==TRSF_OK && MainPrefs.mp_DisplayBeep && TransferWindow) {
	    DisplayBeep(Screen);
	}
	if (TransferWindow)
	  CloseTransferWindow();
	return result==TRSF_OK?TRANS_OK:TRANS_ABORTED;
    }

    if (TransferWin_Object) {
	GetAttr(WINDOW_SigMask, TransferWin_Object, &signal);

	SetGadgetAttrs(TG_List[TG_Abort], TransferWindow,NULL,
		       GA_Disabled, TRUE,
		       TAG_DONE);
	RefreshGList(TG_List[TG_Abort], TransferWindow, NULL,1);

	if (!SilentMode) {
	    while (!done) {
		GetAttr(WINDOW_SigMask, MainWin_Object, &mainsignal);
		wait=Wait(signal|AG_Signal|mainsignal);
		if (wait & AG_Signal)
		  HandleAmigaGuide();
		if (wait & signal)
		  done=HandleTransferIDCMP();
		if (wait & mainsignal)
		  HandleMainWindowIDCMP(FALSE);
	    }
	}
	
	CloseTransferWindow();
    }
    return TRANS_ERROR;
}

ULONG HandleTransferIDCMP(void)
{
    ULONG done=FALSE;
    ULONG result;
    UWORD code=NULL;

    while((result=CA_HandleInput(TransferWin_Object,&code))!=WMHI_LASTMSG) {
	switch (result & WMHI_CLASSMASK) {
	  case WMHI_CLOSEWINDOW:
	    done=TRUE;
	    break;
	  case WMHI_GADGETUP:
	    done=TRUE;
	    break;
	  case WMHI_ICONIFY:
	    if (MainWindow) {
		if (CA_Iconify(MainWin_Object))
		  MainWindow=NULL;
	    }
	    else {
		MainWindow=CA_OpenWindow(MainWin_Object);
		MoveWindowInFrontOf(TransferWindow, MainWindow);
	    }
	    break;
	  case WMHI_RAWKEY:
	    if (code==95)
	      SendAGMessage(AG_TRANSWIN);
	    break;
	}
    }
    return done;
}

#include "trans.gui"
struct Window *OpenTransferWindow(void)
{
    struct Gadget *g1, *g2;
    struct LayoutLimits limits;
    extern struct RastPort *ARPort;
    LONG len=TextLength(ARPort,"0",1);
    fuelargs[0]=fuelargs[1]=0;//&fargs;

    if (TransferWindow)
      return TransferWindow;

    TransferLayout=TRANSFERGUI; // Line 256

    if (!TransferLayout)
      return NULL;

    SetAttrs(g1, LAYOUT_AlignLabels, g2, TAG_DONE);
    SetAttrs(g2, LAYOUT_AlignLabels, g1, TAG_DONE);

    LayoutLimits((struct Gadget *)TransferLayout,&limits,PropFont,Screen);
    limits.MinHeight+=Screen->WBorTop+Screen->WBorBottom;
    limits.MinWidth+=Screen->WBorLeft+Screen->WBorRight;

    TransferWin_Object = WindowObject,
                          WA_Title, GetAmiFTPString(TW_WinTitle),
                          WA_PubScreen,Screen,
                          WA_DepthGadget, TRUE,
                          WA_DragBar, TRUE,
                          WA_CloseGadget, TRUE,
                          WA_Activate, TRUE,
                          WA_SmartRefresh, TRUE,
                          WA_Top, MainWindow->TopEdge+(MainWindow->Height-limits.MinHeight)/2,
                          WA_Left, MainWindow->LeftEdge+(MainWindow->Width-limits.MinWidth)/2,
                          WINDOW_IconifyGadget,TRUE,
                          WINDOW_ParentGroup, TransferLayout,
                          WA_IDCMP, IDCMP_RAWKEY,
                        EndWindow;

    if (!TransferWin_Object)
      return NULL;

    if (TransferWindow=CA_OpenWindow(TransferWin_Object)) {
	return TransferWindow;
    }
    DisposeObject(TransferLayout);
    TransferLayout=NULL;

    return NULL;
}

void CloseTransferWindow(void)
{
    if (TransferWin_Object) {
	DisposeObject(TransferWin_Object);
	TransferWindow=NULL;
	TransferWin_Object=NULL;
	TransferLayout=NULL;
    }
}

static long FileSize=NULL,last=0;

int UploadFile(struct List *transferlist, const char *remote, const int binary)
{
    ULONG wait,signal,mainsignal,done=FALSE;
    char buf[20];
    int res;
    struct Node *node;

    settype(binary);

    if (MainWindow)
      if (!OpenTransferWindow())
	return TRANS_GUI;

    for (node=ListHead(transferlist);ListEnd(node);node=ListNext(node)) {
	int size=0;
	char *rem=0;
	BPTR lock;
	struct FileInfoBlock __aligned fib;
	struct dirlist *entry=(void *)node->ln_Name;
	
	UpdateTransTitle(node);
	if (CurrentState.ADTMode) {
	    rem=malloc(256);
	    strcpy(rem, "new/");
	    strcat(rem, FilePart(entry->name));
	    remote=rem;
	}

	if (entry->size)
	  size=entry->size;
	else {
	    lock=Lock(entry->name,SHARED_LOCK);

	    if (lock) {
		Examine(lock,&fib);
		size=fib.fib_Size;
		UnLock(lock);
	    }
	}

	if (TransferWindow) {
	    sprintf(buf,"%ld",size);
	    SetGadgetAttrs(TG_List[TG_LocalFile], TransferWindow, NULL,
			   GA_Text, entry->name,
			   TAG_DONE);
	    RefreshGList(TG_List[TG_LocalFile],TransferWindow,NULL,1);
	    SetGadgetAttrs(TG_List[TG_RemoteFile], TransferWindow, NULL,
			   GA_Text,remote?(char *)remote:(char *)FilePart(entry->name),
			   TAG_DONE);
	    RefreshGList(TG_List[TG_RemoteFile],TransferWindow,NULL,1);
	    SetGadgetAttrs(TG_List[TG_CPS], TransferWindow, NULL,
			   GA_Text,"0",
			   TAG_DONE);
	    RefreshGList(TG_List[TG_CPS],TransferWindow,NULL,1);
	    RefreshGList(TG_List[TG_CPS],TransferWindow,NULL,1);
	    fuelargs[0]=fuelargs[1]=0;
	    SetGadgetAttrs(TG_List[TG_Gauge],TransferWindow,NULL,
			       FUELGAUGE_Level,0,
			       FUELGAUGE_VarArgs,&fuelargs,
			       TAG_DONE);

	    FileSize=size;
	    last=0;
	}
	res=sendrequest("STOR",entry->name,remote?(char *)remote:(char *)FilePart(entry->name));
	if (rem) {
	    free(rem);
	    rem=NULL;
	}
	if (res!=TRSF_OK)
	  break;
    }

    if (!TransferWin_Object)
      return res;
    UpdateTransTitle(0);

    if (res==TRSF_ABORTED||res==TRSF_OK) {
	if (res==TRSF_OK && MainPrefs.mp_DisplayBeep && TransferWindow) {
	    DisplayBeep(Screen);
	}
	CloseTransferWindow();
	return res;
    }

    GetAttr(WINDOW_SigMask, TransferWin_Object, &signal);
    GetAttr(WINDOW_SigMask, MainWin_Object, &mainsignal);

    SetGadgetAttrs(TG_List[TG_Abort], TransferWindow,NULL,
		   GA_Disabled,TRUE,
		   TAG_DONE);
    RefreshGList(TG_List[TG_Abort],TransferWindow,NULL,1);

    if (!SilentMode) {
	while (!done) {
	    wait=Wait(signal|AG_Signal);
	    
	    if (wait&signal)
	      done=HandleTransferIDCMP();
	    if (wait & AG_Signal)
	      HandleAmigaGuide();
	    if (wait & mainsignal)
	      HandleMainWindowIDCMP(FALSE);
	}
    }

    CloseTransferWindow();
    return TRANS_ERROR;
}


void UpdateDLGads(const long bytes, const long restart_point, const time_t timee)
{

    if (TransferWin_Object) {
	static char buf1[20],buf2[20],buf3[20];
	int hours=0,mins=0,secs=0, cps=0;
	if (timee) {
	    cps=(bytes-restart_point)/timee;
	    if (FileSize && cps) {
		secs=(FileSize-bytes)/cps;
		hours=secs / 3600;
		mins = (secs-hours*3600)/60;
		secs=secs%60;
	    }
	}

	sprintf(buf1, "%ld", bytes);
	sprintf(buf2, "%ld", cps);
	sprintf(buf3, "%0.2d:%0.2d:%0.2d", hours, mins, secs);
	if (SetGadgetAttrs(TG_List[TG_CPS], TransferWindow, NULL,
			   GA_Text, buf2, TAG_DONE)){ 
	    RefreshGList(TG_List[TG_CPS], TransferWindow, NULL, 1);
	}
	if (SetGadgetAttrs(TG_List[TG_ETA], TransferWindow, NULL,
			   GA_Text, buf3, TAG_DONE)) {
	    RefreshGList(TG_List[TG_ETA], TransferWindow, NULL, 1);
	}
	fuelargs[0]=bytes;//FileSize?(bytes*100)/FileSize:0;
	fuelargs[1]=FileSize;
	SetGadgetAttrs(TG_List[TG_Gauge], TransferWindow, NULL,
		       FUELGAUGE_Level, FileSize?(FileSize>10240?bytes/(FileSize/100):(bytes*100)/FileSize):0,
		       FUELGAUGE_VarArgs, &fuelargs[0],
		       TAG_DONE);
    }
}


BOOL CheckExists(char *lfile,int size, ULONG *restartpoint)
{
    static ULONG tags[]={
	RTEZ_ReqTitle, NULL,
	RT_Window, NULL,
	RT_LockWindow, TRUE,
	RT_ReqPos, REQPOS_CENTERWIN,
	TAG_END
      };
    BPTR lock;
    struct FileInfoBlock fib;
    BOOL ret;
    char *Gadgetstring;

    lock=Lock(lfile,ACCESS_READ);
    if (!lock)
      return FALSE;
    Examine(lock,&fib);
    UnLock(lock);

    if (SilentMode || OverwriteAll) {
	*restartpoint=0;
	return FALSE;
    }

    tags[1]=(ULONG)GetAmiFTPString(Str_AmiFTPRequest);
    tags[3]=(ULONG)MainWindow;

    Gadgetstring=malloc(strlen(GetAmiFTPString(TW_OverwriteAll))+
			strlen(GetAmiFTPString(TW_Overwrite))+
			strlen(GetAmiFTPString(TW_Resume))+
			strlen(GetAmiFTPString(TW_CancelTransfer))+6);
    if (!Gadgetstring)
      return FALSE;
    if (fib.fib_Size>=size) {
	sprintf(Gadgetstring,"%s|%s|%s", 
		GetAmiFTPString(TW_Overwrite),
		GetAmiFTPString(TW_OverwriteAll),
		GetAmiFTPString(TW_CancelTransfer));
	ret=(BOOL)rtEZRequest(GetAmiFTPString(TW_FileExists), Gadgetstring, NULL,
			      (struct TagItem *)tags, lfile, fib.fib_Size, size);
	free(Gadgetstring);
	*restartpoint=0;
	if (ret==1)
	  return FALSE;
	if (ret==2) {
	    OverwriteAll = 1;
	    return FALSE;
	}
    }
    else {    
	sprintf(Gadgetstring,"%s|%s|%s|%s",
		GetAmiFTPString(TW_Overwrite),
		GetAmiFTPString(TW_OverwriteAll),
		GetAmiFTPString(TW_Resume),
		GetAmiFTPString(TW_CancelTransfer));
	ret=(BOOL)rtEZRequest(GetAmiFTPString(TW_FileExists), Gadgetstring, NULL,
			      (struct TagItem *)tags, lfile, fib.fib_Size, size);
	free(Gadgetstring);
	if (ret==1)
	  return FALSE;
	if (ret==2) {
	    OverwriteAll = 1;
	    return FALSE;
	}
	if (ret==3) {
	    *restartpoint=fib.fib_Size;
	    return FALSE;
	}
    }
    return TRUE;
}
static char tbufs[50];

void SetTransferSize(const long size)
{
    sprintf(tbufs, "%ld", size);
    FileSize=size;
    fuelargs[0]=0;
    fuelargs[1]=FileSize;
    
    if (TransferWindow) {
	SetGadgetAttrs(TG_List[TG_Gauge], TransferWindow, NULL,
		       FUELGAUGE_VarArgs, &fuelargs,
		       TAG_DONE);
	RefreshGList(TG_List[TG_Gauge], TransferWindow, NULL, 1);
    }
}

int get_file(char *name, char *localname, int size)
{
    int		rval;
    ULONG restartpoint=0;
    static char buf[50];

    if (TransferWindow) {
	sprintf(buf,"%ld",size);
	FileSize=size;
	last=0;
	if (SetGadgetAttrs(TG_List[TG_LocalFile], TransferWindow, NULL,
			   CLASSACT_Underscore, '\n',
			   GA_Text, localname,
			   TAG_DONE))
	  RefreshGList(TG_List[TG_LocalFile], TransferWindow, NULL, 1);
	if (SetGadgetAttrs(TG_List[TG_RemoteFile], TransferWindow, NULL,
			   GA_Text, name,
			   TAG_DONE))
	  RefreshGList(TG_List[TG_RemoteFile], TransferWindow, NULL, 1);
	if (SetGadgetAttrs(TG_List[TG_CPS], TransferWindow, NULL,
			   GA_Text,"0",
			   TAG_DONE))
	  RefreshGList(TG_List[TG_CPS], TransferWindow, NULL, 1);
	fuelargs[0]=0;
	fuelargs[1]=size;
	SetGadgetAttrs(TG_List[TG_Gauge], TransferWindow, NULL,
		       FUELGAUGE_Level, 0,
		       FUELGAUGE_VarArgs, &fuelargs,
		       TAG_DONE);
    }
    if (CheckExists(localname, size, &restartpoint))
      return TRSF_OK;
    rval = recvrequest("RETR", localname, name, "w", restartpoint);
    return rval;
}

char *make_path(char *parent, char *curdir)
{
    char	*tmp;

    if (*curdir == '/') {
	tmp = (char *)strdup(curdir);
    } else {
	tmp = (char *)calloc((unsigned int)(strlen(parent) + 1 +
					    strlen(curdir) + 1),1);
	if (tmp == NULL)
	  return NULL;
	strcpy(tmp, parent);
	if (strcmp(parent, "/") && parent[strlen(parent)-1]!=':')
	  strcat(tmp, "/");
	strcat(tmp, curdir);
    }
    return tmp;
}

BOOL AskGetDir(void)
{
    static ULONG tags[]={
	RTEZ_ReqTitle, NULL,
	RT_Window, NULL,
	RT_LockWindow, TRUE,
	RT_ReqPos, REQPOS_CENTERWIN,
	TAG_END
      };
    BOOL ret;

    if (!MainWindow)
      return FALSE;

    tags[1]=(ULONG)GetAmiFTPString(Str_AmiFTPRequest);
    tags[3]=(ULONG)MainWindow;
    ret=(BOOL)rtEZRequest(GetAmiFTPString(TW_DownloadDir),
			  GetAmiFTPString(TW_GetDir), NULL, (struct TagItem *)tags);
    if (ret)
      return TRUE;
    return FALSE;
}

void PrintQueue(struct List *queue)
{
    struct QueueEntry {
	struct Node qe_Node;
	struct List *filelist;
	char *dirname;
	char *localname;
	char *remote_parent;
	char *local_parent;
    };
    struct QueueEntry *qe;
    for (qe=(struct QueueEntry *)ListHead(queue);
	 ListEnd((struct Node *)qe);
	 qe=(struct QueueEntry *)ListNext((struct Node *)qe)) {
	Printf("remote_parent '%s' dirname '%s'\nlocal_parent '%s' localname '%s'\n",
	       qe->remote_parent,qe->dirname,qe->local_parent,qe->localname);
	Printf("----------------------------------------------------\n");
    }
}

int GetDir(char *remote_parent, char *local_parent, char *name, char *localname)
{
    struct QueueEntry {
	struct Node qe_Node;
	struct List *filelist;
	char *dirname;
	char *localname;
	char *remote_parent;
	char *local_parent;
    };
    struct List Queue;
    struct QueueEntry *first,*entry;
    struct Node *node;
    BPTR newdir;
    int len,rval;

    NewList(&Queue);

    first=calloc(sizeof(struct QueueEntry),1);
    if (!first)
      return TRSF_FAILED;
    first->localname=strdup(localname);
    if (!first->localname) {
	free(first);
	return TRSF_FAILED;
    }
    first->local_parent=strdup(local_parent);
    if (!first->local_parent) {
	free(first->localname);
	free(first);
	return TRSF_FAILED;
    }
    first->remote_parent=strdup(remote_parent);
    if (!first->remote_parent) {
	free(first->localname);
	free(first->local_parent);
	free(first);
	return TRSF_FAILED;
    }
    first->dirname=strdup(name);
    if (!first->dirname) {
	free(first->localname);
	free(first->local_parent);
	free(first->remote_parent);
	free(first);
	return TRSF_FAILED;
    }

    AddHead(&Queue,first);
    while (entry=(struct QueueEntry *)RemTail(&Queue)) {
	char *ldir,*rdir;
	struct dirlist *tmp;

	len=strlen(entry->local_parent)+strlen(entry->localname)+2;
	ldir=calloc(len,1);
	if (ldir==NULL) {
	    rval=TRSF_FAILED;
	    goto out;
	}
	strcpy(ldir,entry->local_parent);
	AddPart(ldir,entry->localname,len);

	rdir=make_path(entry->remote_parent,entry->dirname);
	if (rdir==NULL) {
	    rval=TRSF_FAILED;
	    free(ldir);
	    goto out;
	}
	newdir=CreateDir(ldir);
	if (!newdir && IoErr()!=ERROR_OBJECT_EXISTS) {
	    rval=TRSF_FAILED;
	    goto out;
	}
	UnLock(newdir);
	command("CWD %s",rdir);
	if (code!=250) {
	    free(rdir);
	    free(ldir);
	    rval=TRSF_FAILED;
	    ShowErrorReq(GetAmiFTPString(Str_CDFailed));
	    goto out;
	}
	entry->filelist=read_remote_dir();
	if (!entry->filelist) {
	    free(rdir);
	    free(ldir);
	    rval=TRSF_FAILED;
	    goto out;
	}

	for (node=ListHead(entry->filelist);ListEnd(node);node=ListNext(node)) {
	    tmp=(void *)node->ln_Name;
	    if (S_ISREG(tmp->mode)) {
		char *tmpname=malloc(strlen(ldir)+strlen(tmp->name)+4);
		if (!tmpname) {
		    rval=TRSF_FAILED;
		    goto out;
		}
		strmfp(tmpname,ldir,tmp->name);

		if (get_file(tmp->name,tmpname,tmp->size)!=TRSF_OK) {
		    free(tmpname);
		    free(ldir);
		    free(rdir);
		    rval=TRSF_FAILED;
		    goto out;
		}
	    }
	}
	for (node=ListHead(entry->filelist);ListEnd(node);node=ListNext(node)) {
	    tmp=(void *)node->ln_Name;
	    if (S_ISDIR(tmp->mode)) {
		struct QueueEntry *qentry;
		qentry=calloc(sizeof(struct QueueEntry),1);
		if (qentry) {
		    if (!(qentry->remote_parent=strdup(rdir))) {
			rval=TRSF_FAILED;
			free(qentry);
			goto out;
		    }
		    if (!(qentry->local_parent=strdup(ldir))) {
			rval=TRSF_FAILED;
			free(qentry->remote_parent);
			free(qentry);
			goto out;
		    }
		    if (!(qentry->dirname=strdup(tmp->name))) {
			rval=TRSF_FAILED;
			free(qentry->dirname);
			free(qentry->remote_parent);
			free(qentry);
			goto out;
		    }
		    if (!(qentry->localname=strdup(tmp->name))) {
			rval=TRSF_FAILED;
			free(qentry->localname);
			free(qentry->dirname);
			free(qentry->remote_parent);
			free(qentry);
			goto out;
		    }
		    AddHead(&Queue,qentry);
		}
	    }
	}
	for (node=ListHead(entry->filelist);ListEnd(node);node=ListNext(node)) {
	    tmp=(void *)node->ln_Name;
	    if (S_ISLNK(tmp->mode)) {
		char *lname;
		int rval;
		lname=linkname(tmp->name);
		if (!lname) {
		    rval=TRSF_FAILED;
		    goto out;
		}
		rval=get_file(tmp->name,lname,-1);
		if (rval==TRSF_FAILED) {
		    struct QueueEntry *qentry;
		    if (!(qentry=calloc(sizeof(struct QueueEntry),1))) {
			free(ldir);
			free(rdir);
			goto out;
		    }
		    if (!(qentry->remote_parent=strdup(rdir))) {
			free(qentry);
			free(ldir);
			free(rdir);
			goto out;
		    }
		    if (!(qentry->local_parent=strdup(ldir))) {
			free(qentry->remote_parent);
			free(qentry);
			free(ldir);
			free(rdir);
			goto out;
		    }
		    if (!(qentry->dirname=strdup(lname))) {
			free(qentry->local_parent);
			free(qentry->remote_parent);
			free(ldir);
			free(rdir);
			free(qentry);
			goto out;
		    }
		    if (!(qentry->localname=strdup(lname))) {
			free(qentry->dirname);
			free(qentry->local_parent);
			free(qentry->remote_parent);
			free(qentry);
			free(ldir);
			free(rdir);
			goto out;
		    }
		    AddHead(&Queue,qentry);
		}
		if (lname)
		  free(lname);
	    }
	}
	if (ldir)
	  free(ldir);
	if (rdir)
	  free(rdir);
	free_dirlist(entry->filelist);
	if (entry->remote_parent)
	  free(entry->remote_parent);
	if (entry->local_parent)
	  free(entry->local_parent);
	if (entry->dirname)
	  free(entry->dirname);
	if (entry->localname)
	  free(entry->localname);
	free(entry);
    }
    command("CWD %s",remote_parent);
    return TRSF_OK;
  out:
    while(entry=(struct QueueEntry *)RemHead(&Queue)) {
	if (entry->filelist)
	  free_dirlist(entry->filelist);
	if (entry->remote_parent)
	  free(entry->local_parent);
	if (entry->dirname)
	  free(entry->dirname);
	if (entry->localname)
	  free(entry->localname);
	free(entry);
    }
    command("CWD %s",remote_parent);
    return rval;
}

void UpdateTransTitle(struct Node *node)
{
    ULONG bytes=0;
    int numfiles=0;
    struct dirlist *entry;
    static char title[100];
    char *sbytes;

    if (!TransferWin_Object)
      return;

    for (;node; node=GetSucc(node)) {
	ULONG sel=0;
	GetListBrowserNodeAttrs(node, LBNA_Selected, &sel, TAG_DONE);
	if (sel) {
	    entry=(void *)node->ln_Name;
	    if (entry->size>0)
	      bytes+=entry->size;
	    numfiles++;
	}
    }

    if (bytes<1000000) {
	bytes/=1024;
	sbytes="kB";
    }
    else {
	bytes/=(1024*1024);
	sbytes="MB";
    }
     
    sprintf(title, GetAmiFTPString(TW_WinTitle),
	    numfiles, bytes, sbytes);
    SetAttrs(TransferWin_Object, WA_Title, title, TAG_DONE);
}
@


1.795
log
@Stuff.
@
text
@d1 2
a2 2
/* RCS Id: $Id: TransferWindow.c 1.736 1996/08/17 18:17:57 lilja Exp lilja $
   Locked version: $Revision: 1.736 $
d26 1
d40 1
d499 1
a499 1
    if (SilentMode) {
d507 2
a508 1
    Gadgetstring=malloc(strlen(GetAmiFTPString(TW_Overwrite))+
d510 1
a510 1
			strlen(GetAmiFTPString(TW_CancelTransfer))+3);
d514 3
a516 1
	sprintf(Gadgetstring,"%s|%s", GetAmiFTPString(TW_Overwrite),
d524 4
d530 5
a534 2
	sprintf(Gadgetstring,"%s|%s|%s", GetAmiFTPString(TW_Overwrite),
		GetAmiFTPString(TW_Resume), GetAmiFTPString(TW_CancelTransfer));
d541 4
@


1.736
log
@Transferwindow progressbar freaked out if the file was too big. now fixed.
Other stuff fixed.
@
text
@d1 2
a2 2
/* RCS Id: $Id: TransferWindow.c 1.625 1996/07/04 17:50:58 lilja Exp lilja $
   Locked version: $Revision: 1.625 $
d10 2
d51 1
d185 1
d347 3
a349 1

d353 1
a353 1
	    strcat(rem, FilePart(node->ln_Name));
a355 1
	lock=Lock(node->ln_Name,SHARED_LOCK);
d357 10
a366 4
	if (lock) {
	    Examine(lock,&fib);
	    size=fib.fib_Size;
	    UnLock(lock);
d368 1
d372 1
a372 1
			   GA_Text,node->ln_Name,
d376 1
a376 1
			   GA_Text,remote?(char *)remote:(char *)FilePart(node->ln_Name),
d393 1
a393 1
	res=sendrequest("STOR",node->ln_Name,remote?(char *)remote:(char *)FilePart(node->ln_Name));
d404 2
d880 36
@


1.625
log
@Cleaned up the code a bit.
Rename ftpwin.h to AmiFTP.h and ftpwin.c to AmiFTP.c.
Created Menu.c and moved all menu-functions there.
@
text
@d1 2
a2 2
/* RCS Id: $Id: TransferWindow.c 1.595 1996/06/18 23:19:14 lilja Exp lilja $
   Locked version: $Revision: 1.595 $
d442 6
a447 6
	sprintf(buf1,"%ld",bytes);
	sprintf(buf2,"%ld",cps);
	sprintf(buf3,"%0.2d:%0.2d:%0.2d",hours, mins, secs);
	if (SetGadgetAttrs(TG_List[TG_CPS],TransferWindow,NULL,
			   GA_Text,buf2,TAG_DONE)){ 
	    RefreshGList(TG_List[TG_CPS],TransferWindow,NULL,1);
d449 2
a450 2
	if (SetGadgetAttrs(TG_List[TG_ETA], TransferWindow,NULL,
			   GA_Text,buf3,TAG_DONE)) {
d455 2
a456 2
	SetGadgetAttrs(TG_List[TG_Gauge],TransferWindow,NULL,
		       FUELGAUGE_Level,FileSize?(bytes*100)/FileSize:0,
d525 1
a525 1
    sprintf(tbufs,"%ld",size);
@


1.595
log
@Fixed something.
,
@
text
@d1 2
a2 2
/* RCS Id: $Id: TransferWindow.c 1.587 1996/06/14 13:23:25 lilja Exp lilja $
   Locked version: $Revision: 1.587 $
d5 1
a5 1
#include "ftpwin.h"
@


1.587
log
@Added RCS-variables to source-files.
@
text
@d1 2
a2 2
/* RCS Id: $Id$
   Locked version: $Revision$
d340 2
a341 1
	BPTR lock=Lock(node->ln_Name,SHARED_LOCK);
d343 9
d382 4
a385 1
	res=TRSF_OK;
@


1.585
log
@Changed the parsing of the command line site.
ESC now closes all windows but connect- and transferwindow.
RETURN connects to the current site.
Using the Exec-list functions/macros.
New windowtitle, now with # of files selected and more.
@
text
@d1 2
a2 2
/* dl_gui.c
   Code should work with v38.
@


1.539
log
@Fixed transfer bug when getting Aminet-files and the getreadme was
on. This was due to bad naming of structure members.
@
text
@d42 1
a42 1
    for (node=GetHead(flist);node;node=GetSucc(node)) {
d182 1
a182 1
    for (node=GetHead(flist);node;node=GetSucc(node)) {
d192 1
a192 1

d253 4
d298 1
a298 2
                          WINDOW_IDCMPHook,&IDCMPHook,
                          WINDOW_IDCMPHookBits,IDCMP_RAWKEY,
d338 1
a338 1
    for (node=GetHead(transferlist);node;node=GetSucc(node)) {
d614 3
a616 1
    for (qe=(struct QueueEntry *)GetHead(queue);qe;qe=(struct QueueEntry *)GetSucc((struct Node *)qe)) {
d713 1
a713 1
	for (node=GetHead(entry->filelist);node;node=GetSucc(node)) {
d732 1
a732 1
	for (node=GetHead(entry->filelist);node;node=GetSucc(node)) {
d768 1
a768 1
	for (node=GetHead(entry->filelist);node;node=GetSucc(node)) {
@


1.531
log
@Lots of stuff
@
text
@d44 1
a44 1
	GetListBrowserNodeAttrs(node,LBNA_Selected,&sel,TAG_DONE);
d98 1
a98 1
			char *readme=NameToReadme(curr->name, curr->readmelen);
d102 1
a102 1
			result=get_file(aname, lname, curr->readmelength);
@


1.430
log
@Fixed name/date-sorting in ADT-mode.
@
text
@d7 1
a7 1
#ifndef NORECGETDIR
d9 1
a9 3
int getdir(char *remote_parent, char *local_parent, char *name, char *localname);
#endif
int newget_dir(char *remote_parent, char *local_parent, char *name, char *localname);
d18 1
a18 1
    TG_RemoteFile=0, TG_LocalFile, TG_Size, TG_CPS, TG_DataTransferred, TG_ETA,
d23 1
d25 2
a26 1
int DownloadFile(struct List *flist, const char *localname, const int binary, const int move)
d36 1
d52 3
a54 1
		    if (result=newget_dir(CurrentState.CurrentRemoteDir,CurrentState.CurrentDLDir,curr->name,curr->name)) {
d62 2
a63 1
			  SetListBrowserNodeAttrs(node,LBNA_Selected,FALSE,TAG_DONE);
d96 8
a103 1
		    result=get_file(aname,localfile,curr->size);
d106 1
a106 1
		    result=get_file(curr->name,localfile,curr->size);
d110 2
a111 2
		      LBEditNode(MG_List[MG_ListView],MainWindow,NULL,
				 node,LBNA_Selected,FALSE,TAG_DONE);
d113 1
a113 1
		      SetListBrowserNodeAttrs(node,LBNA_Selected,FALSE,TAG_DONE);
d126 1
a126 1
			    strmfp(localfile,CurrentState.CurrentDLDir,tmp);
d129 4
a132 3
			    if (localname[strlen(localname)-1]=='/'||localname[strlen(localname)-1]==':') {
				strcpy(localfile,localname);
				stcgfn(localfile+strlen(localfile),name);
d136 1
a136 1
				    strcpy(localfile,localname);
d138 1
a138 1
				    stcgfn(localfile+strlen(localfile),name);
d141 3
a143 2
				    if (index(localname,'/')||index(localname,':'))
				      strcpy(localfile,localname);
d145 2
a146 1
				      strmfp(localfile,CurrentState.CurrentDLDir,localname);
d150 1
a150 1
			result=get_file(name,localfile,curr->size);
d153 1
a153 1
				if (result==newget_dir(CurrentState.CurrentRemoteDir,CurrentState.CurrentDLDir,name,name)!=TRSF_OK) {
d159 2
a160 2
			      LBEditNode(MG_List[MG_ListView],MainWindow,NULL,
					 node,LBNA_Selected,FALSE,TAG_DONE);
d162 2
a163 1
			      SetListBrowserNodeAttrs(node,LBNA_Selected,FALSE,TAG_DONE);
d167 2
a168 2
			      LBEditNode(MG_List[MG_ListView],MainWindow,NULL,
					 node,LBNA_Selected,FALSE,TAG_DONE);
d170 2
a171 1
			      SetListBrowserNodeAttrs(node,LBNA_Selected,FALSE,TAG_DONE);
d184 1
a184 1
	GetListBrowserNodeAttrs(node,LBNA_Selected,&t,TAG_DONE);
d194 1
a194 2

    if (result==TRSF_OK||result==TRSF_ABORTED) {
d198 2
a199 1
	CloseTransferWindow();
d250 1
a250 1
		MoveWindowInFrontOf(TransferWindow,MainWindow);
a256 2
ULONG fuelargs[10];
//ULONG fargs=0;
d258 1
d261 1
a261 1
    struct Image *l;
d265 1
a265 1
    fuelargs[0]=0;//&fargs;
a266 1
//    kprintf("%s %ld\n",__FILE__,__LINE__);
d270 1
a270 126
    TransferLayout=LayoutObject,
                     GA_DrawInfo, DrawInfo,
                     GA_TextAttr, AmiFTPAttrF,
                     LAYOUT_DeferLayout, TRUE,
                     LAYOUT_SpaceOuter, TRUE,
                     LAYOUT_Orientation, LAYOUT_ORIENT_VERT,
                     LAYOUT_HorizAlignment, LALIGN_CENTRE,
//                     LAYOUT_BevelStyle,BVS_THIN,

                     StartVGroup, LAYOUT_BevelStyle,BVS_GROUP,LAYOUT_SpaceOuter,TRUE,LOffset(2),ROffset(2),TOffset(1),BOffset(1),
                     StartMember, TG_List[TG_RemoteFile]=ButtonObject,
                       GA_ID, TG_RemoteFile,
                       GA_RelVerify, TRUE,
                       GA_ReadOnly,TRUE,
                       CLASSACT_Underscore,0,
                       GA_Text, " ",
                       BUTTON_Justification, BCJ_LEFT,
                       ButtonEnd,
                       CHILD_MinWidth, PropFont->tf_XSize*35,
                       Label(GetAmiFTPString(TW_RemoteFile)),

                     StartMember, TG_List[TG_LocalFile]=ButtonObject,
                       GA_ID, TG_LocalFile,
                       GA_RelVerify, TRUE,
                       GA_ReadOnly,TRUE,
                       CLASSACT_Underscore,0,
                       GA_Text, " ",
                       BUTTON_Justification, BCJ_LEFT,
                       ButtonEnd,
                       CHILD_MinWidth, PropFont->tf_XSize*35,
                       Label(GetAmiFTPString(TW_LocalFile)),
                     EndGroup,

                     StartVGroup,LAYOUT_BevelStyle,BVS_GROUP,LAYOUT_SpaceOuter,TRUE,StartHGroup,LOffset(2),ROffset(2),TOffset(1),BOffset(1),

                       StartVGroup,
                        LAYOUT_AddImage,l=LabelObject,
                          LABEL_DrawInfo,DrawInfo,
                          LABEL_Text,GetAmiFTPString(TW_Size),
                          LabelEnd,
                          CHILD_MinWidth,l->Width,
                          CHILD_MinHeight,l->Height,
                          CHILD_WeightedWidth,0,
                          CHILD_WeightedHeight,0,
                        StartMember, TG_List[TG_Size]=ButtonObject,
                          GA_ID, TG_Size,
                          GA_RelVerify, TRUE,
                          GA_ReadOnly,TRUE,
                          GA_Text, " ",
                          BUTTON_Justification, BCJ_RIGHT,
                          ButtonEnd,
                          CHILD_MinWidth, len*9,
                       EndGroup,
//                       Label(GetAmiFTPString(TW_Size)),

                       StartVGroup,
                         LAYOUT_AddImage,l=LabelObject,
                           LABEL_DrawInfo,DrawInfo,
                           LABEL_Text,GetAmiFTPString(TW_DataTransferred),
                           LabelEnd,
                           CHILD_MinWidth,l->Width,
                           CHILD_MinHeight,l->Height,
                           CHILD_WeightedWidth,0,
                           CHILD_WeightedHeight,0,
                         StartMember, TG_List[TG_DataTransferred]=ButtonObject,
                           GA_ID, TG_DataTransferred,
                           GA_RelVerify, TRUE,
                           GA_ReadOnly,TRUE,
                           GA_Text, " ",
                           BUTTON_Justification, BCJ_RIGHT,
                           ButtonEnd,
                          CHILD_MinWidth, len*9,
//                       Label(GetAmiFTPString(TW_DataTransferred)),
                       EndGroup,

                       StartVGroup,
                         LAYOUT_AddImage,l=LabelObject,
                          LABEL_DrawInfo,DrawInfo,
                          LABEL_Text,GetAmiFTPString(TW_Cps),
                          LabelEnd,
                          CHILD_MinWidth,l->Width,
                          CHILD_MinHeight,l->Height,
                          CHILD_WeightedWidth,0,
                          CHILD_WeightedHeight,0,
                         StartMember, TG_List[TG_CPS]=ButtonObject,
                          GA_ID, TG_CPS,
                          GA_RelVerify, TRUE,
                          GA_ReadOnly,TRUE,
                          GA_Text, " ",
                          BUTTON_Justification, BCJ_RIGHT,
                          ButtonEnd,
                          CHILD_MinWidth, len*7,
                       EndGroup,
//                       Label(GetAmiFTPString(TW_Cps)),

                     EndGroup, /* End of Horizontal group */

                     StartMember, TG_List[TG_ETA]=ButtonObject,
                        GA_ID, TG_ETA,
                        GA_RelVerify, TRUE,
                        GA_ReadOnly,TRUE,
                        GA_Text, "00:00:00",
                        BUTTON_Justification, BCJ_RIGHT,
                        ButtonEnd,

                     StartHGroup,LOffset(2),ROffset(2),TOffset(1),BOffset(1),
                     StartMember, TG_List[TG_Gauge]=FuelGaugeObject,
                       GA_Text, "%ld%%",
                       FUELGAUGE_Orientation, FUELGAUGE_HORIZONTAL,
                       FUELGAUGE_Justification, FGJ_CENTER,
                       FUELGAUGE_Percent, TRUE,
                       FUELGAUGE_Min,0,
                       FUELGAUGE_Max,100,
                       FUELGAUGE_Level, 0,
                       FUELGAUGE_Ticks, 11,
                       FUELGAUGE_VarArgs, &fuelargs[0],
                       FuelGaugeEnd,EndGroup,
                     EndGroup, /* End of transferdata group */
                     StartMember, TG_List[TG_Abort]=ButtonObject,
                       GA_ID, TG_Abort,
                       GA_RelVerify, TRUE,
                       GA_Text, GetAmiFTPString(TW_Abort),
                       ButtonEnd,
                       CHILD_WeightedWidth,0,
                       CHILD_WeightMinimum, TRUE,
                   LayoutEnd;
d275 3
d283 1
a283 1
                          WA_Title, "AmiFTP Transfer window",
a301 1
//	kprintf("%s %ld\n",__FILE__,__LINE__);
a338 1
//	kprintf("Next file in list: %s\n",node->ln_Name);
a345 1
//	    kprintf("%ld\n",__LINE__);
a348 1
//	    kprintf("%ld\n",__LINE__);
a349 1
//	    kprintf("%ld\n",__LINE__);
a352 1
//	    kprintf("%ld\n",__LINE__);
a353 7
//	    kprintf("%ld\n",__LINE__);
	    SetGadgetAttrs(TG_List[TG_Size], TransferWindow, NULL,
			   GA_Text,buf,
			   TAG_DONE);
//	    kprintf("%ld\n",__LINE__);
	    RefreshGList(TG_List[TG_Size],TransferWindow,NULL,1);
//	    kprintf("%ld\n",__LINE__);
a356 1
//	    kprintf("%ld\n",__LINE__);
a357 5
//	    kprintf("%ld\n",__LINE__);
	    SetGadgetAttrs(TG_List[TG_DataTransferred], TransferWindow, NULL,
			   GA_Text, "0",
			   TAG_DONE);
//	    kprintf("%ld\n",__LINE__);
d359 1
a359 2
//	    kprintf("%ld\n",__LINE__);
	    fuelargs[0]=0;
d362 1
a362 1
			       FUELGAUGE_VarArgs,&fuelargs[0],
a367 1
//	kprintf("Sending %s\n",node->ln_Name);
a375 1
//    kprintf("closing window\n");
a432 4
	if (SetGadgetAttrs(TG_List[TG_DataTransferred],TransferWindow,NULL,
			   GA_Text,buf1,TAG_DONE)) {
	    RefreshGList(TG_List[TG_DataTransferred],TransferWindow,NULL,1);
	}
d437 2
a438 2
	fuelargs[0]=FileSize?(bytes*100)/FileSize:0;
//	fargs=47;
d449 7
a455 1
    static ULONG tags[]={RTEZ_ReqTitle,NULL,RT_Window,NULL,RT_LockWindow,TRUE,RT_ReqPos,REQPOS_CENTERWIN,TAG_END};
d475 3
a477 1
    Gadgetstring=malloc(strlen(GetAmiFTPString(TW_Overwrite))+strlen(GetAmiFTPString(TW_Resume))+strlen(GetAmiFTPString(TW_CancelTransfer))+3);
d481 4
a484 2
	sprintf(Gadgetstring,"%s|%s",GetAmiFTPString(TW_Overwrite),GetAmiFTPString(TW_CancelTransfer));
	ret=(BOOL)rtEZRequest(GetAmiFTPString(TW_FileExists),Gadgetstring,NULL,(struct TagItem *)tags,lfile,fib.fib_Size,size);
d491 4
a494 2
	sprintf(Gadgetstring,"%s|%s|%s",GetAmiFTPString(TW_Overwrite),GetAmiFTPString(TW_Resume),GetAmiFTPString(TW_CancelTransfer));
	ret=(BOOL)rtEZRequest(GetAmiFTPString(TW_FileExists),Gadgetstring,NULL,(struct TagItem *)tags,lfile,fib.fib_Size,size);
a508 1
//    Printf("size: %ld\n",size);
a509 3
    if (SetGadgetAttrs(TG_List[TG_Size],TransferWindow,NULL,
		       GA_Text,tbufs,TAG_DONE))
      RefreshGList(TG_List[TG_Size],TransferWindow,NULL,1);
d511 9
a519 1
//   Printf("filesize: %ld\n",FileSize);
a531 1
//	kprintf("%ld\n",__LINE__);
d533 2
a534 2
			   CLASSACT_Underscore,'\n',
			   GA_Text,localname,
d536 1
a536 2
	  RefreshGList(TG_List[TG_LocalFile],TransferWindow,NULL,1);
//	kprintf("%ld\n",__LINE__);
d538 1
a538 6
			   GA_Text,name,
			   TAG_DONE))
	  RefreshGList(TG_List[TG_RemoteFile],TransferWindow,NULL,1);
//	kprintf("%ld\n",__LINE__);
	if (SetGadgetAttrs(TG_List[TG_Size], TransferWindow, NULL,
			   GA_Text,buf,
d540 1
a540 2
	  RefreshGList(TG_List[TG_Size],TransferWindow,NULL,1);
//	kprintf("%ld\n",__LINE__);
d544 1
a544 7
	  RefreshGList(TG_List[TG_CPS],TransferWindow,NULL,1);
//	kprintf("%ld\n",__LINE__);
	if (SetGadgetAttrs(TG_List[TG_DataTransferred], TransferWindow, NULL,
			   GA_Text, "0",
			   TAG_DONE))
	  RefreshGList(TG_List[TG_DataTransferred],TransferWindow,NULL,1);
//	kprintf("%ld\n",__LINE__);
d546 4
a549 4
//	fargs=0;
	SetGadgetAttrs(TG_List[TG_Gauge],TransferWindow,NULL,
		       FUELGAUGE_Level,0,
		       FUELGAUGE_VarArgs,&fuelargs[0],
a550 4
/*	  if (AttemptLockLayerRom(TransferWindow->WLayer)) {
	      UnlockLayerRom(TransferWindow->WLayer);
	      RefreshGList(TG_List[TG_Gauge],TransferWindow,NULL,1);
	  }*/
d552 1
a552 1
    if (CheckExists(localname,size,&restartpoint))
d554 1
a554 2
    rval = recvrequest("RETR", localname, name, "w",restartpoint);

d579 7
a585 1
    static ULONG tags[]={RTEZ_ReqTitle,NULL,RT_Window,NULL,RT_LockWindow,TRUE,RT_ReqPos,REQPOS_CENTERWIN,TAG_END};
d590 1
d593 2
a594 1
    ret=(BOOL)rtEZRequest(GetAmiFTPString(TW_DownloadDir),GetAmiFTPString(TW_GetDir),NULL,(struct TagItem *)tags);
a597 1
    
d618 1
a618 1
int newget_dir(char *remote_parent, char *local_parent, char *name, char *localname)
d717 1
a717 1
//		kprintf("Getting %s as %s\n",tmp->name,tmpname);
@


1.401
log
@Started on improving the functionnames.
Added Aminet-mode, not 100% finished yet.
Reworked the prefs-window, not everything is finished.
Started using listbrowser v41-functions.
Added parsing of URL-like commandline.
@
text
@d241 2
d250 1
d363 1
d365 1
d371 1
d487 1
d490 1
d571 2
d575 1
d677 2
d681 1
@


1.265
log
@Groups added. Bugs fixed.
@
text
@d20 1
a20 1
    TG_RemoteFile=0, TG_LocalFile, TG_Size, TG_CPS, TG_DataTransferred, 
d55 5
a59 3
			if (flist==FileList) DetachToolList();
			SetListBrowserNodeAttrs(node,LBNA_Selected,FALSE,TAG_DONE);
			if (flist==FileList) AttachToolList(FALSE);
d98 6
a103 4
		    if (flist==FileList) DetachToolList();
		    SetListBrowserNodeAttrs(node,LBNA_Selected,FALSE,TAG_DONE);
		    if (flist==FileList) AttachToolList(FALSE);
		}
d144 5
a148 3
			    if (flist==FileList) DetachToolList();
			    SetListBrowserNodeAttrs(node,LBNA_Selected,FALSE,TAG_DONE);
			    if (flist==FileList) AttachToolList(FALSE);
d151 5
a155 3
			    if (flist==FileList) DetachToolList();
			    SetListBrowserNodeAttrs(node,LBNA_Selected,FALSE,TAG_DONE);
			    if (flist==FileList) AttachToolList(FALSE);
d180 3
d349 9
d499 3
d534 1
d536 11
a546 1
	static char buf1[20],buf2[20];
d549 2
a550 1
	sprintf(buf2,"%ld",timee?(bytes-restart_point)/timee:0);
a553 1
	    Printf("Refreshing\n");
d558 4
a561 1
	    Printf("Refreshing\n");
d584 1
a584 1
    if (SilentMode==TRUE) {
d715 1
d728 1
a728 1
	printf("remote_parent '%s' dirname '%s'\nlocal_parent '%s' localname '%s'\n",
d730 1
a730 1
	printf("----------------------------------------------------\n");
d786 1
a786 1
if (DEBUG) Printf("Popped '%s' '%s' of the stack\n",entry->remote_parent,entry->dirname);
d795 1
a795 1
if (DEBUG) Printf("'%s' '%s'\n",entry->remote_parent,entry->dirname);
d823 1
a823 2
if (DEBUG) {Printf("LINE: %ld\n",__LINE__);
	    PrintQueue(&Queue);}
a842 1
	if (DEBUG)	PrintQueue(&Queue);
a878 2
if (DEBUG) {Printf("LINE: %ld\n",__LINE__);
	    PrintQueue(&Queue);}
a926 3
		    if (DEBUG) printf("Adding '%s' '%s' '%s' '%s'to queue\n",
				      qentry->remote_parent, qentry->dirname,
				      qentry->local_parent,qentry->localname);
a946 2
if (DEBUG) {	printf("LINE: %ld\n",__LINE__);
		PrintQueue(&Queue);}
@


1.200
log
@GETATTR-hit fixed.
@
text
@a34 1
//    kprintf("%s %ld %ld\n",__FILE__,__LINE__,MAXPATHLEN);
a35 1
//    kprintf("%s %ld\n",__FILE__,__LINE__);
a40 1
//    kprintf("%s %ld\n",__FILE__,__LINE__);
a42 1
//	kprintf("%s %ld\n",__FILE__,__LINE__);
a43 1
//	kprintf("%s %ld\n",__FILE__,__LINE__);
d87 8
a94 3
//		kprintf("%s %ld\n",__FILE__,__LINE__);Delay(50);
		result=get_file(curr->name,localfile,curr->size);
//		kprintf("%s %ld\n",__FILE__,__LINE__);Delay(50);
d267 1
d517 4
a520 2
			   GA_Text,buf2,TAG_DONE))
	  RefreshGList(TG_List[TG_CPS],TransferWindow,NULL,1);
d522 4
a525 2
			   GA_Text,buf1,TAG_DONE))
	  RefreshGList(TG_List[TG_DataTransferred],TransferWindow,NULL,1);
@


1.184
log
@Hopefully fixed upload/download bug with refreshglist()
@
text
@d11 1
d26 1
a26 1
int DownloadFile(struct List *flist, char *localname, int binary, int move)
d41 1
a41 1
	return(TRANS_GUI);
d173 1
a173 1
	return(result==TRSF_OK?TRANS_OK:TRANS_ABORTED);
d199 1
a199 1
    return (TRANS_ERROR);
d228 1
a228 1
    return (done);
d240 1
a240 1
      return (TransferWindow);
d357 1
a357 1
      return (NULL);
d380 1
a380 1
      return (NULL);
d384 1
a384 1
	return (TransferWindow);
d389 1
a389 1
    return (NULL);
d404 1
a404 1
int UploadFile(struct List *transferlist, char *remote,int binary)
d415 1
a415 1
	return (TRANS_GUI);
d441 1
a441 1
//	    kprintf("%ld %lx %lx\n",__LINE__,TG_List[TG_LocalFile],TransferWindow);
d475 1
a475 1
      return(res);
d479 1
a479 1
	return (res);
d504 1
a504 1
    return (TRANS_ERROR);
d508 1
a508 1
void UpdateDLGads(long bytes,long restart_point, time_t timee)
d538 1
a538 1
      return(FALSE);
d552 1
a552 1
      return(FALSE);
d559 1
a559 1
	  return (FALSE);
d566 1
a566 1
	  return (FALSE);
d569 1
a569 1
	    return (FALSE);
d572 1
a572 1
    return (TRUE);
d576 1
a576 1
void SetTransferSize(long size)
a588 1
    char	*ftperr;
d633 1
a633 1
      return (TRSF_OK);
d636 1
a636 1
    return(rval);
d649 1
a649 1
	  return (NULL);
d655 1
a655 1
    return (tmp);
d664 1
a664 1
      return (FALSE);
d669 2
a670 2
      return(TRUE);
    return(FALSE);
d711 1
a711 1
      return (TRSF_FAILED);
d715 1
a715 1
	return (TRSF_FAILED);
d721 1
a721 1
	return (TRSF_FAILED);
d728 1
a728 1
	return (TRSF_FAILED);
d736 1
a736 1
	return (TRSF_FAILED);
d915 1
a915 1
    return (TRSF_OK);
d929 1
a929 1
    return (rval);
@


1.173
log
@bugversion
@
text
@d34 1
a34 1
    kprintf("%s %ld %ld\n",__FILE__,__LINE__,MAXPATHLEN);
d36 1
a36 1
    kprintf("%s %ld\n",__FILE__,__LINE__);
d42 1
a42 1
    kprintf("%s %ld\n",__FILE__,__LINE__);
d45 1
a45 1
	kprintf("%s %ld\n",__FILE__,__LINE__);
d47 1
a47 1
	kprintf("%s %ld\n",__FILE__,__LINE__);
d91 1
a91 1
		kprintf("%s %ld\n",__FILE__,__LINE__);Delay(50);
d93 1
a93 1
		kprintf("%s %ld\n",__FILE__,__LINE__);Delay(50);
d237 1
a237 1
    kprintf("%s %ld\n",__FILE__,__LINE__);
d420 1
a420 1
	kprintf("Next file in list: %s\n",node->ln_Name);
d428 1
a428 1
	    kprintf("%ld\n",__LINE__);
d432 3
a434 1
	    kprintf("%ld\n",__LINE__);
d438 3
a440 1
	    kprintf("%ld\n",__LINE__);
d444 3
a446 1
	    kprintf("%ld\n",__LINE__);
d450 3
a452 1
	    kprintf("%ld\n",__LINE__);
d456 3
a458 2
	    /* Hack to fix fuelgauge-bug */
	    kprintf("%ld\n",__LINE__);
a461 4
/*	      if (AttemptLockLayerRom(TransferWindow->WLayer)) {
		  UnlockLayerRom(TransferWindow->WLayer);
		  RefreshGList(TG_List[TG_Gauge],TransferWindow,NULL,1);
	      }*/
a464 11
	    kprintf("%ld\n",__LINE__);
	    RefreshGList(TG_List[TG_RemoteFile],TransferWindow,NULL,1);
	    kprintf("%ld %lx %lx\n",__LINE__,TG_List[TG_LocalFile],TransferWindow);
	    RefreshGList(TG_List[TG_LocalFile],TransferWindow,NULL,1);
	    kprintf("%ld\n",__LINE__);
	    RefreshGList(TG_List[TG_Size],TransferWindow,NULL,1);
	    kprintf("%ld\n",__LINE__);
	    RefreshGList(TG_List[TG_CPS],TransferWindow,NULL,1);
	    kprintf("%ld\n",__LINE__);
	    RefreshGList(TG_List[TG_DataTransferred],TransferWindow,NULL,1);
	    kprintf("%ld\n",__LINE__);
d466 1
a466 1
	kprintf("Sending %s\n",node->ln_Name);
d468 1
d475 1
a475 1
    kprintf("closing window\n");
d515 1
a515 1
		       GA_Text,buf2,TAG_DONE))
d518 1
a518 1
		       GA_Text,buf1,TAG_DONE))
d520 3
a522 8
//	if (bytes-last > 2048)
	  SetGadgetAttrs(TG_List[TG_Gauge],TransferWindow,NULL,
			 FUELGAUGE_Level,FileSize?(bytes*100)/FileSize:0,
			 TAG_DONE);
/*	    if (AttemptLockLayerRom(TransferWindow->WLayer)) {
		UnlockLayerRom(TransferWindow->WLayer);
		RefreshGList(TG_List[TG_Gauge],TransferWindow,NULL,1);
	    }*/
d597 1
a597 1
	kprintf("%ld\n",__LINE__);
d603 1
a603 1
	kprintf("%ld\n",__LINE__);
d608 1
a608 1
	kprintf("%ld\n",__LINE__);
d613 1
a613 1
	kprintf("%ld\n",__LINE__);
d618 1
a618 1
	kprintf("%ld\n",__LINE__);
d623 1
a623 1
	kprintf("%ld\n",__LINE__);
d625 2
a626 2
			FUELGAUGE_Level,0,
			TAG_DONE);
@


1.150
log
@Iconify while transferring added.
Nicer update of fuelgauge.
@
text
@d34 1
a34 1
//    kprintf("%s %ld\n",__FILE__,__LINE__);
d36 1
a36 1
//    kprintf("%s %ld\n",__FILE__,__LINE__);
d42 1
a42 1
//    kprintf("%s %ld\n",__FILE__,__LINE__);
d45 1
a45 1
//	kprintf("%s %ld\n",__FILE__,__LINE__);
d47 1
a47 1
//	kprintf("%s %ld\n",__FILE__,__LINE__);
d91 1
a91 1
//		kprintf("%s %ld\n",__FILE__,__LINE__);Delay(50);
d93 1
a93 1
//		kprintf("%s %ld\n",__FILE__,__LINE__);Delay(50);
d237 1
a237 1
//    kprintf("%s %ld\n",__FILE__,__LINE__);
d420 1
a420 1

d428 1
d432 1
d436 1
d440 1
d444 1
d449 2
a450 1
	    if (SetGadgetAttrs(TG_List[TG_Gauge],NULL,NULL,
d452 2
a453 2
			       TAG_DONE))
	      if (AttemptLockLayerRom(TransferWindow->WLayer)) {
d456 1
a456 1
	      }
d460 1
d462 1
d464 1
d466 1
d468 1
d470 1
d472 1
d480 1
d607 1
d613 1
d618 1
d623 1
d628 1
d633 5
a637 4
	if (SetGadgetAttrs(TG_List[TG_Gauge],NULL,NULL,
		       FUELGAUGE_Level,0,
		       TAG_DONE))
	  if (AttemptLockLayerRom(TransferWindow->WLayer)) {
d640 1
a640 1
	  }
@


1.124
log
@AmiTCP and AS225r2 support in the same binary.
ARexx-command VIEW added.
New option to SETATTR, QUIET.
SETATTR LOCALDIR didn't update the download dir-gadget.
GETATTR STEM=bar didn't work since bar is in lowercase.
Enforcer hits when trying to open AmiFTP on a non-existing screen removed.
Moved 'Show dot-files?' to the Settings-menu.
Icelandic and Spanish catalogs added.
@
text
@a176 1
	GetAttr(WINDOW_SigMask, MainWin_Object, &mainsignal);
d185 1
d220 4
a223 2
	    else
	      MainWindow=CA_OpenWindow(MainWin_Object);
d234 2
d291 1
a291 1
                          CHILD_MinWidth, PropFont->tf_XSize*11,
d311 1
a311 1
                          CHILD_MinWidth, PropFont->tf_XSize*11,
d331 1
a331 1
                          CHILD_MinWidth, PropFont->tf_XSize*10,
d512 4
a515 4
	  if (SetGadgetAttrs(TG_List[TG_Gauge],NULL,NULL,
			     FUELGAUGE_Level,FileSize?(bytes*100)/FileSize:0,
			     TAG_DONE))
	    if (AttemptLockLayerRom(TransferWindow->WLayer)) {
d518 1
a518 1
	    }
@


0.1343
log
@Removed some redudant things from AllocListbrowserNode()
Gadgets no longer flicker since I keep track of the state. Thought ClassAct did that, but no...
Added one tick to the fuelgauge, now 11 ticks => 10 intervals.
@
text
@d34 1
d36 1
d42 1
d45 1
d47 1
d91 1
d93 1
d184 10
a193 8
	while (!done) {
	    wait=Wait(signal|AG_Signal|mainsignal);
	    if (wait & AG_Signal)
	      HandleAmigaGuide();
	    if (wait & signal)
	      done=HandleTransferIDCMP();
	    if (wait & mainsignal)
	      HandleMainWindowIDCMP(FALSE);
d215 8
d233 1
d239 1
d255 1
a255 1
                       CHILD_MinWidth, ScreenFont->tf_XSize*35,
d265 1
a265 1
                       CHILD_MinWidth, ScreenFont->tf_XSize*35,
d287 1
a287 1
                          CHILD_MinWidth, ScreenFont->tf_XSize*11,
d307 1
a307 1
                          CHILD_MinWidth, ScreenFont->tf_XSize*11,
d327 1
a327 1
                          CHILD_MinWidth, ScreenFont->tf_XSize*10,
d354 1
a354 1
    LayoutLimits((struct Gadget *)TransferLayout,&limits,ScreenFont,Screen);
d368 1
d378 1
d476 11
a486 9
    while (!done) {
	wait=Wait(signal|AG_Signal);

	if (wait&signal)
	  done=HandleTransferIDCMP();
	if (wait & AG_Signal)
	  HandleAmigaGuide();
	if (wait & mainsignal)
	  HandleMainWindowIDCMP(FALSE);
d532 5
@


0.1332
log
@Release 1.0
AmiFTP doesn't need amigaguide.library in order to start.
@
text
@d320 1
a320 1
                       FUELGAUGE_Ticks, 10,
@


0.1300
log
@Added Reload-gadget.
Added Sort-gadget to sitelist-window.
AmiFTP now show the correct size of links during transfer.
@
text
@d313 1
d321 1
a321 1
                       FuelGaugeEnd,
d418 9
a426 3
	    SetGadgetAttrs(TG_List[TG_Gauge],TransferWindow,NULL,
			   FUELGAUGE_Level,0,
			   TAG_DONE);
d484 8
a491 5
	if (bytes-last > 2048)
	  SetGadgetAttrs(TG_List[TG_Gauge],TransferWindow,NULL,
			 FUELGAUGE_Level,FileSize?(bytes*100)/FileSize:0,
			 TAG_DONE);
//	RefreshGList(TG_List[TG_Gauge],TransferWindow,NULL,1);
d541 1
d547 1
d582 1
a582 1
	SetGadgetAttrs(TG_List[TG_Gauge],TransferWindow,NULL,
d584 5
a588 1
		       TAG_DONE);
@


0.863
log
@Releaseversion (maybe)
@
text
@d11 11
a21 1
extern BOOL V40;
d23 1
a23 142
struct Gadget *dl_Gadgets[NumGadgets_dl];

struct GadGroup dl_Group1;

struct NewGadget dl_NewGadgets[]={
    {0,0,0,0,NULL,NULL,0,PLACETEXT_LEFT,NULL,NULL}, /* Remote file */
    {0,0,0,0,NULL,NULL,1,PLACETEXT_LEFT,NULL,NULL}, /* Local file */
    {0,0,0,0,NULL,NULL,2,PLACETEXT_LEFT,NULL,NULL}, /* Size */
    {0,0,0,0,NULL,NULL,3,PLACETEXT_LEFT,NULL,NULL}, /* CPS */
    {0,0,0,0,NULL,NULL,4,PLACETEXT_LEFT,NULL,NULL}, /* Data transferred */
    {0,0,0,0,NULL,NULL,5,PLACETEXT_IN,NULL,NULL}    /* Abort */
};

LONG dl_GadgetLabels[]=
{
    (LONG)TW_RemoteFile,
    (LONG)TW_LocalFile,
    (LONG)TW_Size,
    (LONG)TW_Cps,
    (LONG)TW_DataTransferred,
    (LONG)TW_Abort,
    -1
};

ULONG dl_ngtags[] = {
    /* "Remote file" */
    GTTX_Border,TRUE,
    TAG_END,
    /* "Local file" */
    GTTX_Border,TRUE,
    TAG_END,
    /* "Size" */
    GTNM_Border,TRUE,
    GTNM_Number, NULL,
    GTNM_Clipped,TRUE,
    GTNM_Justification,GTJ_RIGHT,
    TAG_END,
    /* "CPS" */
    GTNM_Border,TRUE,
    GTNM_Clipped,TRUE,
    GTNM_Justification,GTJ_RIGHT,
    TAG_END,
    /* "Data transferred" */
    GTNM_Border,TRUE,
    GTNM_Clipped,TRUE,
    GTNM_Justification,GTJ_RIGHT,
    TAG_END,
    /* "Abort transfer" */
    TAG_END
  };
ULONG dl_ngtags39[] = {
    /* "Remote file" */
    GTTX_Border,TRUE,
    TAG_END,
    /* "Local file" */
    GTTX_Border,TRUE,
    TAG_END,
    /* "Size" */
    GTNM_Border,TRUE,
    GTNM_Number, NULL,
    TAG_END,
    /* "CPS" */
    GTNM_Border,TRUE,
    TAG_END,
    /* "Data transferred" */
    GTNM_Border,TRUE,
    TAG_END,
    /* "Abort transfer" */
    TAG_END
  };
ULONG dl_ngtypes[] = {
    TEXT_KIND,
    TEXT_KIND,
    NUMBER_KIND,
    NUMBER_KIND,
    NUMBER_KIND,
    BUTTON_KIND
  };

struct Gadget *dl_glist;
struct Window *dl_Win;
char *make_path(char *parent, char *curdir);

void ComputeSize_dl(UWORD *minwidth,UWORD *minheight)
{
    UWORD n1,n2,n3;
    extern char www[];

    n1 = TextLength(PropRPort,www,25);
    n2 = GadgetTextLength(PropRPort,dl_NewGadgets[GD_dl_RemoteFile]);
    n3 = GadgetTextLength(PropRPort,dl_NewGadgets[GD_dl_LocalFile]);
    n2 = max(n2,n3);
    n3 = GadgetTextLength(PropRPort,dl_NewGadgets[GD_dl_DataTransferred]);
    n2 = max(n2,n3);

    *minwidth = n1+PropFHigh+2*INTERWIDTH+n2;
    *minheight = 6*PropFHigh+13*INTERHEIGHT+2*INTERHEIGHT;

    dl_NewGadgets[GD_dl_RemoteFile].ng_LeftEdge= n2+INTERWIDTH+PropFHigh;
    dl_NewGadgets[GD_dl_RemoteFile].ng_TopEdge = INTERHEIGHT;
    dl_NewGadgets[GD_dl_RemoteFile].ng_Height  = PropFHigh+2*INTERHEIGHT;
    dl_NewGadgets[GD_dl_RemoteFile].ng_Width   = n1;

    dl_NewGadgets[GD_dl_LocalFile].ng_LeftEdge= dl_NewGadgets[GD_dl_RemoteFile].ng_LeftEdge;
    dl_NewGadgets[GD_dl_LocalFile].ng_TopEdge = dl_NewGadgets[GD_dl_RemoteFile].ng_TopEdge+PropFHigh+2*INTERHEIGHT;
    dl_NewGadgets[GD_dl_LocalFile].ng_Height  = dl_NewGadgets[GD_dl_RemoteFile].ng_Height;
    dl_NewGadgets[GD_dl_LocalFile].ng_Width   = n1;

    dl_NewGadgets[GD_dl_Size].ng_LeftEdge= dl_NewGadgets[GD_dl_RemoteFile].ng_LeftEdge;
    dl_NewGadgets[GD_dl_Size].ng_TopEdge = dl_NewGadgets[GD_dl_LocalFile].ng_TopEdge+PropFHigh+2*INTERHEIGHT;
    dl_NewGadgets[GD_dl_Size].ng_Height  = dl_NewGadgets[GD_dl_RemoteFile].ng_Height;
    dl_NewGadgets[GD_dl_Size].ng_Width   = TextLength(PropRPort,www,12);

    dl_NewGadgets[GD_dl_CPS].ng_LeftEdge= dl_NewGadgets[GD_dl_RemoteFile].ng_LeftEdge;
    dl_NewGadgets[GD_dl_CPS].ng_TopEdge = dl_NewGadgets[GD_dl_Size].ng_TopEdge+PropFHigh+2*INTERHEIGHT;
    dl_NewGadgets[GD_dl_CPS].ng_Height  = dl_NewGadgets[GD_dl_RemoteFile].ng_Height;
    dl_NewGadgets[GD_dl_CPS].ng_Width   = dl_NewGadgets[GD_dl_Size].ng_Width;

    dl_NewGadgets[GD_dl_DataTransferred].ng_LeftEdge= dl_NewGadgets[GD_dl_RemoteFile].ng_LeftEdge;
    dl_NewGadgets[GD_dl_DataTransferred].ng_TopEdge = dl_NewGadgets[GD_dl_CPS].ng_TopEdge+PropFHigh+2*INTERHEIGHT;
    dl_NewGadgets[GD_dl_DataTransferred].ng_Height  = dl_NewGadgets[GD_dl_RemoteFile].ng_Height;
    dl_NewGadgets[GD_dl_DataTransferred].ng_Width   = dl_NewGadgets[GD_dl_Size].ng_Width;

    dl_NewGadgets[GD_dl_AbortGad].ng_Width     = 2*INTERWIDTH+GadgetTextLength(PropRPort,dl_NewGadgets[GD_dl_AbortGad]);
    dl_NewGadgets[GD_dl_AbortGad].ng_LeftEdge  = *minwidth/2-dl_NewGadgets[GD_dl_AbortGad].ng_Width/2;
    dl_NewGadgets[GD_dl_AbortGad].ng_Height    = dl_NewGadgets[GD_dl_RemoteFile].ng_Height;
    dl_NewGadgets[GD_dl_AbortGad].ng_TopEdge   = dl_NewGadgets[GD_dl_DataTransferred].ng_TopEdge+PropFHigh+3*INTERHEIGHT;
}

static ULONG tw_tags[]={
    WA_PubScreen,NULL,
    WA_Top,NULL,
    WA_Left,NULL,
    WA_Width,NULL,
    WA_InnerHeight,NULL,
    WA_MinWidth,NULL,
    WA_MinHeight,NULL,
    WA_Title,NULL,
    WA_IDCMP,IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW|IDCMP_GADGETDOWN|IDCMP_GADGETUP|IDCMP_RAWKEY|IDCMP_GADGETHELP,
    WA_Flags,WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH,
    TAG_END
};
d27 1
a27 5
    UWORD Width,Height;
    struct Gadget *gad;
    struct IntuiMessage *imsg;
    BOOL Continue=TRUE,aborted=FALSE;
    char localfile[MAXPATHLEN+1];
d30 3
a32 1
    ULONG wmask,winmask;
d36 8
a43 39
    dl_Win=NULL;
    if (mainWin) {
	ComputeSize_dl(&Width,&Height);
	tw_tags[1]=(unsigned long)myScn;
	tw_tags[3]=mainWin->Height>Height?mainWin->TopEdge+(mainWin->Height-Height)/2:mainWin->TopEdge;
	tw_tags[5]=mainWin->Width>Width?mainWin->LeftEdge+(mainWin->Width-Width-myScn->WBorLeft-myScn->WBorRight)/2:mainWin->LeftEdge;
	tw_tags[7]=Width+myScn->WBorLeft+myScn->WBorRight;
	tw_tags[9]=Height;
	tw_tags[11]=Width+myScn->WBorLeft+myScn->WBorRight;
	tw_tags[13]=Height+myScn->WBorTop+myScn->WBorBottom;
	tw_tags[15]=(ULONG)GetAmiFTPString(TW_WinTitle);
	tw_tags[19]|=(mainWin->Flags&WFLG_WINDOWACTIVE)?WFLG_ACTIVATE:0;
	dl_Win=OpenWindowTagList(NULL,(struct TagItem *)tw_tags);
	if (!dl_Win)
	  return(TRANS_GUI);

	SetFont(dl_Win->RPort,Propdfont);
	gad = CreateContext(&dl_glist);
	if (!gad) {
	    StripIntuiMessages(dl_Win->UserPort,dl_Win);
	    CloseWindow(dl_Win);
	    return(TRANS_GUI);
	}

	if (!Layout(&gad,dl_Win,&dl_NewGadgets[0],V40?&dl_ngtags[0]:&dl_ngtags39[0],&dl_ngtypes[0],&dl_Gadgets[0],NumGadgets_dl)) {
	    StripIntuiMessages(dl_Win->UserPort,dl_Win);
	    CloseWindow(dl_Win);
	    FreeGadgets(dl_glist);
	    return(TRANS_GUI);
	}

	AddGList(dl_Win,dl_glist,~0,-1,NULL);
	RefreshGList(dl_Win->FirstGadget,dl_Win,NULL,-1);
	GT_RefreshWindow(dl_Win,NULL);
	HelpControl(dl_Win,HC_GADGETHELP);
    }

    for (curr=(struct dirlist *)GetHead(flist);curr;curr=(struct dirlist *)GetSucc((struct Node *)curr)) {
	if (curr->dl_Node.ln_Type) {
d45 1
d53 5
a57 2
		    if (result==TRSF_OK)
		      curr->dl_Node.ln_Type=0;
d87 5
a91 2
		if (result==TRSF_OK)
		  curr->dl_Node.ln_Type=0;
d96 16
a111 22
	      {
		  char *name;
		  name=linkname(curr->name);
		  if (name) {
		      memset(localfile,0,sizeof(localfile));
		      if (!localname) {
			  stcgfn(tmp,name);
			  strmfp(localfile,CurrentState.CurrentDLDir,tmp);
		      }
		      else {
			  if (localname[strlen(localname)-1]=='/'||localname[strlen(localname)-1]==':') {
			      strcpy(localfile,localname);
			      stcgfn(localfile+strlen(localfile),name);
			  }
			  else {
			      if (getfa(localname)==1) {
				  strcpy(localfile,localname);
				  strcat(localfile,"/");
				  stcgfn(localfile+strlen(localfile),name);
			      }
			      else {
				  if (index(localname,'/')||index(localname,':'))
d113 33
a145 22
				  else
				    strmfp(localfile,CurrentState.CurrentDLDir,localname);
			      }
			  }
		      }
		      result=get_file(name,localfile,curr->size);
		      if (result==TRSF_BADFILE) {
			  if (AskGetDir()) {
			      if (result==newget_dir(CurrentState.CurrentRemoteDir,CurrentState.CurrentDLDir,name,name)!=TRSF_OK) {
				  free(name);
				  goto out;
			      }
			  }
			  curr->dl_Node.ln_Type=0;
		      }
		      else if (result==TRSF_OK)
			curr->dl_Node.ln_Type=0;
		      else if (result==TRSF_ABORTED)
			goto out;
		      free(name);
		  }
	      }
a147 6
	    if (dl_Win) {
		GT_SetGadgetAttrs(mainGadgets[GD_Files_LV],mainWin,NULL,
				  GTLV_Labels,~0,TAG_END);
		GT_SetGadgetAttrs(mainGadgets[GD_Files_LV],mainWin,NULL,
				  GTLV_Labels,FileList,TAG_END);
	    }
d150 10
d164 21
a184 4
	if (dl_Win) {
	    StripIntuiMessages(dl_Win->UserPort,dl_Win);
	    CloseWindow(dl_Win);
	    FreeGadgets(dl_glist);
d186 2
a187 2
	dl_Win=0;
	return(result==TRSF_OK?TRANS_OK:TRANS_ABORTED);
d189 17
a205 54
    winmask=1<<dl_Win->UserPort->mp_SigBit;
    if (dl_Win) {
	wmask=Wait(winmask|AG_Signal);
	if (wmask&AG_Signal)
	  HandleAmigaGuide();
	if (wmask&winmask) {
	    while (Continue) {
		WaitPort(dl_Win->UserPort);
	    
		while (imsg = GT_GetIMsg(dl_Win->UserPort)) {
		    int (*func)();
		    struct IntuiMessage dl_Msg; 
		    ULONG MsgClass;
		    UWORD Code;
		    MsgClass= imsg->Class;
		    Code    = imsg->Code;
		    CopyMem(imsg,&dl_Msg,sizeof(dl_Msg));
		
		    GT_ReplyIMsg(imsg);
		
		    switch(MsgClass) {
		      case IDCMP_CLOSEWINDOW:
			Continue=FALSE;
			break;
		      case IDCMP_REFRESHWINDOW:
			GT_BeginRefresh(dl_Win);
			GT_EndRefresh(dl_Win,TRUE);
			//		Printf("Got refresh\n");
			break;
		      case IDCMP_GADGETHELP:
			ag.ag_region=-1;
			if (dl_Msg.IAddress==(APTR)dl_Win) {
			    ag.ag_region=0;
			}
			break;
		      case IDCMP_RAWKEY:
			if (dl_Msg.Code==95) {
			    SendAGMessage(AG_TRANSWIN);
			}
			break;
		      case IDCMP_GADGETUP:
		      case IDCMP_GADGETDOWN:
			func = (void *)((struct Gadget *)dl_Msg.IAddress)->UserData;
			if (func)
			  func();
			break;
		      default:
			break;
		    }
		}
	    }
	    StripIntuiMessages(dl_Win->UserPort,dl_Win);
	    CloseWindow(dl_Win);
	    FreeGadgets(dl_glist);
d208 165
a372 2
    dl_Win=NULL;
    return(TRANS_ERROR);
d375 1
d379 2
a380 4
    UWORD Width,Height;
    struct Gadget *gad;
    struct IntuiMessage *imsg;
    BOOL Continue=TRUE;
a382 1
    ULONG winmask,mask;
a384 1
    dl_Win=NULL;
d386 4
a389 33
    if (mainWin) {
	ComputeSize_dl(&Width,&Height);
	tw_tags[1]=(unsigned long)myScn;
	tw_tags[3]=mainWin->Height>Height?mainWin->TopEdge+(mainWin->Height-Height)/2:mainWin->TopEdge;
	tw_tags[5]=mainWin->Width>Width?mainWin->LeftEdge+(mainWin->Width-Width-myScn->WBorLeft-myScn->WBorRight)/2:mainWin->LeftEdge;
	tw_tags[7]=Width+myScn->WBorLeft+myScn->WBorRight;
	tw_tags[9]=Height;
	tw_tags[11]=Width+myScn->WBorLeft+myScn->WBorRight;
	tw_tags[13]=Height+myScn->WBorTop+myScn->WBorBottom;
	tw_tags[15]=(ULONG)GetAmiFTPString(TW_WinTitle);
	tw_tags[19]|=(mainWin->Flags&WFLG_WINDOWACTIVE)?WFLG_ACTIVATE:0;
	dl_Win=OpenWindowTagList(NULL,(struct TagItem *)tw_tags);
	if (!dl_Win)
	  return(TRANS_GUI);
	SetFont(dl_Win->RPort,Propdfont);
	gad = CreateContext(&dl_glist);
	if (!gad) {
	    StripIntuiMessages(dl_Win->UserPort,dl_Win);
	    CloseWindow(dl_Win);
	    return(TRANS_GUI);
	}
	if (!Layout(&gad,dl_Win,&dl_NewGadgets[0],V40?&dl_ngtags[0]:&dl_ngtags39[0],&dl_ngtypes[0],&dl_Gadgets[0],NumGadgets_dl)) {
	    StripIntuiMessages(dl_Win->UserPort,dl_Win);
	    CloseWindow(dl_Win);
	    FreeGadgets(dl_glist);
	    return(TRANS_GUI);
	}

	AddGList(dl_Win,dl_glist,~0,-1,NULL);
	RefreshGList(dl_Win->FirstGadget,dl_Win,NULL,-1);
	GT_RefreshWindow(dl_Win,NULL);
	HelpControl(dl_Win,HC_GADGETHELP);
    }
d400 27
a426 21
	if (mainWin) {
	    GT_SetGadgetAttrs(dl_Gadgets[GD_dl_LocalFile],dl_Win,NULL,
			      GTTX_Text,node->ln_Name,
			      GTTX_CopyText,TRUE,
			      TAG_END);
	    GT_SetGadgetAttrs(dl_Gadgets[GD_dl_RemoteFile],dl_Win,NULL,
			      GTTX_Text,remote?(char *)remote:(char *)FilePart(node->ln_Name),
			      GTTX_CopyText,TRUE,
			      TAG_END);

	    GT_SetGadgetAttrs(dl_Gadgets[GD_dl_Size],dl_Win,NULL,
			      GTNM_Number,size,
			      TAG_END);

	    GT_SetGadgetAttrs(dl_Gadgets[GD_dl_CPS],dl_Win,NULL,
			      GTNM_Number,0,
			      TAG_END);

	    GT_SetGadgetAttrs(dl_Gadgets[GD_dl_DataTransferred],dl_Win,NULL,
			      GTNM_Number,0,
			      TAG_END);
d432 22
a453 14
    if (mainWin) {
	GT_SetGadgetAttrs(dl_Gadgets[GD_dl_AbortGad],dl_Win,NULL,
			  GA_Disabled,TRUE,
			  TAG_END);
    }
    if (!mainWin)
      return(0);
    if (res==TRSF_ABORTED||res==TRSF_OK)
      Continue=FALSE;
    winmask=1<<dl_Win->UserPort->mp_SigBit;

    while (Continue) {
	mask=Wait(winmask|AG_Signal);
	if (mask&AG_Signal)
d455 3
a457 1
	if (mask&winmask) {
d459 2
a460 51
	    while (imsg = GT_GetIMsg(dl_Win->UserPort)) {
		int (*func)();
		struct IntuiMessage dl_Msg; 
		ULONG MsgClass;
		UWORD Code;
		MsgClass= imsg->Class;
		Code    = imsg->Code;
		CopyMem(imsg,&dl_Msg,sizeof(dl_Msg));

		GT_ReplyIMsg(imsg);

		switch(MsgClass) {
		  case IDCMP_CLOSEWINDOW:
		    Continue=FALSE;
		    break;
		  case IDCMP_REFRESHWINDOW:
		    GT_BeginRefresh(dl_Win);
		    GT_EndRefresh(dl_Win,TRUE);
		    break;
		  case IDCMP_GADGETHELP:
		    ag.ag_region=-1;
		    if (dl_Msg.IAddress==(APTR)dl_Win) {
			ag.ag_region=0;
		    }
		    break;
		  case IDCMP_RAWKEY:
		    if (dl_Msg.Code==95) {
			SendAGMessage(AG_TRANSWIN);
		    }
		    break;
		  case IDCMP_GADGETUP:
		  case IDCMP_GADGETDOWN:
		    func = (void *)((struct Gadget *)dl_Msg.IAddress)->UserData;
		    if (func)
		      func();
		    break;
		  default:
		    break;
		}
	    }
	}
    }
    StripIntuiMessages(dl_Win->UserPort,dl_Win);
    CloseWindow(dl_Win);
    FreeGadgets(dl_glist);
    dl_Win=NULL;
    if (res==TRSF_OK)
      return (TRANS_OK);
    if (res==TRSF_ABORTED)
      return (TRANS_ABORTED);
    return(TRANS_ERROR);
d463 1
d466 2
a467 2
    if (!dl_Win)
      return;
d469 13
a481 7
    GT_SetGadgetAttrs(dl_Gadgets[GD_dl_DataTransferred],dl_Win,NULL,
		      GTNM_Number,bytes,
		      TAG_END);
    if (timee) {
	GT_SetGadgetAttrs(dl_Gadgets[GD_dl_CPS],dl_Win,NULL,
			  GTNM_Number,(bytes-restart_point)/timee,
			  TAG_END);
d501 1
a501 1
    tags[3]=(ULONG)mainWin;
d527 10
d543 1
d545 28
a572 23
    if (dl_Win) {
	GT_SetGadgetAttrs(dl_Gadgets[GD_dl_LocalFile],dl_Win,NULL,
			  GTTX_Text,localname,
			  TAG_END);
	GT_SetGadgetAttrs(dl_Gadgets[GD_dl_RemoteFile],dl_Win,NULL,
			  GTTX_Text,name,
			  TAG_END);
	GT_SetGadgetAttrs(dl_Gadgets[GD_dl_Size],dl_Win,NULL,
/*			  GTNM_Clipped,TRUE,
			  GTNM_Justification,GTJ_RIGHT,*/
			  GTNM_Number,size,
			  TAG_END);
	GT_SetGadgetAttrs(dl_Gadgets[GD_dl_DataTransferred],dl_Win,NULL,
/*			  GTNM_Clipped,TRUE,
			  GTNM_Justification,GTJ_RIGHT,*/
			  GTNM_Number,NULL,
			  TAG_END);
	GT_SetGadgetAttrs(dl_Gadgets[GD_dl_CPS],dl_Win,NULL,
/*			  GTNM_Clipped,TRUE,
			  GTNM_Justification,GTJ_RIGHT,*/
			  GTNM_Number,NULL,
			  TAG_END);

d605 1
a605 1
    if (!mainWin)
d608 1
a608 1
    tags[3]=(ULONG)mainWin;
d645 1
d724 2
a725 1
	for (tmp=(struct dirlist *)GetHead(entry->filelist);tmp;tmp=(struct dirlist *)GetSucc(tmp)) {
d744 2
a745 1
	for (tmp=(struct dirlist *)GetHead(entry->filelist);tmp;tmp=(struct dirlist *)GetSucc(tmp)) {
d782 2
a783 1
	for (tmp=(struct dirlist *)GetHead(entry->filelist);tmp;tmp=(struct dirlist *)GetSucc(tmp)) {
@


0.859
log
@Leeching works now!
@
text
@d205 1
d208 1
a208 1
	    static char tmp[4*FESIZE];
a210 1
//#ifdef RECGETDIR
a220 1
//#endif
a282 1
#ifdef RECGETDIR
a288 1
#endif
a626 11
long __STKNEED=4000;
/*
#ifndef NORECGETDIR
int getdir(char *remote_parent, char *local_parent, char *name, char *localname)
{
    struct List *filelist;
    struct dirlist *tmp;
    char *ldir,*rdir;
    char *lname;
    BPTR newdir;
    int rval,len;
a627 99
    kprintf("getdir('%s','%s','%s','%s')\n",remote_parent,local_parent,name,localname);
    len=strlen(local_parent)+strlen(localname)+5;
    ldir=malloc(len);
    if (ldir==NULL)
      return (TRSF_FAILED);
    strcpy(ldir,local_parent);
    AddPart(ldir,localname,len);
    newdir=CreateDir(ldir);
    if (newdir==NULL && IoErr()!=ERROR_OBJECT_EXISTS) {
	free(ldir);
	return (TRSF_FAILED);
    }
    UnLock(newdir);
    command("CWD %s",name);
    if (code!=250) {
	ShowErrorReq(GetAmiFTPString(Str_CDFailed));
	free(ldir);
	return (1);
    }
//    ChangeDir(localname);
    
    kprintf("%ld '%s'\n",__LINE__,name);
    filelist=read_remote_dir();
    kprintf("%ld '%s'\n",__LINE__,name);
    if (filelist) {
	kprintf("getdir(): calling make_path('%s','%s')\n",remote_parent,name);
	rdir=make_path(remote_parent,name);
	if (rdir==NULL)
	  goto out;
	kprintf("getdir(): Getting files from %s to %s\n",rdir,ldir);
	kprintf("getdir(): local_parent '%s' localname '%s' ldir '%s'\n",local_parent,localname,ldir);
	for (tmp=(struct dirlist *)GetHead(filelist);tmp;tmp=(struct dirlist *)GetSucc((struct Node *)tmp)) {
	    if (S_ISREG(tmp->mode)) {
		char *tmpname=calloc(4*FESIZE,1);
		strmfp(tmpname,ldir,tmp->name);
kprintf("getdir(): Getting file: %s\n",tmp->name);
		if (get_file(tmp->name,tmpname,tmp->size)!=TRSF_OK) {
		    free(tmpname);
		    goto out;
		}
kprintf("getdir(): Got file\n");
		free(tmpname);
	    }
	}
kprintf("getdir(): Checking for dirs\n");
	for (tmp=(struct dirlist *)GetHead(filelist);tmp;tmp=(struct dirlist *)GetSucc((struct Node *)tmp)) {
	    if (S_ISDIR(tmp->mode)) {
kprintf("getdir(): Calling getdir('%s','%s','%s','%s')\n",rdir,ldir,tmp->name,tmp->name);
		if (getdir(rdir,ldir,tmp->name,tmp->name)!=TRSF_OK)
		  goto out;
	    }
	}
kprintf("getdir(): Checking for links\n");
	for (tmp=(struct dirlist *)GetHead(filelist);tmp;tmp=(struct dirlist *)GetSucc((struct Node *)tmp)) {
	    if (S_ISLNK(tmp->mode)) {
kprintf("getdir(): Found link\n");
		lname=linkname(tmp->name);
		if (lname==NULL)
		  goto out;
		rval=get_file(lname,lname,-1);
		if (rval==TRSF_FAILED) {
		    if (getdir(rdir,ldir,lname,lname)!=TRSF_OK) {
			free(lname);
			goto out;
		    }
		}
		else if (rval!=TRSF_OK) {
		    free(lname);
		    goto out;
		}
		free(lname);
		lname=NULL;
	    }
	}
	kprintf("getdir(): Done with %s\n",rdir);
	if (filelist)
	  free_dirlist(filelist); 
 	if (rdir)
	  free(rdir);
	if (ldir)
	  free(ldir);
	command("CWD %s",remote_parent);
	kprintf("getdir(): Exiting (OK)\n");
	return (TRSF_OK);
     out:
	if (filelist)
	  free_dirlist(filelist);
 	if (rdir)
	  free(rdir);
	if (ldir)
	  free(ldir);
	command("CWD %s",remote_parent);
//	ChangeDir(parent_local_dir);
	kprintf("getdir(): Exiting (FAILED)\n");
	return (TRSF_FAILED);
    }
}
#endif
*/
a678 1
#ifndef NORECGETDIR
d740 1
a740 1
Printf("'%s' '%s'\n",entry->remote_parent,entry->dirname);
d772 5
a776 1
		char *tmpname=calloc(8*FESIZE,1); // change to malloc(strlen(ldir)+strlen(tmp->name)+2);
d793 29
a821 5
		qentry->remote_parent=strdup(rdir);
		qentry->local_parent=strdup(ldir);
		qentry->dirname=strdup(tmp->name);
		qentry->localname=strdup(tmp->name);
		AddHead(&Queue,qentry);
d831 4
d851 1
d861 1
d868 1
a915 1
#endif
@


0.827
log
@Add Current to sitelist added.
More rtLockWindow()'s
Leeching seems to work, but is not finished yet.
@
text
@d216 3
d886 1
a886 1
		char *tmpname=calloc(8*FESIZE,1); /* change to malloc(strlen(ldir)+strlen(tmp->name)+2);
d888 8
a895 8
		kprintf("Getting %s as %s\n",tmp->name,tmpname);
/*		    if (get_file(tmp->name,tmpname,tmp->size)!=TRSF_OK) {
			free(tmpname);
			free(ldir);
			free(rdir);
			rval=TRSF_FAILED;
			goto out;
			}*/
@


0.814
log
@Added default download-dir.
@
text
@d210 1
a210 1
#ifdef RECGETDIR
d218 1
a218 1
#endif
d627 2
a629 2
long __STKNEED=4000;

d737 1
a737 1

d750 1
a750 1
	if (strcmp(parent, "/"))
d805 1
d807 1
d837 1
d839 1
a839 1
    while (entry=RemTail(&Queue)) {
d842 1
a842 1
	printf("Popped '%s' '%s' of the stack\n",entry->remote_parent,entry->dirname);
d851 1
d879 2
a880 2
	printf("LINE: %ld\n",__LINE__);
	PrintQueue(&Queue);
d883 1
a883 1
		char *tmpname=calloc(4*FESIZE,1);
d895 1
a895 1
	PrintQueue(&Queue);
d907 2
a908 2
	printf("LINE: %ld\n",__LINE__);
	PrintQueue(&Queue);
d949 3
a951 3
		    printf("Adding '%s' '%s' '%s' '%s'to queue\n",
			   qentry->remote_parent, qentry->dirname,
			   qentry->local_parent,qentry->localname);
d972 2
a973 2
	printf("LINE: %ld\n",__LINE__);
	PrintQueue(&Queue);
d978 1
a978 1
    while(entry=RemHead(&Queue)) {
@


0.807
log
@Added AmigaGuide on-line help.
@
text
@d98 1
a98 1
    UWORD n1,n2,n3,n4,n5;
a162 1
    char *name;
a163 1
    ULONG omask=0,mask=0;
d166 1
d168 1
a428 1
	static char temp[20],temp2[20];
d443 1
a443 1
			      GTTX_Text,remote?remote:FilePart(node->ln_Name),
d459 1
a459 1
	res=sendrequest("STOR",node->ln_Name,remote?remote:FilePart(node->ln_Name));
d594 1
a594 1
    int		rval, answer;
a595 1
    ULONG mask=0,omask=0;
@


0.774
log
@Now handles filenames up to 128 chars, atleast in DownloadFile().
@
text
@d151 1
a151 1
    WA_IDCMP,IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW|IDCMP_GADGETDOWN|IDCMP_GADGETUP,
d167 1
a167 1

d203 1
d207 1
a221 1
		    static char tmp[4*FESIZE];
a256 1
			  char tmp[FESIZE];
d320 1
a320 1

d322 6
a327 2
	while (Continue) {
	    WaitPort(dl_Win->UserPort);
d329 8
a336 8
	    while (imsg = GT_GetIMsg(dl_Win->UserPort)) {
		int (*func)();
		struct IntuiMessage dl_Msg; 
		ULONG MsgClass;
		UWORD Code;
		MsgClass= imsg->Class;
		Code    = imsg->Code;
		CopyMem(imsg,&dl_Msg,sizeof(dl_Msg));
d338 1
a338 1
		GT_ReplyIMsg(imsg);
d340 29
a368 17
		switch(MsgClass) {
		  case IDCMP_CLOSEWINDOW:
		    Continue=FALSE;
		    break;
		  case IDCMP_REFRESHWINDOW:
		    GT_BeginRefresh(dl_Win);
		    GT_EndRefresh(dl_Win,TRUE);
		    //		Printf("Got refresh\n");
		    break;
		  case IDCMP_GADGETUP:
		  case IDCMP_GADGETDOWN:
		    func = (void *)((struct Gadget *)dl_Msg.IAddress)->UserData;
		    if (func)
		      func();
		    break;
		  default:
		    break;
d371 3
a374 3
	StripIntuiMessages(dl_Win->UserPort,dl_Win);
	CloseWindow(dl_Win);
	FreeGadgets(dl_glist);
d389 1
d425 1
d473 2
d476 15
a490 1
	WaitPort(dl_Win->UserPort);
d492 28
a519 27
	while (imsg = GT_GetIMsg(dl_Win->UserPort)) {
	    int (*func)();
	    struct IntuiMessage dl_Msg; 
	    ULONG MsgClass;
	    UWORD Code;
	    MsgClass= imsg->Class;
	    Code    = imsg->Code;
	    CopyMem(imsg,&dl_Msg,sizeof(dl_Msg));

	    GT_ReplyIMsg(imsg);

	    switch(MsgClass) {
	      case IDCMP_CLOSEWINDOW:
		Continue=FALSE;
		break;
	      case IDCMP_REFRESHWINDOW:
		GT_BeginRefresh(dl_Win);
		GT_EndRefresh(dl_Win,TRUE);
		break;
	      case IDCMP_GADGETUP:
	      case IDCMP_GADGETDOWN:
		func = (void *)((struct Gadget *)dl_Msg.IAddress)->UserData;
		if (func)
		  func();
		break;
	      default:
		break;
d674 1
a674 1
		char *tmpname=calloc(FESIZE,1);
d881 1
a881 1
		char *tmpname=calloc(FESIZE,1);
@


0.710
log
@Transfer Window now looks good on both V39 and V40.
@
text
@a142 1
/*    WA_AutoAdjust,FALSE,*/
d220 1
a220 1
		    char tmp[FESIZE];
a242 1
//		Printf("Getting file: %s as %s (localname='%s')\n",curr->name,localfile,localname?localname:"");
a278 1
//		      Printf("Getting link %s as %s\n",curr->name,localfile);
a300 1
//		Printf("%ld\n",curr->dl_Node.ln_Type);
a441 2
	if (DEBUG)
	  Printf("Calling sendreq()\n");
a442 2
	if (DEBUG)
	  Printf("Done.\n");
d531 1
a531 2
    if (DEBUG)
      Printf("stackusage=%ld\n",stackused());
a538 2
	if (DEBUG)
	  Printf("stackusage=%ld\n",stackused());
a546 2
	if (DEBUG)
	  Printf("stackusage=%ld\n",stackused());
@


0.700
log
@Fixed bug in initconn(). Now works with mlink!!!
CPS is now cleared after each upload.
@
text
@d11 1
d63 20
a169 1

d194 1
a194 1
	if (!Layout(&gad,dl_Win,&dl_NewGadgets[0],&dl_ngtags[0],&dl_ngtypes[0],&dl_Gadgets[0],NumGadgets_dl)) {
d402 1
a402 1
	if (!Layout(&gad,dl_Win,&dl_NewGadgets[0],&dl_ngtags[0],&dl_ngtypes[0],&dl_Gadgets[0],NumGadgets_dl)) {
a434 2
			      GTNM_Clipped,TRUE,
			      GTNM_Justification,GTJ_RIGHT,
a438 2
			      GTNM_Clipped,TRUE,
			      GTNM_Justification,GTJ_RIGHT,
a442 2
			      GTNM_Clipped,TRUE,
			      GTNM_Justification,GTJ_RIGHT,
a512 2
		      GTNM_Clipped,TRUE,
		      GTNM_Justification,GTJ_RIGHT,
a516 2
			  GTNM_Clipped,TRUE,
			  GTNM_Justification,GTJ_RIGHT,
d585 2
a586 2
			  GTNM_Clipped,TRUE,
			  GTNM_Justification,GTJ_RIGHT,
d590 2
a591 2
			  GTNM_Clipped,TRUE,
			  GTNM_Justification,GTJ_RIGHT,
d595 2
a596 2
			  GTNM_Clipped,TRUE,
			  GTNM_Justification,GTJ_RIGHT,
@


0.692
log
@Release version.
@
text
@d423 1
a423 1
			      GTNM_Number,size,
d429 1
a429 1
			      GTNM_Number,NULL,
@


0.685
log
@Links were viewed twice.
Workaround for V39 GTNM_Number/Justification bug.
@
text
@d420 6
@


0.671
log
@"View" on links downloaded it twice.
@
text
@d44 4
a47 4
    GTTX_Border,TRUE,
    GTTX_Text, NULL,
    GTTX_Clipped,TRUE,
    GTTX_Justification,GTJ_RIGHT,
d50 3
a52 3
    GTTX_Border,TRUE,
    GTTX_Clipped,TRUE,
    GTTX_Justification,GTJ_RIGHT,
d55 3
a57 3
    GTTX_Border,TRUE,
    GTTX_Clipped,TRUE,
    GTTX_Justification,GTJ_RIGHT,
d65 3
a67 3
    TEXT_KIND,
    TEXT_KIND,
    TEXT_KIND,
d103 1
a103 1
    dl_NewGadgets[GD_dl_Size].ng_Width   = TextLength(PropRPort,www,10);
d108 1
a108 1
    dl_NewGadgets[GD_dl_CPS].ng_Width   = TextLength(PropRPort,www,10);
d113 1
a113 1
    dl_NewGadgets[GD_dl_DataTransferred].ng_Width   = TextLength(PropRPort,www,10);
d395 1
a395 1
	char temp[20];
d413 12
a424 13
	    {
	
		sprintf(temp,"%8ld",size);
		GT_SetGadgetAttrs(dl_Gadgets[GD_dl_Size],dl_Win,NULL,
				  GTTX_Text,temp,
				  GTTX_CopyText,TRUE,
				  TAG_END);
		sprintf(temp,"%8ld",0);
		GT_SetGadgetAttrs(dl_Gadgets[GD_dl_DataTransferred],dl_Win,NULL,
				  GTTX_Text,temp,
				  GTTX_CopyText,TRUE,
				  TAG_END);
	    }
a488 2
    static char temp1[20];
    static char temp2[20];
a491 1
    sprintf(temp1,"%ld",bytes);
d493 3
a495 1
		      GTTX_Text,temp1,
a497 1
	sprintf(temp2,"%ld",(bytes-restart_point)/timee);
d499 3
a501 1
			  GTTX_Text,temp2,
a557 1
    char temp[20],temp2[10];
d560 1
a567 1
	sprintf(temp,"%8ld",size);
d569 3
a571 1
			  GTTX_Text,temp,
a572 1
	sprintf(temp2,"%8ld",0);
d574 3
a576 1
			  GTTX_Text,temp2,
d579 3
a581 1
			  GTTX_Text,NULL,
@


0.667
log
@Datatransferred was updated one time too much.
@
text
@d164 1
a164 1
	  return(1);
d171 1
a171 1
	    return(2);
d178 1
a178 1
	    return(3);
d302 1
a302 1
	return(0);
d345 1
a345 1
    return(10);
d374 1
a374 1
	  return(1);
d380 1
a380 1
	    return(2);
d386 1
a386 1
	    return(3);
d481 5
a485 2

    return(0);
@


0.656
log
@De-selection after downloading multiple files now work again.
Aborting now results in aborting the entire transfer.
@
text
@d427 2
a428 1

d430 2
d492 1
a492 1
    sprintf(temp1,"%8ld",bytes);
d497 1
a497 1
	sprintf(temp2,"%8ld",(bytes-restart_point)/timee);
@


0.651
log
@Abort-gadget was ghosted after the first transfer, fixed.
Upload loop would continue even if there was an error.
@
text
@d228 2
d276 2
d284 1
a284 1
		Printf("%ld\n",curr->dl_Node.ln_Type);
@


0.623
log
@Added menuitem TransferMode->Binary/ASCII
@
text
@d280 1
d425 7
a431 5
	if (mainWin) {
	    GT_SetGadgetAttrs(dl_Gadgets[GD_dl_AbortGad],dl_Win,NULL,
			      GA_Disabled,TRUE,
			      TAG_END);
	}
@


0.588
log
@The GUI now handles proportional fonts. Only the main listview is fixed font.
@
text
@d46 2
d51 2
d56 2
a119 3
#ifndef AS225
#include <amitcp/socketbasetags.h>
#endif
d148 1
a148 1
    settype(binary?BINARY:ASCII);
d189 1
a189 1
#ifndef NORECGETDIR
d262 1
a262 1
#ifndef NORECGETDIR
a349 1
    ULONG mask,omask=0;
d353 1
a353 8
#ifndef AS225
    SocketBaseTags(SBTM_GETREF(SBTC_BREAKMASK),&omask,TAG_END);
#endif

    if (binary)
      settype(BINARY);
    else
      settype(ASCII);
a422 6
	if (mainWin) {
	    mask = omask | 1<<dl_Win->UserPort->mp_SigBit;
#ifndef AS225
	    SocketBaseTags(SBTM_SETREF(SBTC_BREAKMASK),&mask,TAG_END);
#endif
	}
a423 3
#ifndef AS225
	SocketBaseTags(SBTM_SETREF(SBTC_BREAKMASK),&omask,TAG_END);
#endif
d475 1
a475 1
void UpdateDLGads(long bytes,time_t timee)
d487 1
a487 1
	sprintf(temp2,"%8ld",bytes/timee);
d501 1
d513 25
a537 8
    ret=(BOOL)rtEZRequest(GetAmiFTPString(TW_FileExists),GetAmiFTPString(TW_Overwrite),NULL,(struct TagItem *)tags,lfile,fib.fib_Size,size);
    if (DEBUG)
      Printf("stackusage=%ld\n",stackused());
    if (ret==1)
      return (FALSE);
    if (ret==2) {
	*restartpoint=fib.fib_Size;
	return (FALSE);
a566 5
#ifndef AS225
	SocketBaseTags(SBTM_GETREF(SBTC_BREAKMASK),&omask,TAG_END);
	mask = omask | 1<<dl_Win->UserPort->mp_SigBit;
	SocketBaseTags(SBTM_SETREF(SBTC_BREAKMASK),&mask,TAG_END);
#endif
d572 1
a572 4
#ifndef AS225
    if (dl_Win)
      SocketBaseTags(SBTM_SETREF(SBTC_BREAKMASK),&omask,TAG_END);
#endif
@


0.563
log
@AmiFTP now works with AS225r2 and hopefully with mlink.
Fixes concerning the locale.
@
text
@d74 3
a76 3
    n1 = TextLength(RPort,www,40);
    n2 = GadgetTextLength(RPort,dl_NewGadgets[GD_dl_RemoteFile]);
    n3 = GadgetTextLength(RPort,dl_NewGadgets[GD_dl_LocalFile]);
d78 1
a78 1
    n3 = GadgetTextLength(RPort,dl_NewGadgets[GD_dl_DataTransferred]);
d81 2
a82 2
    *minwidth = n1+FHigh+2*INTERWIDTH+n2;
    *minheight = 6*FHigh+13*INTERHEIGHT+2*INTERHEIGHT;
d84 1
a84 1
    dl_NewGadgets[GD_dl_RemoteFile].ng_LeftEdge= n2+INTERWIDTH+FHigh;
d86 1
a86 1
    dl_NewGadgets[GD_dl_RemoteFile].ng_Height  = FHigh+2*INTERHEIGHT;
d90 1
a90 1
    dl_NewGadgets[GD_dl_LocalFile].ng_TopEdge = dl_NewGadgets[GD_dl_RemoteFile].ng_TopEdge+FHigh+2*INTERHEIGHT;
d95 1
a95 1
    dl_NewGadgets[GD_dl_Size].ng_TopEdge = dl_NewGadgets[GD_dl_LocalFile].ng_TopEdge+FHigh+2*INTERHEIGHT;
d97 1
a97 1
    dl_NewGadgets[GD_dl_Size].ng_Width   = TextLength(RPort,www,10);
d100 1
a100 1
    dl_NewGadgets[GD_dl_CPS].ng_TopEdge = dl_NewGadgets[GD_dl_Size].ng_TopEdge+FHigh+2*INTERHEIGHT;
d102 1
a102 1
    dl_NewGadgets[GD_dl_CPS].ng_Width   = TextLength(RPort,www,10);
d105 1
a105 1
    dl_NewGadgets[GD_dl_DataTransferred].ng_TopEdge = dl_NewGadgets[GD_dl_CPS].ng_TopEdge+FHigh+2*INTERHEIGHT;
d107 1
a107 1
    dl_NewGadgets[GD_dl_DataTransferred].ng_Width   = TextLength(RPort,www,10);
d109 1
a109 1
    dl_NewGadgets[GD_dl_AbortGad].ng_Width     = 2*INTERWIDTH+GadgetTextLength(RPort,dl_NewGadgets[GD_dl_AbortGad]);
d112 1
a112 1
    dl_NewGadgets[GD_dl_AbortGad].ng_TopEdge   = dl_NewGadgets[GD_dl_DataTransferred].ng_TopEdge+FHigh+3*INTERHEIGHT;
d119 1
a119 1
    WA_AutoAdjust,FALSE,
d125 2
d150 9
a158 7
	tw_tags[3]=(unsigned long)myScn;
	tw_tags[5]=mainWin->Height>Height?mainWin->TopEdge+(mainWin->Height-Height)/2:mainWin->TopEdge;
	tw_tags[7]=mainWin->Width>Width?mainWin->LeftEdge+(mainWin->Width-Width-myScn->WBorLeft-myScn->WBorRight)/2:mainWin->LeftEdge;
	tw_tags[9]=Width+myScn->WBorLeft+myScn->WBorRight;
	tw_tags[11]=Height;
	tw_tags[13]=(ULONG)GetAmiFTPString(TW_WinTitle);
	tw_tags[17]|=(mainWin->Flags&WFLG_WINDOWACTIVE)?WFLG_ACTIVATE:0;
d163 1
a163 1
	SetFont(dl_Win->RPort,dfont);
d363 9
a371 7
	tw_tags[3]=(unsigned long)myScn;
	tw_tags[5]=mainWin->Height>Height?mainWin->TopEdge+(mainWin->Height-Height)/2:mainWin->TopEdge;
	tw_tags[7]=mainWin->Width>Width?mainWin->LeftEdge+(mainWin->Width-Width-myScn->WBorLeft-myScn->WBorRight)/2:mainWin->LeftEdge;
	tw_tags[9]=Width+myScn->WBorLeft+myScn->WBorRight;
	tw_tags[11]=Height;
	tw_tags[13]=(ULONG)GetAmiFTPString(TW_WinTitle);
	tw_tags[17]|=(mainWin->Flags&WFLG_WINDOWACTIVE)?WFLG_ACTIVATE:0;
d375 1
a375 1
	SetFont(dl_Win->RPort,dfont);
@


0.544
log
@Added gadstrlen() and macro GadgetTextLength() to compute correct strings with _ in labels.
Checks if CTRL-C has been hit before opening window.
@
text
@d505 1
a505 1
    static ULONG tags[]={RTEZ_ReqTitle,(ULONG)"AmiFTP Overwrite",RT_Window,NULL,RT_LockWindow,TRUE,RT_ReqPos,REQPOS_CENTERWIN,TAG_END};
d516 1
d705 1
a705 1
    static ULONG tags[]={RTEZ_ReqTitle,(ULONG)"AmiFTP Request",RT_Window,NULL,RT_LockWindow,TRUE,RT_ReqPos,REQPOS_CENTERWIN,TAG_END};
d710 1
@


0.534
log
@Anonymous flag on per default
@
text
@d75 2
a76 2
    n2 = TextLength(RPort,dl_NewGadgets[GD_dl_RemoteFile].ng_GadgetText,strlen(dl_NewGadgets[GD_dl_RemoteFile].ng_GadgetText));
    n3 = TextLength(RPort,dl_NewGadgets[GD_dl_LocalFile].ng_GadgetText,strlen(dl_NewGadgets[GD_dl_LocalFile].ng_GadgetText));
d78 1
a78 1
    n3 = TextLength(RPort,dl_NewGadgets[GD_dl_DataTransferred].ng_GadgetText,strlen(dl_NewGadgets[GD_dl_DataTransferred].ng_GadgetText));
d109 1
a109 1
    dl_NewGadgets[GD_dl_AbortGad].ng_Width     = 2*INTERWIDTH+TextLength(RPort,dl_NewGadgets[GD_dl_AbortGad].ng_GadgetText,strlen(dl_NewGadgets[GD_dl_AbortGad].ng_GadgetText));
@


0.531
log
@Resume transfer added (when getting files).
Get-dir-tree is broken.
@
text
@d7 1
d10 1
d182 1
d190 1
d255 1
d262 1
d572 1
d681 1
a697 1
	kprintf("make_path(): '%s'\n",tmp);
d733 1
d932 1
@


0.486
log
@Recursive getting of directory trees implemented.
Password/Anonymous-gadget added in SiteConfiguration Window
Layout fixes.
@
text
@d7 2
d181 4
a184 2
		if (result=getdir(CurrentState.CurrentRemoteDir,CurrentState.CurrentDLDir,curr->name,curr->name)) {
		    goto out;
d251 5
a255 3
			  if (result==getdir(CurrentState.CurrentRemoteDir,CurrentState.CurrentDLDir,name,name)!=TRSF_OK) {
			      free(name);
			      goto out;
d434 1
a434 1
    if (res==TRSF_ABORTED)
d497 1
a497 1
BOOL CheckExists(char *lfile,int size)
d499 1
a499 1
    ULONG tags[]={RTEZ_ReqTitle,(ULONG)"AmiFTP Overwrite",RT_Window,NULL,RT_LockWindow,TRUE,RT_ReqPos,REQPOS_CENTERWIN,TAG_END};
d516 7
a522 3
    if (ret)
      return(FALSE);
    return(TRUE);
d530 1
d557 1
a557 1
    if (CheckExists(localname,size))
d559 1
a559 1
    rval = recvrequest("RETR", localname, name, "w");
a564 23
    switch (rval) {
      case 1:
	/* non_fatal error */
	ftperr = index(response_line, ':');
	if (ftperr != NULL) {
	    ftperr++;
	    if (!strncmp(ftperr, "Permission", 10))
	      rval = EPERM;
	    else if (!strncmp(ftperr, "not a plain file", 16))
	      rval = EISDIR;
	    else
	      rval = 0;
	} else
	  rval = 0;
	break;
      case 2:
	rval = EIO;
	break;
      default:
	break;
    }

    return (rval);
d566 1
d576 2
d598 1
d600 1
d602 1
d606 2
a607 1
//	Printf("getdir(): local_parent '%s' localname '%s' ldir '%s'\n",local_parent,localname,ldir);
d610 1
a610 1
		char tmpname[FESIZE];
d612 7
a618 2
		if (get_file(tmp->name,tmpname,tmp->size)!=TRSF_OK)
		  goto out;
d621 1
d624 1
d629 1
d632 1
d651 1
a653 4
	if (filelist)
	  free_dirlist(filelist);
	if (filelist)
	  free_dirlist(filelist);
d659 1
d670 1
d682 2
a683 2
	tmp = (char *)malloc((unsigned int)(strlen(parent) + 1 +
					    strlen(curdir) + 1));
d690 1
d693 230
@


0.388
log
@send/recv-request re-written
Layoutbug in connect-window fixed
@
text
@d63 1
d114 12
a125 10
static ULONG tw_tags[]={WA_AutoAdjust,FALSE,
	                WA_PubScreen,NULL,
			WA_Top,NULL,
			WA_Left,NULL,
			WA_Width,NULL,
			WA_InnerHeight,NULL,
			WA_Title,NULL,
			WA_IDCMP,IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW|IDCMP_GADGETDOWN|IDCMP_GADGETUP,
			WA_Flags,WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH,
			TAG_END};
d127 1
a127 1
int DownloadFile(struct dirlist *curr,char *localname,struct List *flist, int binary, int move)
d137 1
d174 11
a184 6
    if (flist)
    {
	for (curr=(struct dirlist *)GetHead(flist);curr;curr=(struct dirlist *)GetSucc((struct Node *)curr)) {
	    if (curr->dl_Node.ln_Type && ~S_ISLNK(curr->mode)) {
		name=curr->name;
//		strmfp(local_name,localname?localname:CurrentState.CurrentDLDir,name);
d186 2
a187 2
		    char tmp[200];
		    stcgfn(tmp,name);
d193 1
a193 1
			stcgfn(localfile+strlen(localfile),name);
d199 1
a199 1
			    stcgfn(localfile+strlen(localfile),name);
d209 50
a258 55
		if (dl_Win) {
		    GT_SetGadgetAttrs(dl_Gadgets[GD_dl_LocalFile],dl_Win,NULL,
				      GTTX_Text,localfile,
				      GTTX_CopyText,TRUE,
				      TAG_END);
		    GT_SetGadgetAttrs(dl_Gadgets[GD_dl_RemoteFile],dl_Win,NULL,
				      GTTX_Text,name,
				      GTTX_CopyText,TRUE,
				      TAG_END);
		    {
			char temp[20];
			sprintf(temp,"%8ld",curr->size);
			GT_SetGadgetAttrs(dl_Gadgets[GD_dl_Size],dl_Win,NULL,
					  GTTX_Text,temp,
					  GTTX_CopyText,TRUE,
					  TAG_END);
			sprintf(temp,"%8ld",0);
			//	GT_SetGadgetAttrs(dl_Gadgets[GD_dl_CPS],dl_Win,NULL,
						  //			  GTTX_Text,temp,
						  //			  GTTX_CopyText,TRUE,
						  //			  TAG_END);
			GT_SetGadgetAttrs(dl_Gadgets[GD_dl_DataTransferred],dl_Win,NULL,
					  GTTX_Text,temp,
					  GTTX_CopyText,TRUE,
					  TAG_END);
		    }
		    //    RefreshGList(dl_Win->FirstGadget,dl_Win,NULL,-1);
		    //    GT_RefreshWindow(dl_Win,NULL);
		}
		if (CheckExists(localfile,curr->size))
		  continue;
		if (dl_Win) {
#ifndef AS225
		    SocketBaseTags(SBTM_GETREF(SBTC_BREAKMASK),&omask,TAG_END);
		    mask = omask | 1<<dl_Win->UserPort->mp_SigBit;
		    SocketBaseTags(SBTM_SETREF(SBTC_BREAKMASK),&mask,TAG_END);
#endif
		}
		//		if (DEBUG)
//		  kprintf("Calling recvreq()\n");
		aborted=FALSE;
		result=recvrequest("RETR",localfile,name,"w");
#ifndef AS225
		if (dl_Win)
		  SocketBaseTags(SBTM_SETREF(SBTC_BREAKMASK),&omask,TAG_END);
#endif
		curr->dl_Node.ln_Type=0;
		if (aborted || result !=TRSF_OK)
		  break;
		if (dl_Win) {
		    GT_SetGadgetAttrs(mainGadgets[GD_Files_LV],mainWin,NULL,
				      GTLV_Labels,~0,TAG_END);
		    GT_SetGadgetAttrs(mainGadgets[GD_Files_LV],mainWin,NULL,
				      GTLV_Labels,FileList,TAG_END);
		}
a259 36
	}
	if (dl_Win)
	  GT_SetGadgetAttrs(dl_Gadgets[GD_dl_AbortGad],dl_Win,NULL,
			    GA_Disabled,TRUE,
			    TAG_END);
    }
    else {
	/* */
	name=S_ISLNK(curr->mode)?linkname(curr->name):curr->name;
//	strmfp(localname,CurrentState.CurrentDLDir,name);
	if (!localname) {
	    char tmp[200];
	    stcgfn(tmp,name);
	    strmfp(localfile,CurrentState.CurrentDLDir,tmp);
	}
	else {
	    if (localname[strlen(localname)-1]=='/'||localname[strlen(localname)-1]==':') {
		strcpy(localfile,localname);
		stcgfn(localfile+strlen(localfile),name);
	    }
	    else {
		if (getfa(localname)==1) {
		    strcpy(localfile,localname);
		    strcat(localfile,"/");
		    stcgfn(localfile+strlen(localfile),name);
		}
		else {
		    if (index(localname,'/')||index(localname,':')) {
			strcpy(localfile,localname);
		    }
		    else
		      strmfp(localfile,CurrentState.CurrentDLDir,localname);
		}
	    }
	}
	if (CheckExists(localfile,curr->size)) {
d261 4
a264 3
		StripIntuiMessages(dl_Win->UserPort,dl_Win);
		CloseWindow(dl_Win);
		FreeGadgets(dl_glist);
a265 2
	    dl_Win=0;
	    return(0);
d267 3
a269 38
	if (dl_Win) {
	    GT_SetGadgetAttrs(dl_Gadgets[GD_dl_LocalFile],dl_Win,NULL,
			      GTTX_Text,localfile,
			      GTTX_CopyText,TRUE,
			      TAG_END);
	    GT_SetGadgetAttrs(dl_Gadgets[GD_dl_RemoteFile],dl_Win,NULL,
			      GTTX_Text,name,
			      GTTX_CopyText,TRUE,
			      TAG_END);
	    {
		char temp[20];
		sprintf(temp,"%8ld",curr->size);
		GT_SetGadgetAttrs(dl_Gadgets[GD_dl_Size],dl_Win,NULL,
				  GTTX_Text,temp,
				  GTTX_CopyText,TRUE,
				  TAG_END);
		sprintf(temp,"%8ld",0);
		//	GT_SetGadgetAttrs(dl_Gadgets[GD_dl_CPS],dl_Win,NULL,
					  //			  GTTX_Text,temp,
					  //			  GTTX_CopyText,TRUE,
					  //			  TAG_END);
		GT_SetGadgetAttrs(dl_Gadgets[GD_dl_DataTransferred],dl_Win,NULL,
				  GTTX_Text,temp,
				  GTTX_CopyText,TRUE,
				  TAG_END);
	    }
	
	    //    RefreshGList(dl_Win->FirstGadget,dl_Win,NULL,-1);
	    //    GT_RefreshWindow(dl_Win,NULL);
#ifndef AS225
	    SocketBaseTags(SBTM_GETREF(SBTC_BREAKMASK),&omask,TAG_END);
	    mask = omask | 1<<dl_Win->UserPort->mp_SigBit;
	    SocketBaseTags(SBTM_SETREF(SBTC_BREAKMASK),&mask,TAG_END);
#endif
	}
//	if (DEBUG)
//	  kprintf("Calling recvreq()\n");
	aborted=FALSE;
a270 17
	result=recvrequest("RETR",localfile,name,"w");
	if (dl_Win) {
#ifndef AS225
	    SocketBaseTags(SBTM_SETREF(SBTC_BREAKMASK),&omask,TAG_END);
#endif
	    GT_SetGadgetAttrs(dl_Gadgets[GD_dl_AbortGad],dl_Win,NULL,
			      GA_Disabled,TRUE,
			      TAG_END);
	}
	    curr->dl_Node.ln_Type=0;
	if (dl_Win) {
	    GT_SetGadgetAttrs(mainGadgets[GD_Files_LV],mainWin,NULL,
			      GTLV_Labels,~0,TAG_END);
	    GT_SetGadgetAttrs(mainGadgets[GD_Files_LV],mainWin,NULL,
			      GTLV_Labels,FileList,TAG_END);
	}
    }
d280 1
d332 1
a332 1
    int aborted=0;
d380 1
d409 1
a409 1
	aborted=FALSE;
d416 1
a416 1
	sendrequest("STOR",node->ln_Name,remote?remote:FilePart(node->ln_Name));
d428 1
a428 1
    if (!aborted)
d473 2
a474 2
    char temp[20];

d478 1
a478 1
    sprintf(temp,"%8ld",bytes);
d480 1
a480 2
		      GTTX_CopyText,TRUE,
		      GTTX_Text,temp,
d483 1
a483 1
	sprintf(temp,"%8ld",bytes/timee);
d485 1
a485 2
			  GTTX_CopyText,TRUE,
			  GTTX_Text,temp,
d513 176
@


0.371
log
@Localized source.
@
text
@d121 1
a121 1
			WA_Flags,WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_ACTIVATE,
d135 2
a136 4
    if (binary)
      settype(BINARY);
    else
      settype(ASCII);
d146 1
a146 1

d241 1
a241 1
		result=recvrequest("RETR",localfile,name,"w",curr->size,&aborted);
d339 1
a339 1
	result=recvrequest("RETR",localfile,name,"w",curr->size,&aborted);
d431 8
a438 12
	dl_Win = OpenWindowTags(NULL,
				WA_AutoAdjust,FALSE,
				WA_PubScreen,myScn,
				WA_Top,mainWin->Height>Height?mainWin->TopEdge+(mainWin->Height-Height)/2:mainWin->TopEdge,
				WA_Left,mainWin->Width>Width?mainWin->LeftEdge+(mainWin->Width-Width-myScn->WBorLeft-myScn->WBorRight)/2:mainWin->LeftEdge,
				WA_Width,Width+myScn->WBorLeft+myScn->WBorRight,
				WA_InnerHeight,Height,
				WA_Title,"AmiFTP Transfer window",
				WA_IDCMP,IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW|IDCMP_GADGETDOWN|IDCMP_GADGETUP,
				WA_Flags,WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_ACTIVATE,
				TAG_DONE
				);
d499 1
a499 1
	sendrequest("STOR",node->ln_Name,remote?remote:FilePart(node->ln_Name),size,&aborted);
@


0.345
log
@Upload via ARexx now works
Entering a remotedir in stringgadget results in re-reading it
@
text
@d13 17
a29 6
    {0,0,0,0,"Remote file",NULL,0,PLACETEXT_LEFT,NULL,NULL},
    {0,0,0,0,"Local file",NULL,1,PLACETEXT_LEFT,NULL,NULL},
    {0,0,0,0,"Size",NULL,2,PLACETEXT_LEFT,NULL,NULL},
    {0,0,0,0,"cps",NULL,3,PLACETEXT_LEFT,NULL,NULL},
    {0,0,0,0,"Data transferred",NULL,4,PLACETEXT_LEFT,NULL,NULL},
    {0,0,0,0,"Abort transfer",NULL,5,PLACETEXT_IN,NULL,NULL}
d113 11
a132 10
    ULONG tags[]={WA_AutoAdjust,FALSE,
		    WA_PubScreen,NULL,
		    WA_Top,NULL,
		    WA_Left,NULL,
		    WA_Width,NULL,
		    WA_InnerHeight,NULL,
		    WA_Title,(ULONG)(char *)"AmiFTP Transfer window",
		    WA_IDCMP,IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW|IDCMP_GADGETDOWN|IDCMP_GADGETUP,
		    WA_Flags,WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_ACTIVATE,
		    TAG_END};
d134 1
a134 3
    //    stackch();
    //  stackch();
    //    stackch();
d142 8
a149 25
	//    stackch();
	//    Printf("Stackusage: %ld\n",stackused());
	//    {char bla[100];Printf("Stackusage: %ld\n",stackused(),bla);}
	tags[3]=(unsigned long)myScn;
	tags[5]=mainWin->Height>Height?mainWin->TopEdge+(mainWin->Height-Height)/2:mainWin->TopEdge;
	tags[7]=mainWin->Width>Width?mainWin->LeftEdge+(mainWin->Width-Width-myScn->WBorLeft-myScn->WBorRight)/2:mainWin->LeftEdge;
	tags[9]=Width+myScn->WBorLeft+myScn->WBorRight;
	tags[11]=Height;
	dl_Win=OpenWindowTagList(NULL,(struct TagItem *)tags);
	/*
	  dl_Win = OpenWindowTags(NULL,
	  WA_AutoAdjust,FALSE,
	  WA_PubScreen,myScn,
	  WA_Top,mainWin->TopEdge,
	  WA_Left,mainWin->LeftEdge,
	  WA_Width,Width+myScn->WBorLeft+myScn->WBorRight,
	  WA_InnerHeight,Height,
	  WA_Title,"AmiFTP Transfer window",
	  WA_IDCMP,IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW|IDCMP_GADGETDOWN|IDCMP_GADGETUP,
	  WA_Flags,WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_ACTIVATE,
	  TAG_DONE
	  );*/
	//    stackch();
	//    Printf("bla bla bla bla bla bla bla\n");
	//    stackch();
d152 1
d160 1
a160 1
	/*    if (!Layout_dl(&gad,dl_Win)) {*/
d167 1
a167 1
	//    stackch();
a210 1
		    //    stackch();
a227 2
		    //    stackch();
		    
a247 1
		//    stackch();
a310 1
	    //    stackch();
a328 2
	    //    stackch();
	    
a348 1
	//    stackch();
d358 1
a358 1
    if (result==TRSF_OK) {
a463 3



d588 1
a588 1
//    stackch();
a595 1
//    stackch();
d598 1
a598 1
    ret=(BOOL)rtEZRequest("File '%s' already exists\nOld filesize is: %ld bytes (%ld bytes)\n","Overwrite|Cancel transfer",NULL,(struct TagItem *)tags,lfile,fib.fib_Size,size);
a600 1
//    stackch();
@


0.336
log
@Added AS225-support (via #ifdefs)
Using GetSysTime() instead of time() in transferroutines
@
text
@d129 1
d443 1
d492 3
a494 13
	GT_SetGadgetAttrs(dl_Gadgets[GD_dl_LocalFile],dl_Win,NULL,
			  GTTX_Text,node->ln_Name,
			  GTTX_CopyText,TRUE,
			  TAG_END);
	GT_SetGadgetAttrs(dl_Gadgets[GD_dl_RemoteFile],dl_Win,NULL,
			  GTTX_Text,FilePart(node->ln_Name),
			  GTTX_CopyText,TRUE,
			  TAG_END);
	{
	
	    sprintf(temp,"%8ld",size);
	    GT_SetGadgetAttrs(dl_Gadgets[GD_dl_Size],dl_Win,NULL,
			      GTTX_Text,temp,
d497 2
a498 3
	    sprintf(temp,"%8ld",0);
	    GT_SetGadgetAttrs(dl_Gadgets[GD_dl_DataTransferred],dl_Win,NULL,
			      GTTX_Text,temp,
d501 13
a514 1

d516 2
a517 1
	mask = omask | 1<<dl_Win->UserPort->mp_SigBit;
d519 1
a519 1
	SocketBaseTags(SBTM_SETREF(SBTC_BREAKMASK),&mask,TAG_END);
d521 2
a522 1
	sendrequest("STOR",node->ln_Name,FilePart(node->ln_Name),size,&aborted);
d526 5
a530 3
	GT_SetGadgetAttrs(dl_Gadgets[GD_dl_AbortGad],dl_Win,NULL,
			  GA_Disabled,TRUE,
			  TAG_END);
d532 2
d572 1
@


0.326
log
@Links are now parsed to linkname and (link)
Upload via ARexx should be finished now
@
text
@d98 1
a98 1

d100 1
d242 1
d246 1
d252 1
d255 1
d343 1
d347 1
d355 1
d357 1
d434 1
d436 1
d514 1
d516 1
d518 1
d520 1
@


0.322
log
@Dir-cache added.
Delete added.
@
text
@d415 1
a415 1
int UploadFile(struct List *transferlist)
d427 4
a430 1
    settype(BINARY);
@


0.312
log
@UploadFile() now takes a filelist as argument.
@
text
@d101 1
a101 1
int DownloadFile(struct dirlist *curr,char *localname,struct List *flist, int binary)
@


0.305
log
@Added some casts to avoid compiler warnings
@
text
@d414 2
a415 1
int UploadFile()
a420 3
    char filename[300];
    char *name,*dir;
    long size;
d423 1
d426 18
a443 9
    {
	struct FileRequester *FileRequester;
	ULONG tags[]={ASL_Window,NULL,ASLFR_PrivateIDCMP,TRUE,ASLFR_SleepWindow,TRUE,ASLFR_InitialDrawer,NULL,ASLFR_RejectIcons,TRUE,ASLFR_TitleText,NULL,ASLFR_DoMultiSelect,TRUE,TAG_END};
	tags[1]=(unsigned long)mainWin;
	tags[7]=(unsigned long)CurrentState.CurrentDLDir;
	tags[11]=(unsigned long)"Select file(s) to upload";
	filename[0]='\0';
	FileRequester=AllocAslRequest(ASL_FileRequest,NULL);
	if (!FileRequester)
d445 6
a450 4
	if (AslRequest(FileRequester,(struct TagItem *)tags)) {
	    strmfp(filename,FileRequester->fr_Drawer,FileRequester->fr_File);
	    name=strdup(FileRequester->fr_File);
	    dir=strdup(FileRequester->fr_Drawer);
d452 5
a456 3
	else {
	    FreeAslRequest(FileRequester);
	    return(1);
d458 7
a464 1
	FreeAslRequest(FileRequester);
d466 4
a469 4
    if (filename[0]==0)
      return(1);
    {
	BPTR lock=Lock(filename,SHARED_LOCK);
d476 2
a477 56
	else
	  return(1);
    }
    settype(BINARY);

    ComputeSize_dl(&Width,&Height);
    dl_Win = OpenWindowTags(NULL,
			    WA_AutoAdjust,FALSE,
			    WA_PubScreen,myScn,
			    WA_Top,mainWin->Height>Height?mainWin->TopEdge+(mainWin->Height-Height)/2:mainWin->TopEdge,
			    WA_Left,mainWin->Width>Width?mainWin->LeftEdge+(mainWin->Width-Width-myScn->WBorLeft-myScn->WBorRight)/2:mainWin->LeftEdge,
			    WA_Width,Width+myScn->WBorLeft+myScn->WBorRight,
			    WA_InnerHeight,Height,
			    WA_Title,"AmiFTP Transfer window",
			    WA_IDCMP,IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW|IDCMP_GADGETDOWN|IDCMP_GADGETUP,
			    WA_Flags,WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_ACTIVATE,
			    TAG_DONE
			    );
    if (!dl_Win)
      return(1);
    SetFont(dl_Win->RPort,dfont);
    gad = CreateContext(&dl_glist);
    if (!gad) {
	StripIntuiMessages(dl_Win->UserPort,dl_Win);
	CloseWindow(dl_Win);
	free(name);
	free(dir);
	return(2);
    }
    if (!Layout(&gad,dl_Win,&dl_NewGadgets[0],&dl_ngtags[0],&dl_ngtypes[0],&dl_Gadgets[0],NumGadgets_dl)) {
	StripIntuiMessages(dl_Win->UserPort,dl_Win);
	CloseWindow(dl_Win);
	FreeGadgets(dl_glist);
	free(dir);
	free(name);
	return(3);
    }

    AddGList(dl_Win,dl_glist,~0,-1,NULL);
    RefreshGList(dl_Win->FirstGadget,dl_Win,NULL,-1);
    GT_RefreshWindow(dl_Win,NULL);

    GT_SetGadgetAttrs(dl_Gadgets[GD_dl_LocalFile],dl_Win,NULL,
		      GTTX_Text,name,
		      GTTX_CopyText,TRUE,
		      TAG_END);
    GT_SetGadgetAttrs(dl_Gadgets[GD_dl_RemoteFile],dl_Win,NULL,
		      GTTX_Text,name,
		      GTTX_CopyText,TRUE,
		      TAG_END);
    {
	char temp[20];
	
	sprintf(temp,"%8ld",size);
	GT_SetGadgetAttrs(dl_Gadgets[GD_dl_Size],dl_Win,NULL,
			  GTTX_Text,temp,
d480 2
a481 7
	sprintf(temp,"%8ld",0);
//	GT_SetGadgetAttrs(dl_Gadgets[GD_dl_CPS],dl_Win,NULL,
//			  GTTX_Text,temp,
//			  GTTX_CopyText,TRUE,
//			  TAG_END);
	GT_SetGadgetAttrs(dl_Gadgets[GD_dl_DataTransferred],dl_Win,NULL,
			  GTTX_Text,temp,
d484 22
a506 12


//    RefreshGList(dl_Win->FirstGadget,dl_Win,NULL,-1);
//    GT_RefreshWindow(dl_Win,NULL);
    aborted=FALSE;
    mask = omask | 1<<dl_Win->UserPort->mp_SigBit;
    SocketBaseTags(SBTM_SETREF(SBTC_BREAKMASK),&mask,TAG_END);
    sendrequest("STOR",filename,name,size,&aborted);
    SocketBaseTags(SBTM_SETREF(SBTC_BREAKMASK),&omask,TAG_END);
    GT_SetGadgetAttrs(dl_Gadgets[GD_dl_AbortGad],dl_Win,NULL,
		      GA_Disabled,TRUE,
		      TAG_END);
d545 1
@


0.284
log
@First RCS version.
@
text
@d116 1
a116 1
		    WA_Title,"AmiFTP Transfer window",
d133 1
a133 1
	tags[3]=myScn;
d138 1
a138 1
	dl_Win=OpenWindowTagList(NULL,tags);
d178 1
a178 1
	for (curr=GetHead(flist);curr;curr=GetSucc(curr)) {
d430 3
a432 3
	tags[1]=mainWin;
	tags[7]=CurrentState.CurrentDLDir;
	tags[11]="Select file(s) to upload";
d437 1
a437 1
	if (AslRequest(FileRequester,tags)) {
@
