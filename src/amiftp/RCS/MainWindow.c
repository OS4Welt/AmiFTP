head	1.795;
access;
symbols;
locks
	lilja:1.795
	lilja:0.647; strict;
comment	@ * @;


1.795
date	96.09.28.13.32.58;	author lilja;	state Exp;
branches;
next	1.736;

1.736
date	96.08.17.18.17.57;	author lilja;	state Exp;
branches;
next	1.730;

1.730
date	96.08.02.21.57.32;	author lilja;	state Exp;
branches;
next	1.713;

1.713
date	96.07.25.22.53.54;	author lilja;	state Exp;
branches;
next	1.710;

1.710
date	96.07.25.00.21.30;	author lilja;	state Exp;
branches;
next	1.692;

1.692
date	96.07.20.00.28.38;	author lilja;	state Exp;
branches;
next	1.630;

1.630
date	96.07.07.20.10.48;	author lilja;	state Exp;
branches;
next	1.625;

1.625
date	96.07.04.17.50.58;	author lilja;	state Exp;
branches;
next	1.614;

1.614
date	96.07.01.21.01.37;	author lilja;	state Exp;
branches;
next	1.607;

1.607
date	96.06.30.12.33.45;	author lilja;	state Exp;
branches;
next	1.595;

1.595
date	96.06.18.23.19.14;	author lilja;	state Exp;
branches;
next	1.587;

1.587
date	96.06.14.13.08.59;	author lilja;	state Exp;
branches;
next	1.585;

1.585
date	96.06.13.00.03.21;	author lilja;	state Exp;
branches;
next	1.541;

1.541
date	96.06.04.21.43.36;	author lilja;	state Exp;
branches;
next	1.531;

1.531
date	96.05.28.00.17.52;	author lilja;	state Exp;
branches;
next	1.430;

1.430
date	96.04.14.13.21.26;	author lilja;	state Exp;
branches;
next	1.401;

1.401
date	96.03.28.13.52.44;	author lilja;	state Exp;
branches;
next	1.265;

1.265
date	96.03.08.18.01.38;	author lilja;	state Exp;
branches;
next	1.200;

1.200
date	96.02.20.00.19.28;	author lilja;	state Exp;
branches;
next	1.173;

1.173
date	96.02.14.19.06.27;	author lilja;	state Exp;
branches;
next	1.150;

1.150
date	96.02.11.16.38.55;	author lilja;	state Exp;
branches;
next	1.124;

1.124
date	96.02.10.15.46.32;	author lilja;	state Exp;
branches;
next	0.1343;

0.1343
date	96.01.20.17.34.39;	author lilja;	state Exp;
branches;
next	0.1300;

0.1300
date	95.12.08.20.24.52;	author lilja;	state Exp;
branches;
next	0.857;

0.857
date	95.10.24.18.41.14;	author lilja;	state Exp;
branches;
next	0.827;

0.827
date	95.10.23.21.01.35;	author lilja;	state Exp;
branches;
next	0.814;

0.814
date	95.10.15.15.22.12;	author lilja;	state Exp;
branches;
next	0.807;

0.807
date	95.10.13.12.51.19;	author lilja;	state Exp;
branches;
next	0.774;

0.774
date	95.10.07.00.18.25;	author lilja;	state Exp;
branches;
next	0.765;

0.765
date	95.10.01.17.57.28;	author lilja;	state Exp;
branches;
next	0.753;

0.753
date	95.09.30.13.35.40;	author lilja;	state Exp;
branches;
next	0.728;

0.728
date	95.09.30.10.27.47;	author lilja;	state Exp;
branches;
next	0.671;

0.671
date	95.09.20.10.15.33;	author lilja;	state Exp;
branches;
next	0.647;

0.647
date	95.09.16.21.18.38;	author lilja;	state Exp;
branches;
next	0.623;

0.623
date	95.09.16.10.54.30;	author lilja;	state Exp;
branches;
next	0.588;

0.588
date	95.09.12.16.24.08;	author lilja;	state Exp;
branches;
next	0.567;

0.567
date	95.09.11.17.15.13;	author lilja;	state Exp;
branches;
next	0.563;

0.563
date	95.09.10.20.59.20;	author lilja;	state Exp;
branches;
next	0.544;

0.544
date	95.09.08.14.11.28;	author lilja;	state Exp;
branches;
next	0.486;

0.486
date	95.08.26.11.48.42;	author lilja;	state Exp;
branches;
next	0.425;

0.425
date	95.07.24.18.19.29;	author lilja;	state Exp;
branches;
next	0.413;

0.413
date	95.07.23.13.03.53;	author lilja;	state Exp;
branches;
next	0.371;

0.371
date	95.06.30.19.18.41;	author lilja;	state Exp;
branches;
next	0.345;

0.345
date	95.06.15.23.29.18;	author lilja;	state Exp;
branches;
next	0.336;

0.336
date	95.06.15.11.53.20;	author lilja;	state Exp;
branches;
next	0.322;

0.322
date	95.06.12.23.14.26;	author lilja;	state Exp;
branches;
next	0.305;

0.305
date	95.06.08.16.45.30;	author lilja;	state Exp;
branches;
next	0.303;

0.303
date	95.06.08.15.30.02;	author lilja;	state Exp;
branches;
next	0.284;

0.284
date	95.06.06.21.42.35;	author lilja;	state Exp;
branches;
next	;


desc
@Mainwindow gui-functions
@


1.795
log
@Stuff.
@
text
@/* RCS Id: $Id: MainWindow.c 1.736 1996/08/17 18:17:57 lilja Exp lilja $
   Locked version: $Revision: 1.736 $
*/

#include "AmiFTP.h"
#include "gui.h"

struct Window *MainWindow;
struct Screen *Screen;
struct DrawInfo *DrawInfo;
struct VisualInfo *VisualInfo;
static struct TextFont *ScreenFont;
static struct TextFont *AmiFTPFont;
static struct TextFont *ListViewFont;
struct TextAttr AmiFTPAttr = {NULL, 0, FS_NORMAL, FPF_PROPORTIONAL};
struct TextAttr ListViewAttr = {NULL, 0, FS_NORMAL, FPF_PROPORTIONAL};
struct TextAttr *AmiFTPAttrF;
struct TextAttr *ListViewAttrF;
struct TextFont *PropFont;
struct TextFont *LBFont;

static ULONG lsel=-1;
static struct Gadget *pagelayout;
extern struct Menu *menu;
extern struct List clist;

int prev_state=-1;

Object *MainWin_Object;
Object *MainWindowLayout;

struct Gadget *MG_List[NumGadgets_main];
extern struct MsgPort *AppPort; /* Move to .h */

static UBYTE sitenamebuffer[100], remotedirbuffer[100], localdirbuffer[100];
struct ColumnInfo columninfo[]={
    {0, NULL, 0},
    {0, NULL, 0},
    {0, NULL, 0},
    {0, NULL, 0},
    {0, NULL, 0},
    {0, NULL, 0},
    {-1, (STRPTR)~0, -1}
};

struct ColumnInfo dummycolumninfo[]={
    {0, NULL, 0},
    {-1, (STRPTR)~0, -1}
};

extern char *wintitle;

static BOOL Upload=FALSE;
struct List DropUploadList;

static void ScrollListbrowser(ULONG direction);
void FreeInfoList(struct List *list);
void CreateInfoList(struct List *list);

ULONG HandleMainWindowIDCMP(const BOOL AllowIconify)
{
    ULONG result,done=FALSE;
    UWORD code=NULL;
    Upload=FALSE;

    while (MainWin_Object &&
	   (result=CA_HandleInput(MainWin_Object,&code))!=WMHI_LASTMSG) {
	switch (result & WMHI_CLASSMASK) {
	  case WMHI_CLOSEWINDOW:
	    done=TRUE;
	    break;
	  case WMHI_GADGETUP:
	    switch (result & WMHI_GADGETMASK) {
	      case MG_ListView: {
		  struct Node *node;
		  ULONG attr;
		  if (FileList) {
		      for (node=GetHead(FileList);node;node=GetSucc(node)) {
			  GetListBrowserNodeAttrs(node,
						  LBNA_Selected, &attr, TAG_DONE);
			  if (attr) break;
		      }
		      if (node) {
			  UpdateMainButtons(MB_FILESELECTED);
		      }
		      else {
			  UpdateMainButtons(MB_NONESELECTED);
		      }
		      if (code!=-1) {
			  ULONG attr=0;
			  ULONG action=0;
			  GetAttrs(MG_List[MG_ListView],
				   LISTBROWSER_NumSelected, &attr,
				   LISTBROWSER_RelEvent, &action,
				   LISTBROWSER_SelectedNode, &node,
				   TAG_DONE);
			  if (attr&&node) {
			      if (action&LBRE_DOUBLECLICK && lsel==code) {
				  struct dirlist *curr=(void *)node->ln_Name;
				  struct List *head;
				  
				  LockWindow(MainWin_Object);
				  if (curr->mode&0x4000) {
				      if (!change_remote_dir(curr->name, 0)) {
					  if (head=LookupCache(CurrentState.CurrentRemoteDir)) {
					      DetachToolList();
					      FileList=head;
					      AttachToolList(TRUE);
					      UpdateMainButtons(MB_NONESELECTED);
					  }
					  else if (head=read_remote_dir()) {
					      DetachToolList();
					      AddCacheEntry(head,CurrentState.CurrentRemoteDir);
					      FileList=head;
					      AttachToolList(TRUE);
					      UpdateMainButtons(MB_NONESELECTED);
					  }
					  else
					    ShowErrorReq(Str_ErrorReadingDir);
				      }
				      else {
					  RemoteCDFailed();
				      }
				  }
				  else if (S_ISLNK(curr->mode)) {
				      char *name;
				      struct List *head;
				      name = linkname(curr->name);
				      
				      if (name) {
					  if (change_remote_dir(name,0)==ENOTDIR) {
					      DownloadFile(FileList,NULL,TransferMode,0);
					  }
					  else {
					      if (head=LookupCache(CurrentState.CurrentRemoteDir)) {
						  DetachToolList();
						  FileList=head;
						  AttachToolList(TRUE);
						  UpdateMainButtons(MB_NONESELECTED);
					      }
					      else if (head=read_remote_dir()) {
						  DetachToolList();
						  AddCacheEntry(head,CurrentState.CurrentRemoteDir);
						  FileList=head;
						  AttachToolList(TRUE);
						  UpdateMainButtons(MB_NONESELECTED);
					      }
					      else
						ShowErrorReq(GetAmiFTPString(Str_ErrorReadingDir));
					  }
					  free(name);
				      }
				  }
				  else {
				      DownloadFile(FileList, NULL, TransferMode, 0);
				  }
				  
				  UnlockWindow(MainWin_Object);
			      }
			  }
			  lsel=code;
		      }
		  }
	      }
		break;
	      case MG_CacheList:
		{
		    struct Node *node;
		    struct List *head;
		    int i;
		    char *dir;

		    for (i=0, node=GetHead(&clist); node; node=GetSucc(node), i++)
		      if (code==i) break;
		    GetChooserNodeAttrs(node, CNA_Text, &dir, TAG_DONE);
		    if (!change_remote_dir(dir, 0)) {
			if (head=LookupCache(CurrentState.CurrentRemoteDir)) {
			    DetachToolList();
			    FileList=head;
			    AttachToolList(TRUE);
			    UpdateMainButtons(MB_NONESELECTED);
			}
		    }
		    else {
			RemoteCDFailed();
		    }
		}
		break;
	      case MG_SpeedBar:
		if (!HandleSpeedBar(code))
		  done=TRUE;
		break;
	      case MG_Get:
	      case MG_Get2:
		Get_clicked();
		break;
	      case MG_Put:
	      case MG_Put2:
		Put_clicked();
		break;
	      case MG_View:
	      case MG_View2:
		View_clicked(FALSE);
		break;
	      case MG_Parent:
		Parent_clicked();
		break;
	      case MG_Readme:
		View_clicked(TRUE);
		break;
	      case MG_DLButton:
		DLPath_clicked();
		break;
	      case MG_DLString:
		DLPathString_clicked();
		break;
	      case MG_Connect:
		Connect_clicked();
		break;
	      case MG_Disconnect:
		Disconnect_clicked();
		break;
	      case MG_Reload:
		Dir_clicked();
		break;
	      case MG_DirName:
		Dir_clicked();
		break;
	      case MG_SiteName:
		Site_clicked();
	      default:
		break;
	    }
	    break;
	  case WMHI_MENUPICK: {
	      USHORT menunum=code;
	      struct CallBackHook *cbh;
	      struct Window *win=MainWindow;

	      while (MainWindow==win && menunum!=MENUNULL) {
		  struct MenuItem *menuitem=ItemAddress(menu,menunum);
		  cbh=(void *)GTMENUITEM_USERDATA(menuitem);
		  if ((ULONG)cbh>100) {
		      if (cbh->cbh_func) {
			  if (!cbh->cbh_func(menuitem))
			    done=TRUE;
		      }
		  }
		  else {	/* Hotlist item selected */
		      int hnum=(int)cbh,i;
		      struct SiteNode *ptr=NULL;
		      struct Node *lbn;
		      hnum--;
		      for (i=0,lbn=GetHead(&SiteList);lbn;lbn=GetSucc(lbn)) {
			  GetListBrowserNodeAttrs(lbn,
						  LBNA_UserData,&ptr,
						  TAG_DONE);
			  if (ptr) {
			      if (ptr->sn_HotList) {
				  if (i==hnum)
				    break;
				  i++;
			      }
			  }
		      }
		      if (ptr && (i==hnum) && ptr->sn_MenuType!=SLN_PARENT && !ptr->sn_BarLabel) {
			  ConnectSite(ptr,0);
			  if (connected)
			    strncpy(CurrentState.LastLVSite,ptr->sn_Node.ln_Name,60);
		      }
		  }
		  menunum=menuitem->NextSelect;
	      }
	      break;
	  }
	  case WMHI_MENUHELP: {
	      struct CallBackHook *cbh;
	      struct MenuItem *menuitem=ItemAddress(menu,result&WMHI_MENUMASK);

	      if (menuitem) {
		  cbh=(void *)GTMENUITEM_USERDATA(menuitem);
		  if (cbh) {
		      if ((LONG)cbh>100)
			SendAGMessage(cbh->cbh_aguide);
		      else
			SendAGMessage(AG_MENUHOTLIST);
		  }
	      }
	  }
	    break;
	  case WMHI_ICONIFY:
	    if (AllowIconify)
	      if (CA_Iconify(MainWin_Object))
		MainWindow=NULL;
	    break;
	  case WMHI_UNICONIFY:
	    MainWindow=CA_OpenWindow(MainWin_Object);
	    break;
	  case WMHI_RAWKEY:
//	    kprintf("key: %ld\n", code);
	    break;
	}
	if (MenuNeedsUpdate) {
	    UpdateMenus();
	    MenuNeedsUpdate=FALSE;
	}
    }

    if (Upload) {
	struct Node *node;
	LockWindow(MainWin_Object);
	UploadFile(&DropUploadList, NULL, TransferMode);
	Upload=FALSE;
	free_dirlist(&DropUploadList);
	UnlockWindow(MainWin_Object);
    }

    return done;
}


struct List dummy_list;
static struct Hook MainIDCMPHook;

static ULONG __asm __saveds MainIDCMPHookFunc(register __a0 struct Hook *hook,
					      register __a2 Object *WinObj,
					      register __a1 struct IntuiMessage *msg)
{
    switch (msg->Class) {
      case IDCMP_RAWKEY:
	switch (msg->Code) {
	  case 95:
	    SendAGMessage(AG_MAINWIN);
	    break;
	  case CURSORUP:
	    if (msg->Qualifier & (IEQUALIFIER_LSHIFT|IEQUALIFIER_RSHIFT))
	      ScrollListbrowser(LBP_PAGEUP);
	    else if (msg->Qualifier & (IEQUALIFIER_LALT|IEQUALIFIER_RALT))
	      ScrollListbrowser(LBP_TOP);
	    else
	      ScrollListbrowser(LBP_LINEUP);
	    break;
	  case CURSORDOWN:
	    if (msg->Qualifier & (IEQUALIFIER_LSHIFT|IEQUALIFIER_RSHIFT))
	      ScrollListbrowser(LBP_PAGEDOWN);
	    else if (msg->Qualifier & (IEQUALIFIER_LALT|IEQUALIFIER_RALT))
	      ScrollListbrowser(LBP_BOTTOM);
	    else
	      ScrollListbrowser(LBP_LINEDOWN);
	    break;
	}
	break;
    }
    return 0;
}

static struct Hook AppMessageHook;
static ULONG __asm __saveds AppMessageHookFunc(register __a0 struct Hook *hook,
					       register __a2 Object *WinObj,
					       register __a1 struct AppMessage *msg)
{
    int i;
    struct Node *node;
    extern Object *AboutWin_Object;
    extern Object *EditSiteWin_Object;
    extern Object *TransferWin_Object;
    extern Object *SiteListWin_Object;
    extern Object *MainPrefsWin_Object;

    if (!connected || TransferWin_Object || AboutWin_Object || EditSiteWin_Object ||
	SiteListWin_Object || MainPrefsWin_Object)
      return 0;

    while (node=RemHead(&DropUploadList)) {
	free(node->ln_Name);
	FreeMem(node, sizeof(struct Node));
    }

    for (i=0; i<msg->am_NumArgs; i++) {
	if (msg->am_ArgList[i].wa_Lock && msg->am_ArgList[i].wa_Name) {
	    char path[300];
	    BPTR lock;
	    struct FileInfoBlock fib;

	    NameFromLock(msg->am_ArgList[i].wa_Lock, path, 300);
	    AddPart(path, msg->am_ArgList[i].wa_Name, 300);

	    lock=Lock(path, ACCESS_READ);
	    if (lock) {
		if (Examine(lock, &fib)) {
		    if (fib.fib_DirEntryType<0) {
			struct dirlist *entry;
			struct Node *node;

			if (entry=new_direntry(path, NULL, NULL, NULL,
					       S_IFREG, fib.fib_Size)) {
			    if (node=AllocListBrowserNode(1,
							  LBNA_UserData, entry,
							  LBNA_Column, 0,
							  LBNCA_Text, entry->name,
							  LBNA_Selected, TRUE,
							  TAG_DONE)) {
				node->ln_Name=(void *)entry;
				AddTail(&DropUploadList, node);
				Upload=TRUE;
			    }
			    else
			      free_direntry(entry);
			}
		    }
		}
		UnLock(lock);
	    }
	}
    }
    return 0;
}

struct RastPort *ARPort,rastport;
extern struct List SpeedBarList;

struct Window *OpenFTPWindow(const BOOL StartIconified)
{
    struct Object *g1,*g2, *g3, *but1, *but2, *buttonlayout;

    Screen=LockPubScreen(MainPrefs.mp_OpenOnDefaultScreen?NULL:MainPrefs.mp_PubScreen);
    if (!Screen) {
	char pubname[256];
	Screen=LockPubScreen(NULL);
/*	GetDefaultPubScreen(pubname);
	if (MainPrefs.mp_PubScreen)
	  free(MainPrefs.mp_PubScreen);
	MainPrefs.mp_PubScreen=strdup(pubname);*/
    }
    ScreenFont=OpenFont(Screen->Font);

    AmiFTPAttr.ta_Name=Screen->Font->ta_Name;
    AmiFTPAttr.ta_YSize=Screen->Font->ta_YSize;
    ListViewAttr.ta_Name=Screen->Font->ta_Name;
    ListViewAttr.ta_YSize=Screen->Font->ta_YSize;

    if (!MainPrefs.mp_UseDefaultFonts) {
	if (MainPrefs.mp_FontName && MainPrefs.mp_FontSize > 0) {
	    AmiFTPAttr.ta_Name=MainPrefs.mp_FontName;
	    AmiFTPAttr.ta_YSize=MainPrefs.mp_FontSize;
	}
	if (MainPrefs.mp_ListFontName && MainPrefs.mp_ListFontSize > 0) {
	    ListViewAttr.ta_Name=MainPrefs.mp_ListFontName;
	    ListViewAttr.ta_YSize=MainPrefs.mp_ListFontSize;
	}
    }

    if (AmiFTPFont=OpenDiskFont(&AmiFTPAttr)) {
	AmiFTPAttrF=&AmiFTPAttr;
	PropFont=AmiFTPFont;
    }
    else {
	AmiFTPAttrF=Screen->Font;
	PropFont=ScreenFont;
    }

    if (ListViewFont=OpenDiskFont(&ListViewAttr)) {
	ListViewAttrF=&ListViewAttr;
	LBFont=ListViewFont;
    }
    else {
	ListViewAttrF=AmiFTPAttrF;
	LBFont=PropFont;
    }

    InitRastPort(&rastport);
    SetFont(&rastport, PropFont);
    ARPort=&rastport;
    TextLength(&rastport, "0", 1);
    DrawInfo=GetScreenDrawInfo(Screen);
    VisualInfo=GetVisualInfo(Screen, TAG_DONE);

    InitSpeedBarList();

    CreateInfoList(&dummy_list);

    lsel=-1;
    MainWindowLayout=LayoutObject,
    	               GA_DrawInfo, DrawInfo,
                       GA_TextAttr, AmiFTPAttrF,
	               LAYOUT_DeferLayout, TRUE,//FALSE,
	               LAYOUT_SpaceOuter, TRUE,
	               LAYOUT_HorizAlignment, LALIGN_RIGHT,
	               LAYOUT_Orientation, LAYOUT_ORIENT_VERT,

	               StartMember,g1=LayoutObject,LAYOUT_Orientation,LAYOUT_ORIENT_VERT,
                         StartMember, MG_List[MG_SiteName]=StringObject,
	                   GA_ID,MG_SiteName,
	                   GA_RelVerify, TRUE,
                           STRINGA_Buffer,sitenamebuffer,
	                   STRINGA_MaxChars, 99,
                         StringEnd,Label(GetAmiFTPString(MW_SiteName)),
                       EndGroup,CHILD_WeightedHeight,0,

	               StartHGroup,Spacing(FALSE),
                         StartMember, g2=VGroupObject,
                           StartMember, MG_List[MG_DirName]=StringObject,
	                     GA_ID,MG_DirName,
	                     GA_RelVerify, TRUE,
                             GA_Disabled,TRUE,
                             STRINGA_Buffer,remotedirbuffer,
	                     STRINGA_MaxChars, 120,
                           StringEnd,Label(GetAmiFTPString(MW_DirName)),
                         EndGroup,

                         StartMember, MG_List[MG_CacheList]=ChooserObject,
                           GA_ID, MG_CacheList,
                           GA_RelVerify, TRUE,
//                           GA_Width, 20,
                           GA_Disabled, TRUE,
                           CHOOSER_Labels, &clist,
                           CHOOSER_AutoFit, TRUE,
                           CHOOSER_DropDown, TRUE,
                         ChooserEnd,
                         CHILD_WeightedWidth, 0,

                         StartMember, MG_List[MG_Reload]=ButtonObject,
	                   GA_Text,GetAmiFTPString(MW_Reload),
	                   GA_ID, MG_Reload,
	                   GA_RelVerify, TRUE,
                           GA_Disabled, TRUE,
	                 ButtonEnd,
                         CHILD_WeightedWidth, 0,
                       EndGroup, CHILD_WeightedHeight, 0,

                       StartMember, MG_List[MG_SpeedBar]=SpeedBarObject,
                           GA_ID, MG_SpeedBar,
                           GA_RelVerify, TRUE,
                           SPEEDBAR_Buttons, &SpeedBarList,
                       SpeedBarEnd,

	               StartVGroup, CLASSACT_BackFill, LAYERS_BACKFILL, StartMember,
                         MG_List[MG_ListView]=ListBrowserObject,
	                 GA_ID, MG_ListView,
	                 GA_RelVerify, TRUE,
                         GA_TextAttr, ListViewAttrF,
	                 LISTBROWSER_Labels, (ULONG)FileList?FileList:&dummy_list,
	                 LISTBROWSER_MultiSelect, TRUE,
	                 LISTBROWSER_ShowSelected, TRUE,
                         LISTBROWSER_ColumnInfo, (ULONG)FileList?&columninfo:&dummycolumninfo,
                         LISTBROWSER_Separators, FALSE,
                         LISTBROWSER_AutoFit, TRUE,
                         LISTBROWSER_HorizontalProp, TRUE,
	               ListBrowserEnd,
                       CHILD_MinHeight, LBFont->tf_YSize*6,
                       EndGroup, 

	               LAYOUT_AddChild, g3=VLayoutObject, EvenSized,

  	                 StartHGroup, StartHGroup, Spacing(FALSE),

	                   StartMember, MG_List[MG_DLString]=StringObject,
	                     GA_ID, MG_DLString,
	                     GA_RelVerify, TRUE,
                             STRINGA_Buffer, localdirbuffer,
	                     STRINGA_MaxChars, 80,
	                   StringEnd,

	                   StartMember, MG_List[MG_DLButton]=ButtonObject,
	                     BUTTON_AutoButton, BAG_POPDRAWER,
	                     GA_ID, MG_DLButton,
	                     GA_RelVerify, TRUE,
	                     ButtonEnd,
	                     CHILD_WeightedWidth, 0,
	                     CHILD_WeightedHeight, 0,
	                 EndGroup,
                         CHILD_WeightedHeight, 0,
	                 Label(GetAmiFTPString(MW_DownloadDir)),
                         EndGroup, CHILD_WeightedHeight, 0,

	                 LAYOUT_AddChild, but1=HLayoutObject, EvenSized,
                         LAYOUT_AddChild, pagelayout=LayoutObject,
                         LAYOUT_AddChild, MG_List[MG_Page2]=PageObject,
                         PAGE_Add, LayoutObject,

  	                   StartMember, MG_List[MG_Parent]=ButtonObject,
	                     GA_Text, GetAmiFTPString(MW_Parent),
	                     GA_ID, MG_Parent,
	                     GA_RelVerify, TRUE,
                             GA_Disabled, TRUE,
	                   ButtonEnd,
                         LayoutEnd,
                         PAGE_Add, LayoutObject,
                           StartMember, MG_List[MG_Readme]=ButtonObject,
	                     GA_Text, GetAmiFTPString(MW_ViewReadme),
	                     GA_ID, MG_Readme,
	                     GA_RelVerify, TRUE,
                             GA_Disabled, TRUE,
	                   ButtonEnd,
                         LayoutEnd,
                         LayoutEnd,
                         LayoutEnd,
	                   StartMember, MG_List[MG_Get]=ButtonObject,
	                     GA_Text, GetAmiFTPString(MW_Get),
	                     GA_ID, MG_Get,
	                     GA_RelVerify, TRUE,
                             GA_Disabled, TRUE,
	                   ButtonEnd,
	                   StartMember, MG_List[MG_Put]=ButtonObject,
	                     GA_Text, GetAmiFTPString(MW_Put),
	                     GA_ID, MG_Put,
	                     GA_RelVerify, TRUE,
                             GA_Disabled, TRUE,
	                   ButtonEnd,
	                   StartMember, MG_List[MG_View]=ButtonObject,
	                     GA_Text, GetAmiFTPString(MW_View),
	                     GA_ID, MG_View,
	                     GA_RelVerify, TRUE,
                             GA_Disabled, TRUE,
	                   ButtonEnd,
	                 EndGroup,
                         CHILD_WeightedHeight, 0,

	                 LAYOUT_AddChild, but2=HLayoutObject, EvenSized,

	                   StartMember, MG_List[MG_Connect]=ButtonObject,
	                     GA_Text, GetAmiFTPString(MW_Connect),
	                     GA_ID, MG_Connect,
	                     GA_RelVerify, TRUE,
	                   ButtonEnd,

	                   StartMember, MG_List[MG_Disconnect]=ButtonObject,
	                     GA_Text, GetAmiFTPString(MW_Disconnect),
	                     GA_ID, MG_Disconnect,
	                     GA_RelVerify, TRUE,
                             GA_Disabled, TRUE,
	                   ButtonEnd,
	                 EndGroup,
                         CHILD_WeightedHeight, 0,
                       EndGroup,
                       CHILD_WeightedHeight, 0,
	             LayoutEnd;
    if (!MainWindowLayout) {
//	Printf("Failed to create layout\n");
	return 0;
    }

    SetAttrs(g1, LAYOUT_AlignLabels, g2, TAG_DONE);
    SetAttrs(g2, LAYOUT_AlignLabels, g1, TAG_DONE);

    MainIDCMPHook.h_Entry=(HOOKFUNC)MainIDCMPHookFunc;
    MainIDCMPHook.h_SubEntry=NULL;
    MainIDCMPHook.h_Data=NULL;

    AppMessageHook.h_Entry=(HOOKFUNC)AppMessageHookFunc;
    AppMessageHook.h_SubEntry=NULL;
    AppMessageHook.h_Data=NULL;

    if (!MainPrefs.mp_ShowButtons) {
	SetAttrs(g3,
		 LAYOUT_RemoveChild, but1,
		 LAYOUT_RemoveChild, but2,
		 TAG_DONE);
	MG_List[MG_Parent]=MG_List[MG_Get]=MG_List[MG_Put]=MG_List[MG_View]=
	  MG_List[MG_Readme]=MG_List[MG_Get2]=MG_List[MG_Put2]=MG_List[MG_View2]=
	    MG_List[MG_Connect]=MG_List[MG_Disconnect]=NULL;
    }
    if (!MainPrefs.mp_ShowToolBar) {
	SetAttrs(MainWindowLayout,
		 LAYOUT_RemoveChild, MG_List[MG_SpeedBar],
		 TAG_DONE);
	FreeSpeedBarList();
    }

    MainWin_Object = WindowObject,
                       WA_Title, wintitle,
                       WA_ScreenTitle, wintitle,
                       WA_PubScreen, Screen,
                       WA_SizeGadget, TRUE,
                       WA_SizeBBottom, TRUE,
                       WA_Top, CurrentState.TopEdge?CurrentState.TopEdge:MainPrefs.mp_TopEdge-Screen->ViewPort.DyOffset,
                       WA_Left, CurrentState.LeftEdge?CurrentState.LeftEdge:MainPrefs.mp_LeftEdge-Screen->ViewPort.DxOffset,
                       WA_InnerHeight, CurrentState.Height?CurrentState.Height:MainPrefs.mp_Height,
                       WA_InnerWidth, CurrentState.Width?CurrentState.Width:MainPrefs.mp_Width,
                       WA_DepthGadget, TRUE,
                       WA_DragBar, TRUE,
                       WA_CloseGadget, TRUE,
                       WA_Activate, TRUE,
                       WA_SmartRefresh, TRUE,
                       WA_MenuHelp, TRUE,
                       WA_IDCMP, IDCMP_MENUHELP,
                       WINDOW_IconifyGadget, TRUE,
                       WINDOW_IconTitle, "AmiFTP",
                       WINDOW_Icon, GetDiskObject("PROGDIR:AMIFTP"),
                       WINDOW_AppPort, AppPort,
                       WINDOW_AppWindow, TRUE,
                       WINDOW_AppMsgHook, &AppMessageHook,
                       WINDOW_ParentGroup, MainWindowLayout,
                       WINDOW_IDCMPHook, &MainIDCMPHook,
                       WINDOW_IDCMPHookBits, IDCMP_RAWKEY,
                     EndWindow;

    if (!MainWin_Object) {
//	Printf("Failed to create WinObject\n");
	DisposeObject(MainWindowLayout);
	return 0;
    }

    UpdateMenus();

    {
	int state=prev_state==-1?MB_DISCONNECTED:prev_state;
	prev_state=-1;

	UpdateMainButtons(state);
    }

    if (StartIconified) {
	MainWindow=NULL;
	CA_Iconify(MainWin_Object);
	return (struct Window *)1;
    }

    if (MainWindow=CA_OpenWindow(MainWin_Object)) {
	UpdateWindowTitle();
	UnlockPubScreen(NULL, Screen);
	return MainWindow;
    }

    UnlockPubScreen(NULL, Screen);

    DisposeObject(MainWin_Object);
    MainWin_Object=NULL;
    MainWindowLayout=NULL;
    CloseFont(ScreenFont);
    ScreenFont=NULL;
    if (ListViewFont)
      CloseFont(ListViewFont);
    if (AmiFTPFont)
      CloseFont(AmiFTPFont);
    FreeInfoList(&dummy_list);
    ListViewFont=NULL;
    AmiFTPFont=NULL;

    return NULL;
}

void CloseMainWindow()
{
    if (MainWin_Object) {
/*	LONG w,h,l,t;

	GetAttrs(MainWin_Object,
		 WA_InnerWidth, &w, WA_InnerHeight, &h,
		 TAG_DONE);*/
	CurrentState.Width=MainWindow->Width-MainWindow->BorderLeft-MainWindow->BorderRight;
	CurrentState.Height=MainWindow->Height-MainWindow->BorderTop-MainWindow->BorderBottom;
	CurrentState.TopEdge=MainWindow->TopEdge;
	CurrentState.LeftEdge=MainWindow->LeftEdge;
/*	kprintf("%ld %ld %ld %ld\n", CurrentState.Width, CurrentState.Height,
		CurrentState.TopEdge, CurrentState.LeftEdge);*/
	DisposeObject(MainWin_Object);
	MainWin_Object=NULL;
	MainWindowLayout=NULL;
	MainWindow=NULL;
    }
    if (ScreenFont) {
	CloseFont(ScreenFont);
	ScreenFont=NULL;
    }
    if (ListViewFont) {
	CloseFont(ListViewFont);
	ListViewFont=NULL;
    }
    if (AmiFTPFont) {
	CloseFont(AmiFTPFont);
	AmiFTPFont=NULL;
    }
    if (VisualInfo) {
	FreeVisualInfo(VisualInfo);
	VisualInfo=NULL;
    }
    FreeSpeedBarList();
    FreeInfoList(&dummy_list);
}


#define DisableGadget(gadget, disable) if (SetGadgetAttrs(gadget, MainWindow, NULL, GA_Disabled, disable, TAG_DONE) && MainWindow) RefreshGList(gadget, MainWindow, NULL, 1);

void UpdateMainButtons(const int state)
{
    UpdateWindowTitle();

    if (state == prev_state)
      return;

    switch (state) {
      case MB_DISCONNECTED:
	if (MainPrefs.mp_ShowButtons) {
	    if (CurrentState.ADTMode) {
		DisableGadget(MG_List[MG_Readme], TRUE)
	      }
	    else {
		DisableGadget(MG_List[MG_Parent], TRUE);
	    }
	    DisableGadget(MG_List[MG_Get], TRUE);
	    DisableGadget(MG_List[MG_Put], TRUE);
	    DisableGadget(MG_List[MG_View], TRUE);
	    DisableGadget(MG_List[MG_Get2], TRUE);
	    DisableGadget(MG_List[MG_Put2], TRUE);
	    DisableGadget(MG_List[MG_View2], TRUE);
	    DisableGadget(MG_List[MG_Disconnect], TRUE);
	}

	DisableGadget(MG_List[MG_DirName], TRUE);
	DisableGadget(MG_List[MG_CacheList], TRUE);
	DisableGadget(MG_List[MG_Reload], TRUE);
	if (SetGadgetAttrs(MG_List[MG_ListView], MainWindow, NULL,
			   LISTBROWSER_Labels, &dummy_list,
			   LISTBROWSER_ColumnInfo, &dummycolumninfo,
			   LISTBROWSER_AutoFit, TRUE,
			   TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_ListView], MainWindow, NULL, 1);
	lsel=-1;
	break;
      case MB_NONESELECTED:
	if (CurrentState.ADTMode) {
	    if (MainPrefs.mp_ShowButtons)
	      DisableGadget(MG_List[MG_Readme], TRUE);
	    DisableGadget(MG_List[MG_DirName], TRUE);
	    DisableGadget(MG_List[MG_CacheList], TRUE);
	    DisableGadget(MG_List[MG_Reload], TRUE);
	}
	else {
	    if (MainPrefs.mp_ShowButtons)
	      DisableGadget(MG_List[MG_Parent], FALSE);
	    DisableGadget(MG_List[MG_DirName], FALSE);
	    DisableGadget(MG_List[MG_CacheList], FALSE);
	    DisableGadget(MG_List[MG_Reload], FALSE);
	}
	if (MainPrefs.mp_ShowButtons) {
	    DisableGadget(MG_List[MG_Get], TRUE);
	    DisableGadget(MG_List[MG_Put], FALSE);
	    DisableGadget(MG_List[MG_View], TRUE);
	    DisableGadget(MG_List[MG_Get2], TRUE);
	    DisableGadget(MG_List[MG_Put2], FALSE);
	    DisableGadget(MG_List[MG_View2], TRUE);
	    DisableGadget(MG_List[MG_Disconnect], FALSE);
	}
	lsel=-1;
	break;
	  case MB_FILESELECTED:
	if (CurrentState.ADTMode) {
	    if (MainPrefs.mp_ShowButtons)
	      DisableGadget(MG_List[MG_Readme], FALSE);
	    DisableGadget(MG_List[MG_DirName], TRUE);
	    DisableGadget(MG_List[MG_CacheList], TRUE);
	    DisableGadget(MG_List[MG_Reload], TRUE);
	}
	else {
	    if (MainPrefs.mp_ShowButtons)
	      DisableGadget(MG_List[MG_Parent], FALSE);
	    DisableGadget(MG_List[MG_DirName], FALSE);
	    DisableGadget(MG_List[MG_Reload], FALSE);
	    DisableGadget(MG_List[MG_CacheList], FALSE);
	}

	if (MainPrefs.mp_ShowButtons) {
	    DisableGadget(MG_List[MG_Get], FALSE);
	    DisableGadget(MG_List[MG_Put], FALSE);
	    DisableGadget(MG_List[MG_Disconnect], FALSE);
	    DisableGadget(MG_List[MG_View], FALSE);
	    DisableGadget(MG_List[MG_Get2], FALSE);
	    DisableGadget(MG_List[MG_Put2], FALSE);
	    DisableGadget(MG_List[MG_View2], FALSE);
	}
	break;
      default:
	break;
    }

    if (MainPrefs.mp_ShowToolBar)
      UpdateSpeedBar(state);

    prev_state=state;

    if (MainWindow)
      RefreshGList(MG_List[MG_CacheList], MainWindow, NULL, 1);
}
#undef DisableGadget

void AttachToolList(const BOOL NoneSelected)
{
    if (MainWindow) {
	if (SetGadgetAttrs(MG_List[MG_ListView], MainWindow, NULL,
			   LISTBROWSER_Labels, FileList,
			   LISTBROWSER_ColumnInfo, &columninfo,
			   NoneSelected?LISTBROWSER_AutoFit:TAG_IGNORE, TRUE,
			   NoneSelected?LISTBROWSER_Selected:TAG_IGNORE, -1,
			   NoneSelected?LISTBROWSER_MakeVisible:TAG_IGNORE, 0,
			   TAG_DONE))
	  RefreshGList(MG_List[MG_ListView], MainWindow, NULL, 1);
    }
    else
      SetAttrs(MG_List[MG_ListView],
	       LISTBROWSER_Labels, FileList,
	       LISTBROWSER_ColumnInfo, &columninfo,
	       NoneSelected?LISTBROWSER_AutoFit:TAG_IGNORE, TRUE,
	       NoneSelected?LISTBROWSER_Selected:TAG_IGNORE, -1,
	       NoneSelected?LISTBROWSER_MakeVisible:TAG_IGNORE, 0,
	       TAG_DONE);
    if (NoneSelected) lsel=-1;
}

void DetachToolList(void)
{
    if (MainWindow)
      if (SetGadgetAttrs(MG_List[MG_ListView], MainWindow, NULL,
			 LISTBROWSER_Labels, ~0,
			 LISTBROWSER_AutoFit, TRUE,
			 TAG_DONE))
	RefreshGList(MG_List[MG_ListView], MainWindow, NULL, 1);
    else
      SetAttrs(MG_List[MG_ListView], LISTBROWSER_Labels, ~0, TAG_DONE);
}

void UpdateRemoteDir(const char *dir)
{
    if (dir) 
      if (dir!=&CurrentState.CurrentRemoteDir[0])
	strncpy(CurrentState.CurrentRemoteDir, dir, 255);
    if (MainWindow) {
	if (SetGadgetAttrs(MG_List[MG_DirName], MainWindow, NULL,
			   STRINGA_TextVal, dir,
			   TAG_END))
	  RefreshGList(MG_List[MG_DirName], MainWindow, NULL, 1);
    }
    UpdateWindowTitle();
}

void UpdateLocalDir(const char *dir)
{
    if (dir!=&CurrentState.CurrentDLDir[0])
      strncpy(CurrentState.CurrentDLDir, dir, 255);
    if (MainWindow) {
	if (SetGadgetAttrs(MG_List[MG_DLString], MainWindow, NULL,
			   STRINGA_TextVal, dir,
			   TAG_END))
	    RefreshGList(MG_List[MG_DLString], MainWindow, NULL, 1);
    }
    UpdateWindowTitle();
}

void UpdateSiteName(const char *site)
{
    if (site!=CurrentState.CurrentSite)
      strncpy(CurrentState.CurrentSite, site, 50);
    if (MainWindow) {
	if (SetGadgetAttrs(MG_List[MG_SiteName], MainWindow, NULL,
			   STRINGA_TextVal, site,
			   TAG_END))
	    RefreshGList(MG_List[MG_SiteName], MainWindow, NULL, 1);
    }
}

void LockWindow(Object *window_object)
{
    if (window_object==MainWin_Object)
      ClearMenuStrip(MainWindow);
    SetAttrs(window_object,
	     WA_BusyPointer, TRUE,
	     TAG_DONE);
}

void UnlockWindow(Object *window_object)
{
    SetAttrs(window_object,
	     WA_BusyPointer, FALSE,
	     TAG_DONE);

    if (window_object==MainWin_Object) {
	struct Menu *mmenu=menu->NextMenu; /* The files menu */
	struct MenuItem *menuitem;

	menuitem=mmenu->FirstItem;
	menuitem=mmenu->FirstItem;
	menuitem=mmenu->FirstItem;
	menuitem=mmenu->FirstItem;
	
	menuitem->Flags|=TransferMode==BINARY?CHECKED:NULL;
	menuitem=menuitem->NextItem;
	menuitem->Flags|=TransferMode==ASCII?CHECKED:NULL;

	mmenu=mmenu->NextMenu; /* The sort menu */
	menuitem=mmenu->FirstItem;
	menuitem->Flags|=SortMode==SORTBYNAME?CHECKED:NULL;
	menuitem=menuitem->NextItem;
	menuitem->Flags|=SortMode==SORTBYDATE?CHECKED:NULL;

	mmenu=mmenu->NextMenu; /* The settings menu */
	menuitem=mmenu->FirstItem;
	menuitem=menuitem->NextItem;
	menuitem=menuitem->NextItem;

	menuitem=menuitem->NextItem;
	menuitem->Flags|=LogWindow?CHECKED:NULL;

	menuitem=menuitem->NextItem;
	menuitem->Flags|=MainPrefs.mp_Showdotfiles?CHECKED:NULL;

	menuitem=menuitem->NextItem;
	menuitem->Flags|=MainPrefs.mp_ShowAllADTFiles?CHECKED:NULL;
	if (MainWindow)
	  ResetMenuStrip(MainWindow, menu);
	else
	  SetAttrs(window_object,
		   WINDOW_MenuStrip, menu,
		   TAG_DONE);
    }

    return;
}

void ChangeAmiFTPMode(void)
{
    if (CurrentState.ADTMode) {
	SetGadgetAttrs(MG_List[MG_Page2], MainWindow, NULL,
		       PAGE_Current, 1, TAG_DONE);
	RethinkLayout(pagelayout, MainWindow, NULL, TRUE);
    }
    else {
	SetGadgetAttrs(MG_List[MG_Page2], MainWindow, NULL,
		       PAGE_Current, 0, TAG_DONE);
	RethinkLayout(pagelayout, MainWindow, NULL, TRUE);
    }
    RefreshGList(pagelayout, MainWindow, NULL, 1);
}

void UpdateWindowTitle()
{
    static char title[100];
    int numselfiles=0, numselbytes=0;
    char *bytes="kB";
    int freebytes=0;
    char *fbytes="kB";
    struct InfoData info;
    BPTR lock;

    if (lock=Lock(CurrentState.CurrentDLDir, ACCESS_READ)) {
	char pathname[256];
	int i;

	NameFromLock(lock, pathname, 256);
	UnLock(lock);
	i=0;
	while (pathname[i]!=':' && pathname[i]) {
	    i++;
	}
	i++;
	pathname[i]='\0';

	if (!getdfs(pathname, &info)) {
	    freebytes=(info.id_NumBlocks-info.id_NumBlocksUsed)*info.id_BytesPerBlock;
	    if (freebytes < 1000000) {
		freebytes/=1024;
		fbytes="kB";
	    }
	    else {
		freebytes/=(1024*1024);
		fbytes="MB";
	    }
	}
    }

    if (FileList) {
	struct Node *node;

	for (node=FirstNode(FileList); node; node=NextNode(node)) {
	    ULONG sel;
	    struct dirlist *ptr;

	    GetListBrowserNodeAttrs(node, LBNA_Selected, &sel, TAG_DONE);
	    if (sel && (ptr=(void *)node->ln_Name)) {
		numselfiles++;
		numselbytes+=ptr->size==-1?0:ptr->size;
	    }
	}
	if (numselbytes < 1000000) {
	    numselbytes/=1024;
	    bytes="kB";
	}
	else {
	    numselbytes/=(1024*1024);
	    bytes="MB";
	}
    }
    sprintf(title, GetAmiFTPString(Str_WindowTitle),
	    numselfiles, numselbytes, bytes, freebytes, fbytes);
    SetAttrs(MainWin_Object,
	     WA_Title, title,
	     TAG_DONE);
}

static void ScrollListbrowser(ULONG direction)
{
    if (FileList) {
	if (!EmptyList(FileList)) {
	    SetGadgetAttrs(MG_List[MG_ListView], MainWindow, NULL,
			   LISTBROWSER_Position, direction,
			   TAG_DONE);
	}
    }
}

static struct Image *listimage;
static UWORD listmapping[4];

void CreateInfoList(struct List *list)
{
    struct Node *node;
    extern struct Image im;
    extern char *linfotext;
    int i;
    char *infostrings[4]={NULL, "Copyright © 1996 by Magnus Lilja", "<lilja@@lysator.liu.se>","All Rights Reserved"};

    infostrings[0]=linfotext;

    NewList(list);

    listmapping[0]=DrawInfo->dri_Pens[BACKGROUNDPEN];
    listmapping[1]=DrawInfo->dri_Pens[SHADOWPEN];
    listmapping[2]=DrawInfo->dri_Pens[SHINEPEN];
    listmapping[3]=DrawInfo->dri_Pens[FILLPEN];

    if (listimage=(struct Image *)NewObject(LABEL_GetClass(), NULL,
					   LABEL_Mapping, listmapping,
					   LABEL_Image, &im,
					   TAG_END))
      if (node=AllocListBrowserNode(1,
				    LBNA_Flags, LBFLG_READONLY,
				    LBNA_Column, 0,
				    LBNCA_Image, (ULONG)listimage,
				    LBNCA_Justification, LCJ_CENTRE,
				    TAG_END))
	AddTail(list, node);
    
    for (i=0; i<4; i++)
      if (node=AllocListBrowserNode(1,
				    LBNA_Flags, LBFLG_READONLY,
				    LBNA_Column, 0,
				    LBNCA_Text, infostrings[i],
				    LBNCA_Justification, LCJ_CENTRE,
				    TAG_DONE))
	AddTail(list, node);
}

void FreeInfoList(struct List *list)
{
    FreeListBrowserList(list);
    if (listimage)
      DisposeObject(listimage);
}

/* EOF */
@


1.736
log
@Transferwindow progressbar freaked out if the file was too big. now fixed.
Other stuff fixed.
@
text
@d1 2
a2 2
/* RCS Id: $Id: MainWindow.c 1.730 1996/08/02 21:57:32 lilja Exp lilja $
   Locked version: $Revision: 1.730 $
d46 5
d57 2
d190 2
a191 1
		HandleSpeedBar(code);
d314 1
a314 4
	while (node=RemHead(&DropUploadList)) {
	    free(node->ln_Name);
	    FreeMem(node, sizeof(struct Node));
	}
d392 17
a408 5
			struct Node *node=AllocMem(sizeof(struct Node), MEMF_CLEAR);
			if (node) {
			    node->ln_Name=strdup(path);
			    AddTail(&DropUploadList, node);
			    Upload=TRUE;
d426 9
a434 3
    Screen=LockPubScreen(MainPrefs.mp_PubScreen);
    if (!Screen)
      Screen=LockPubScreen(NULL);
a469 31
#if 0
    if (!AmiFTPAttr.ta_Name) {
	AmiFTPAttrF=Screen->Font;
	PropFont=ScreenFont;
    }
    else {
	AmiFTPFont=OpenDiskFont(&AmiFTPAttr);
	if (AmiFTPFont) {
	    AmiFTPAttrF=&AmiFTPAttr;
	    PropFont=AmiFTPFont;
	}
	else {
	    AmiFTPAttrF=Screen->Font;
	    PropFont=ScreenFont;
	}
    }
    if (!ListViewAttr.ta_Name) {
	ListViewAttrF=AmiFTPAttrF;
	LBFont=PropFont;
    }
    else {
	if (ListViewFont=OpenDiskFont(&ListViewAttr)) {
	    ListViewAttrF=&ListViewAttr;
	    LBFont=ListViewFont;
	}
	else {
	    ListViewAttrF=AmiFTPAttrF;
	    LBFont=PropFont;
	}
    }
#endif
d480 2
a481 1
    NewList(&dummy_list);
d545 1
a545 1
                         LISTBROWSER_ColumnInfo, (ULONG)&columninfo,
d736 1
d739 1
d779 1
a790 1
    prev_state=state;
d815 2
d880 2
d892 1
d902 1
d1015 1
d1108 49
@


1.730
log
@AmiFTP starts even if no TCP/IP-stack is running.
No 'please insert inet:...' when starting.
Still has to fix the ARexx stuff to cope with no stack running.
@
text
@d1 2
a2 2
/* RCS Id: $Id: MainWindow.c 1.713 1996/07/25 22:53:54 lilja Exp lilja $
   Locked version: $Revision: 1.713 $
d409 1
a409 1
    Screen=LockPubScreen(strlen(CurrentState.ScreenName)?CurrentState.ScreenName:NULL);
@


1.713
log
@Fixed 'AmiFTP ftp://ftp.boo.bar/'. Now using GetHead() etc instead of
ListHead()-functions.
@
text
@d1 2
a2 2
/* RCS Id: $Id: MainWindow.c 1.710 1996/07/25 00:21:30 lilja Exp lilja $
   Locked version: $Revision: 1.710 $
d292 1
a292 1
	    kprintf("key: %ld\n", code);
@


1.710
log
@Fontprefs seems to work ok, except in PrefsWindow.
@
text
@d1 2
a2 2
/* RCS Id: $Id: MainWindow.c 1.692 1996/07/20 00:28:38 lilja Exp lilja $
   Locked version: $Revision: 1.692 $
a412 1
    kprintf("Screen->Font %s/%ld\n", Screen->Font->ta_Name, Screen->Font->ta_YSize);
@


1.692
log
@Speedbar and buttons configurable.
@
text
@d1 2
a2 2
/* RCS Id: $Id: MainWindow.c 1.630 1996/07/07 20:10:48 lilja Exp lilja $
   Locked version: $Revision: 1.630 $
d413 1
d415 34
d478 1
d481 1
a481 1
    SetFont(&rastport,PropFont);
d483 1
a483 1
    TextLength(&rastport,"0",1);
d485 1
a485 1
    VisualInfo=GetVisualInfo(Screen,TAG_DONE);
d492 2
a493 2
    	               GA_DrawInfo,DrawInfo,
                       GA_TextAttr,AmiFTPAttrF,
@


1.630
log
@Added items in the menu to duplicate the buttons.
@
text
@d1 2
a2 2
/* RCS Id: $Id: MainWindow.c 1.625 1996/07/04 17:50:58 lilja Exp lilja $
   Locked version: $Revision: 1.625 $
d25 3
d35 1
a35 1
static UBYTE sitenamebuffer[100],remotedirbuffer[100],localdirbuffer[100];
d37 7
a43 7
    {0,NULL,0},
    {0,NULL,0},
    {0,NULL,0},
    {0,NULL,0},
    {0,NULL,0},
    {0,NULL,0},
    {-1,(STRPTR)~0,-1}
d59 2
a60 1
    while ((result=CA_HandleInput(MainWin_Object,&code))!=WMHI_LASTMSG) {
d159 26
d230 1
d232 1
a232 1
	      while (menunum!=MENUNULL) {
d291 3
d403 1
d407 1
a407 1
    struct Object *g1,*g2;
d451 2
d462 1
a462 3
#if 0
                       StartVGroup, 
#endif
d483 11
d498 1
a498 1
                           GA_Disabled,TRUE,
d500 8
a507 2
                         CHILD_WeightedWidth,0,
                       EndGroup,CHILD_WeightedHeight,0,
d509 1
a509 1
	               StartVGroup,CLASSACT_BackFill,LAYERS_BACKFILL,StartMember,
d511 1
a511 1
	                 GA_ID,MG_ListView,
d513 1
a513 1
                         GA_TextAttr,ListViewAttrF,
d515 6
a520 6
	                 LISTBROWSER_MultiSelect,TRUE,
	                 LISTBROWSER_ShowSelected,TRUE,
                         LISTBROWSER_ColumnInfo,(ULONG)&columninfo,
                         LISTBROWSER_Separators,FALSE,
                         LISTBROWSER_AutoFit,TRUE,
                         LISTBROWSER_HorizontalProp,TRUE,
d522 1
a522 1
                       CHILD_MinHeight,LBFont->tf_YSize*6,
a523 1
	               StartVGroup, EvenSized,
d525 3
a527 1
  	                 StartHGroup,StartHGroup, Spacing(FALSE),
d530 1
a530 1
	                     GA_ID,MG_DLString,
d533 1
a533 1
	                     STRINGA_MaxChars,80,
d541 2
a542 2
	                     CHILD_WeightedWidth,0,
	                     CHILD_WeightedHeight,0,
d544 1
a544 1
                         CHILD_WeightedHeight,0, 
d546 1
a546 1
                         EndGroup,
d548 1
a548 1
	                 StartHGroup, EvenSized,
d550 1
a550 1
                         LAYOUT_AddChild,MG_List[MG_Page2]=PageObject,
d554 1
a554 1
	                     GA_Text,GetAmiFTPString(MW_Parent),
d557 1
a557 1
                             GA_Disabled,TRUE,
d562 1
a562 1
	                     GA_Text,GetAmiFTPString(MW_ViewReadme),
d565 1
a565 1
                             GA_Disabled,TRUE,
d571 1
a571 1
	                     GA_Text,GetAmiFTPString(MW_Get),
d574 1
a574 1
                             GA_Disabled,TRUE,
d577 1
a577 1
	                     GA_Text,GetAmiFTPString(MW_Put),
d580 1
a580 1
                             GA_Disabled,TRUE,
d583 1
a583 1
	                     GA_Text,GetAmiFTPString(MW_View),
d586 1
a586 1
                             GA_Disabled,TRUE,
d589 1
a589 1
                         CHILD_WeightedHeight,0,
d591 1
a591 1
	                 StartHGroup, EvenSized,
d594 1
a594 1
	                     GA_Text,GetAmiFTPString(MW_Connect),
d600 1
a600 1
	                     GA_Text,GetAmiFTPString(MW_Disconnect),
d603 1
a603 1
                             GA_Disabled,TRUE,
d606 1
a606 1
                         CHILD_WeightedHeight,0,
d608 1
a608 1
                       CHILD_WeightedHeight,0,
d615 2
a616 2
    SetAttrs(g1,LAYOUT_AlignLabels,g2,TAG_DONE);
    SetAttrs(g2,LAYOUT_AlignLabels,g1,TAG_DONE);
d625 17
a641 1
    
d650 2
a651 2
                       WA_InnerHeight, MainPrefs.mp_Height,
                       WA_InnerWidth, MainPrefs.mp_Width,
d667 1
a667 1
                       WINDOW_IDCMPHookBits, IDCMP_RAWKEY|IDCMP_GADGETUP,
d678 7
d690 1
d716 11
d748 1
a750 1
int prev_state=MB_DISCONNECTED;
d757 1
d764 14
a777 2
	if (CurrentState.ADTMode) {
	    DisableGadget(MG_List[MG_Readme], TRUE)
d779 1
a779 6
	else {
	    DisableGadget(MG_List[MG_Parent], TRUE);
	}
	DisableGadget(MG_List[MG_Get], TRUE);
	DisableGadget(MG_List[MG_Put], TRUE);
	DisableGadget(MG_List[MG_Disconnect], TRUE);
d781 1
d791 2
a792 1
	    DisableGadget(MG_List[MG_Readme], TRUE);
d794 1
d798 2
a799 1
	    DisableGadget(MG_List[MG_Parent], FALSE);
d801 1
d804 9
a812 4
	DisableGadget(MG_List[MG_Get], TRUE);
	DisableGadget(MG_List[MG_Put], FALSE);
	DisableGadget(MG_List[MG_Disconnect], FALSE);
	DisableGadget(MG_List[MG_View], TRUE);
d815 1
a815 1
      case MB_FILESELECTED:
d817 2
a818 1
	    DisableGadget(MG_List[MG_Readme], FALSE);
d820 1
d824 2
a825 1
	    DisableGadget(MG_List[MG_Parent], FALSE);
d828 11
a839 4
	DisableGadget(MG_List[MG_Get], FALSE);
	DisableGadget(MG_List[MG_Put], FALSE);
	DisableGadget(MG_List[MG_Disconnect], FALSE);
	DisableGadget(MG_List[MG_View], FALSE);
d844 6
@


1.625
log
@Cleaned up the code a bit.
Rename ftpwin.h to AmiFTP.h and ftpwin.c to AmiFTP.c.
Created Menu.c and moved all menu-functions there.
@
text
@d1 2
a2 2
/* RCS Id: $Id: MainWindow.c 1.614 1996/07/01 21:01:37 lilja Exp lilja $
   Locked version: $Revision: 1.614 $
d157 1
a157 1
		Get_Clicked();
@


1.614
log
@(shift/alt/none)+cursor up/down scrolls the filelist.
@
text
@d1 2
a2 2
/* RCS Id: $Id: MainWindow.c 1.607 1996/06/30 12:33:45 lilja Exp lilja $
   Locked version: $Revision: 1.607 $
d5 1
a6 2
#include "ftpwin.h"
#include <workbench/workbench.h>
d24 1
a24 1
struct Menu *menu;
a42 10
void ParentClicked(void);
void PutClicked(void);
void ViewClicked(void);
void ConnectClicked(void);
void DisconnectClicked(void);
void UpdateMenus(void);
void DLPathString_clicked(void);

int BuildMenu(void);

d47 1
d69 1
a69 1
						  LBNA_Selected,&attr,TAG_DONE);
d81 5
a85 3
			  GetAttrs(MG_List[MG_ListView],LISTBROWSER_NumSelected,&attr,
				   LISTBROWSER_RelEvent,&action,
				   LISTBROWSER_SelectedNode,&node,TAG_DONE);
d93 1
a93 1
				      if (!change_remote_dir(curr->name,0)) {
d144 1
a144 1
				      DownloadFile(FileList,NULL,TransferMode,0);
a259 4
	  case WMHI_VANILLAKEY:
	    if (code==0x1B)
	      done=TRUE;
	    break;
d266 1
d367 1
d373 1
a489 13
#if 0
                           StartMember, MG_List[MG_FreeDisk]=ButtonObject,
                             GA_ID, MG_FreeDisk,
                             GA_Text, "%ld %s free",
                             GA_ReadOnly, TRUE, 
                             BUTTON_BevelStyle, BVS_NONE,
                             BUTTON_Transparent, TRUE,
                             BUTTON_VarArgs, &freeargs,
                             BUTTON_Justification, BCJ_RIGHT,
                             ButtonEnd,
                             CHILD_WeightedWidth,0,
                             CHILD_WeightedHeight,0,
#endif
a494 1
#if 1
a555 69
#else
                       EndGroup,
                       EndGroup, CHILD_WeightedWidth,100, 
    
                       LAYOUT_AddImage, BevelObject, 
                         BEVEL_Style, BVS_SBAR_HORIZ,
                       BevelEnd, CHILD_WeightedWidth,0,

                       StartVGroup, EvenSized, 
	                 StartMember, MG_List[MG_Connect]=ButtonObject,
	                   GA_Text,GetAmiFTPString(MW_Connect),
	                   GA_ID, MG_Connect,
	                   GA_RelVerify, TRUE,
	                 ButtonEnd,
                         CHILD_WeightedHeight,0,

	                 StartMember, MG_List[MG_Disconnect]=ButtonObject,
	                   GA_Text,GetAmiFTPString(MW_Disconnect),
	                   GA_ID, MG_Disconnect,
	                   GA_RelVerify, TRUE,
                           GA_Disabled,TRUE,
	                 ButtonEnd,
                         CHILD_WeightedHeight,0,

                         LAYOUT_AddChild, pagelayout=LayoutObject,
                         LAYOUT_AddChild,MG_List[MG_Page2]=PageObject,
                         PAGE_Add, LayoutObject,
  	                   StartMember, MG_List[MG_Parent]=ButtonObject,
	                     GA_Text,GetAmiFTPString(MW_Parent),
	                     GA_ID, MG_Parent,
	                     GA_RelVerify, TRUE,
                             GA_Disabled,TRUE,
	                   ButtonEnd,
                         LayoutEnd,
                         PAGE_Add, LayoutObject,
                           StartMember, MG_List[MG_Readme]=ButtonObject,
	                     GA_Text,GetAmiFTPString(MW_ViewReadme),
	                     GA_ID, MG_Readme,
	                     GA_RelVerify, TRUE,
                             GA_Disabled,TRUE,
	                   ButtonEnd,
                         LayoutEnd,
                         LayoutEnd,
                         LayoutEnd,
                         CHILD_WeightedHeight,0,

	                 StartMember, MG_List[MG_Get]=ButtonObject,
	                   GA_Text,GetAmiFTPString(MW_Get),
	                   GA_ID, MG_Get,
	                   GA_RelVerify, TRUE,
                           GA_Disabled,TRUE,
	                 ButtonEnd,
                         CHILD_WeightedHeight,0,
	                 StartMember, MG_List[MG_Put]=ButtonObject,
	                   GA_Text,GetAmiFTPString(MW_Put),
	                   GA_ID, MG_Put,
	                   GA_RelVerify, TRUE,
                           GA_Disabled,TRUE,
	                 ButtonEnd,
                         CHILD_WeightedHeight,0,
	                 StartMember, MG_List[MG_View]=ButtonObject,
	                   GA_Text,GetAmiFTPString(MW_View),
	                   GA_ID, MG_View,
	                   GA_RelVerify, TRUE,
                           GA_Disabled,TRUE,
	                 ButtonEnd,
                         CHILD_WeightedHeight,0,
                       EndGroup, CHILD_WeightedWidth,0,
#endif
d561 1
d564 1
d568 1
a572 1
//    freeargs[0]=0;
d576 4
a579 4
                       WA_PubScreen,Screen,
                       WA_SizeGadget,TRUE,
                       WA_SizeBBottom,TRUE,
                       WA_Top,CurrentState.TopEdge?CurrentState.TopEdge:MainPrefs.mp_TopEdge-Screen->ViewPort.DyOffset,
d581 4
a584 4
                       WA_InnerHeight,MainPrefs.mp_Height,
                       WA_InnerWidth,MainPrefs.mp_Width,
                       WA_DepthGadget,TRUE,
                       WA_DragBar,TRUE,
d586 6
a591 6
                       WA_Activate,TRUE,
                       WA_SmartRefresh,TRUE,
                       WA_MenuHelp,TRUE,
                       WA_IDCMP,IDCMP_MENUHELP|IDCMP_VANILLAKEY,
                       WINDOW_IconifyGadget,TRUE,
                       WINDOW_IconTitle,"AmiFTP",
d593 1
a593 1
                       WINDOW_AppPort,AppPort,
a596 1
//                       WINDOW_InterpretUserData, WGUD_FUNC,
d598 1
a598 1
                       WINDOW_IDCMPHookBits,IDCMP_RAWKEY|IDCMP_GADGETUP,
d606 1
d616 1
a616 5
	UnlockPubScreen(NULL,Screen);
#if 0
	if (SetAttrs(MG_List[MG_FreeDisk], BUTTON_VarArgs, &freeargs, TAG_DONE))
	  RefreshGList(MG_List[MG_FreeDisk], MainWindow, NULL, 1);
#endif
d619 2
a620 2
//    Printf("CA_OpenWindow() failed\n");
    UnlockPubScreen(NULL,Screen);
d662 1
a662 10
int menu_Iconify(void);
int menu_ClearCache(void);
int menu_HostlistPrefs(void);
int menu_BinaryTransferMode(struct MenuItem *menuitem);
int menu_AsciiTransferMode(struct MenuItem *menuitem);
int menu_LogWindow(void);
int ToggleDotFiles(void);
int menu_ToggleADT(struct MenuItem *menuitem);
int menu_ResetADT(void);
int AddToSitelist(void);
d664 1
a664 2
#include "Menu.h"
int prev_state=MB_DISCONNECTED;
a667 3
/*    if (!MainWindow)
      return;
*/
d676 1
a676 2
	    if (SetGadgetAttrs(MG_List[MG_Readme],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE) && MainWindow)
	      RefreshGList(MG_List[MG_Readme],MainWindow,NULL,1);
d679 1
a679 2
	    if (SetGadgetAttrs(MG_List[MG_Parent],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE) && MainWindow)
	      RefreshGList(MG_List[MG_Parent],MainWindow,NULL,1);
d681 7
a687 14
	if (SetGadgetAttrs(MG_List[MG_Get],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_Get],MainWindow,NULL,1);
	if (SetGadgetAttrs(MG_List[MG_Put],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_Put],MainWindow,NULL,1);
	if (SetGadgetAttrs(MG_List[MG_Disconnect],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_Disconnect],MainWindow,NULL,1);
	if (SetGadgetAttrs(MG_List[MG_DirName],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_DirName],MainWindow,NULL,1);
	if (SetGadgetAttrs(MG_List[MG_Reload],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_Reload],MainWindow,NULL,1);
	if (SetGadgetAttrs(MG_List[MG_View],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_View],MainWindow,NULL,1);
	if (SetGadgetAttrs(MG_List[MG_ListView],MainWindow,NULL,
			   LISTBROWSER_Labels,&dummy_list,
d689 1
a689 1
	  RefreshGList(MG_List[MG_ListView],MainWindow,NULL,1);
d694 3
a696 6
	    if (SetGadgetAttrs(MG_List[MG_Readme],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE) && MainWindow)
	      RefreshGList(MG_List[MG_Readme],MainWindow,NULL,1);
	    if (SetGadgetAttrs(MG_List[MG_DirName],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE) && MainWindow)
	      RefreshGList(MG_List[MG_DirName],MainWindow,NULL,1);
	    if (SetGadgetAttrs(MG_List[MG_Reload],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE) && MainWindow)
	      RefreshGList(MG_List[MG_Reload],MainWindow,NULL,1);
d699 8
a706 15
	    if (SetGadgetAttrs(MG_List[MG_Parent],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE) && MainWindow)
	      RefreshGList(MG_List[MG_Parent],MainWindow,NULL,1);
	    if (SetGadgetAttrs(MG_List[MG_DirName],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE) && MainWindow)
	      RefreshGList(MG_List[MG_DirName],MainWindow,NULL,1);
	    if (SetGadgetAttrs(MG_List[MG_Reload],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE) && MainWindow)
	      RefreshGList(MG_List[MG_Reload],MainWindow,NULL,1);
	}
	if (SetGadgetAttrs(MG_List[MG_Get],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_Get],MainWindow,NULL,1);
	if (SetGadgetAttrs(MG_List[MG_Put],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_Put],MainWindow,NULL,1);
	if (SetGadgetAttrs(MG_List[MG_Disconnect],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_Disconnect],MainWindow,NULL,1);
	if (SetGadgetAttrs(MG_List[MG_View],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_View],MainWindow,NULL,1);
d711 3
a713 6
	    if (SetGadgetAttrs(MG_List[MG_Readme],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE) && MainWindow)
	      RefreshGList(MG_List[MG_Readme],MainWindow,NULL,1);
	    if (SetGadgetAttrs(MG_List[MG_DirName],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE) && MainWindow)
	      RefreshGList(MG_List[MG_DirName],MainWindow,NULL,1);
	    if (SetGadgetAttrs(MG_List[MG_Reload],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE) && MainWindow)
	      RefreshGList(MG_List[MG_Reload],MainWindow,NULL,1);
d716 8
a723 15
	    if (SetGadgetAttrs(MG_List[MG_Parent],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE) && MainWindow)
	      RefreshGList(MG_List[MG_Parent],MainWindow,NULL,1);
	    if (SetGadgetAttrs(MG_List[MG_DirName],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE) && MainWindow)
	      RefreshGList(MG_List[MG_DirName],MainWindow,NULL,1);
	    if (SetGadgetAttrs(MG_List[MG_Reload],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE) && MainWindow)
	      RefreshGList(MG_List[MG_Reload],MainWindow,NULL,1);
	}
	if (SetGadgetAttrs(MG_List[MG_Get],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_Get],MainWindow,NULL,1);
	if (SetGadgetAttrs(MG_List[MG_Put],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_Put],MainWindow,NULL,1);
	if (SetGadgetAttrs(MG_List[MG_Disconnect],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_Disconnect],MainWindow,NULL,1);
	if (SetGadgetAttrs(MG_List[MG_View],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_View],MainWindow,NULL,1);
d729 1
d734 7
a740 6
	if (SetGadgetAttrs(MG_List[MG_ListView],MainWindow,NULL,
			   LISTBROWSER_Labels,FileList,
			   NoneSelected?LISTBROWSER_AutoFit:TAG_IGNORE,TRUE,
			   NoneSelected?LISTBROWSER_Selected:TAG_IGNORE,-1,
			   NoneSelected?LISTBROWSER_MakeVisible:TAG_IGNORE,0,TAG_DONE))
	  RefreshGList(MG_List[MG_ListView],MainWindow,NULL,1);
d744 5
a748 4
	       LISTBROWSER_Labels,FileList,
	       NoneSelected?LISTBROWSER_AutoFit:TAG_IGNORE,TRUE,
	       NoneSelected?LISTBROWSER_Selected:TAG_IGNORE,-1,
	       NoneSelected?LISTBROWSER_MakeVisible:TAG_IGNORE,0,TAG_DONE);
d755 5
a759 3
      if (SetGadgetAttrs(MG_List[MG_ListView],MainWindow,NULL,
			 LISTBROWSER_Labels,~0,LISTBROWSER_AutoFit,TRUE,TAG_DONE))
	RefreshGList(MG_List[MG_ListView],MainWindow,NULL,1);
d761 1
a761 1
      SetAttrs(MG_List[MG_ListView],LISTBROWSER_Labels,~0,TAG_DONE);
d768 1
a768 1
	strncpy(CurrentState.CurrentRemoteDir,dir,255);
d770 4
a773 2
	if (SetGadgetAttrs(MG_List[MG_DirName],MainWindow,NULL,STRINGA_TextVal,dir,TAG_END))
	  RefreshGList(MG_List[MG_DirName],MainWindow,NULL,1);
d781 1
a781 1
      strncpy(CurrentState.CurrentDLDir,dir,255);
d783 4
a786 2
	if (SetGadgetAttrs(MG_List[MG_DLString],MainWindow,NULL,STRINGA_TextVal,dir,TAG_END))
	    RefreshGList(MG_List[MG_DLString],MainWindow,NULL,1);
d794 1
a794 1
      strncpy(CurrentState.CurrentSite,site,50);
d796 4
a799 302
	if (SetGadgetAttrs(MG_List[MG_SiteName],MainWindow,NULL,STRINGA_TextVal,site,TAG_END))
	    RefreshGList(MG_List[MG_SiteName],MainWindow,NULL,1);
    }
}

int menu_Quit(void)
{
    geta4();
    return 0;
}

int menu_SortByName(struct MenuItem *menuitem)
{
    SortMode=SORTBYNAME;

    ClearMenuStrip(MainWindow);
    menuitem->Flags|=CHECKED;
    ResetMenuStrip(MainWindow, menu);

    if (FileList && !CurrentState.ADTMode) {
	LockWindow(MainWin_Object);
	DetachToolList();
	FileList=sort_filelist(FileList, SORTBYNAME, ASCENDING);
	AttachToolList(FALSE);
	UnlockWindow(MainWin_Object);
    }
    else if (FileList) {
	LockWindow(MainWin_Object);
	DetachToolList();
	FileList=sort_ADT(FileList, SORTBYNAME);
	AttachToolList(FALSE);
	UnlockWindow(MainWin_Object);
    }
    return 1;
}

int menu_SortByDate(struct MenuItem *menuitem)
{
    SortMode=SORTBYDATE;

    ClearMenuStrip(MainWindow);
    menuitem->Flags|=CHECKED;
    ResetMenuStrip(MainWindow, menu);

    if (FileList && !CurrentState.ADTMode) {
	LockWindow(MainWin_Object);
	DetachToolList();
	FileList=sort_filelist(FileList, SORTBYDATE, DESCENDING);
	AttachToolList(FALSE);
	UnlockWindow(MainWin_Object);
    }
    else if (FileList) {
	LockWindow(MainWin_Object);
	DetachToolList();
	FileList=sort_ADT(FileList, SORTBYDATE);
	AttachToolList(FALSE);
	UnlockWindow(MainWin_Object);
    }
    return 1;
}


int menu_Iconify()
{
    if (CA_Iconify(MainWin_Object))
      MainWindow=NULL;
    return 2;
}

int menu_SelectAll()
{
    struct Node *node;
    ULONG n=0,flags;

    /* Fix disconnect/connect of listview */
    if (FileList) {
	for (node=GetHead(FileList);node;node=GetSucc(node)) {
	    GetListBrowserNodeAttrs(node, LBNA_Flags, &flags, TAG_DONE);
	    if (!(flags&LBFLG_HIDDEN)) {
		SetListBrowserNodeAttrs(node,
					LBNA_Selected, TRUE,
					TAG_DONE);
		n=1;
	    }
	}
	if (n)
	  RefreshGList(MG_List[MG_ListView], MainWindow, NULL, 1);
	if (GetHead(FileList))
	    UpdateMainButtons(MB_FILESELECTED);
    }
    UpdateWindowTitle();
    return 1;
}

int menu_UnselectAll()
{
    struct Node *node;
    ULONG n=0;

    /* Fix: Add disconnect/connect of listview */
    if (FileList) {
	for (node=GetHead(FileList);node;node=GetSucc(node)) {
	    SetListBrowserNodeAttrs(node,
				    LBNA_Selected, FALSE,
				    TAG_DONE);
	    n=1;
	}
	if (n)
	  RefreshGList(MG_List[MG_ListView], MainWindow, NULL, 1);
	UpdateMainButtons(MB_NONESELECTED);
    }
    UpdateWindowTitle();
    return 1;
}

int menu_Delete()
{
    struct dirlist *curr;
    struct Node *node,*nnode;
    int t=0;
    int sel=0;
    static ULONG tags[]={
	RTEZ_ReqTitle, NULL,
	RT_Window, NULL,
	RT_LockWindow, TRUE,
	RT_ReqPos, REQPOS_CENTERWIN,
	TAG_END};

    tags[1]=(ULONG)GetAmiFTPString(Str_AmiFTPRequest);
    tags[3]=(ULONG)MainWindow;
    if (FileList) {
	LockWindow(MainWin_Object);
	if (!rtEZRequest(GetAmiFTPString(MW_DeleteRequest),GetAmiFTPString(MW_DeleteCancel),NULL,(struct TagItem *)tags)) {
	    UnlockWindow(MainWin_Object);
	    return 1;
	}
	node=GetHead(FileList);
	while (node) {
	    nnode=GetSucc(node);
	    sel=0;
	    GetListBrowserNodeAttrs(node,LBNA_Selected,&sel,TAG_DONE);
	    if (sel) {
		curr=(void *)node->ln_Name; /* The dirlist-structure is in ln_Name */
		if (curr) {
		    if (!S_ISDIR(curr->mode)) {
			if (delete_remote(curr->name,"DELE")) {
			    LBRemNode(MG_List[MG_ListView], MainWindow, NULL, node);
			    free_direntry(curr);
			}
			else {
			    t=1;
			}
		    }
		    else {
			if (delete_remote(curr->name, "RM")) {
			    LBRemNode(MG_List[MG_ListView], MainWindow, NULL, node);
			    free_direntry(curr);
			}
			else {
			    t=1;
			}
		    }
		}
	    }
	    node=nnode;
	}
	if (t==0)
	  UpdateMainButtons(MB_NONESELECTED);
	UnlockWindow(MainWin_Object);
    }
    UpdateWindowTitle();
    return 1;
}

int menu_Move(void)
{
    return 1;
}

int menu_ClearCache(void)
{
    ClearCache(FALSE);
    return 1;
}

int menu_HostlistPrefs(void)
{
    LockWindow(MainWin_Object);
    OpenSiteListWindow(FALSE);
    UnlockWindow(MainWin_Object);
    return 1;
}

int menu_BinaryTransferMode(struct MenuItem *menuitem)
{
    if (TransferMode!=BINARY) {
	TransferMode=BINARY;
	ClearMenuStrip(MainWindow);
	menuitem->Flags|=CHECKED;
	ResetMenuStrip(MainWindow, menu);
    }
    return 1;
}

int menu_AsciiTransferMode(struct MenuItem *menuitem)
{
    if (TransferMode!=ASCII) {
	TransferMode=ASCII;
	ClearMenuStrip(MainWindow);
	menuitem->Flags|=CHECKED;
	ResetMenuStrip(MainWindow, menu);
    }
    return 1;
}

int menu_ResetADT(void)
{
    MainPrefs.mp_LastAminetDate=0;
    MainPrefs.mp_LastAMOTD=0;
    return 1;
}

int menu_ToggleADT(struct MenuItem *menuitem)
{
    struct Node *node;
    ULONG attr;

    if (!CurrentState.ADTMode)
      return 1;

    if (menuitem) {
	if (menuitem->Flags&CHECKED) {
	    if (FileList) {
		DetachToolList();
		node=GetTail(FileList);
		if (node->ln_Name==NULL) {
		    Remove(node);
		    FreeListBrowserNode(node);
		}
		for (node=GetHead(FileList);node;node=GetSucc(node)) {
		    SetListBrowserNodeAttrs(node,LBNA_Flags,LBFLG_CUSTOMPENS,TAG_DONE);
		}
		if (SetGadgetAttrs(MG_List[MG_ListView], MainWindow, NULL,
				   LISTBROWSER_Labels, FileList,
				   LISTBROWSER_AutoFit, TRUE,
				   LISTBROWSER_MakeVisible, 0, TAG_DONE))
		  RefreshGList(MG_List[MG_ListView], MainWindow, NULL, 1);
//		AttachToolList(FALSE);
	    }
	    MainPrefs.mp_ShowAllADTFiles=TRUE;
	}
	else {
	    if (FileList) {
		DetachToolList();
		for (node=GetHead(FileList);node;node=GetSucc(node)) {
		    struct dirlist *n=(struct dirlist *)node->ln_Name;
		    if (!n->new || n->hide) {
			SetListBrowserNodeAttrs(node,
						LBNA_Flags,LBFLG_CUSTOMPENS|LBFLG_HIDDEN,
						LBNA_Selected,FALSE,TAG_DONE);
		    }
		}
		for (node=GetHead(FileList);node;node=GetSucc(node)) {
		    ULONG flags;
		    GetListBrowserNodeAttrs(node,LBNA_Flags, &flags, TAG_DONE);
		    if (!(flags&LBFLG_HIDDEN))
		      break;
		}
		if (!node) {
		    node=AllocListBrowserNode(6,
					      LBNA_Column, 0,
					      LBNCA_Text, GetAmiFTPString(Str_NoNewAminetFiles),
					      LBNA_Column, 1,
					      LBNCA_Text, "",
					      LBNA_Column, 2,
					      LBNCA_Text, "",
					      LBNA_Column, 3,
					      LBNCA_Text, "",
					      LBNA_Column, 4,
					      LBNCA_Text, "",
					      LBNA_Column, 5,
					      LBNCA_Text, "",
					      TAG_DONE);
		    if (node)
		      AddTail(FileList,node);
    }
		if (SetGadgetAttrs(MG_List[MG_ListView], MainWindow, NULL,
				   LISTBROWSER_Labels, FileList,
				   LISTBROWSER_AutoFit, TRUE,
				   LISTBROWSER_MakeVisible, 0, TAG_DONE))
		  RefreshGList(MG_List[MG_ListView], MainWindow, NULL, 1);
//		AttachToolList(FALSE);
		GetAttr(LISTBROWSER_Selected,MG_List[MG_ListView],&attr);
		if (attr) {
		    UpdateMainButtons(MB_FILESELECTED);
		}
		else {
		    UpdateMainButtons(MB_NONESELECTED);
		}
	    }
	    MainPrefs.mp_ShowAllADTFiles=FALSE;
	}
a800 89
    UpdateWindowTitle();
    return 1;
}

int BuildMenu()
{
    struct NewMenu *NewMenu;
    struct Menu *MenuNew;

    long Count=0,SiteCount=0;
    struct SiteNode *ptr;
    struct Node *lbn;

    while(mainmenus[Count++].nm_Type!=NM_END);

    for (lbn=GetHead(&SiteList);lbn;lbn=GetSucc(lbn)) {
	GetListBrowserNodeAttrs(lbn,
				LBNA_UserData,&ptr,
				TAG_DONE);
	if (ptr) {
	    if (ptr->sn_HotList)
	      SiteCount++;
	}
    }

    if (NewMenu = (struct NewMenu *)AllocVec((Count + SiteCount) * sizeof(struct NewMenu),MEMF_ANY|MEMF_CLEAR)) {
	extern BPTR LogWindow;
	mainmenus[15].nm_Flags=CHECKIT|(TransferMode==BINARY?CHECKED:NULL);
	mainmenus[16].nm_Flags=CHECKIT|(TransferMode==ASCII?CHECKED:NULL);
	mainmenus[22].nm_Flags=CHECKIT|(SortMode==SORTBYNAME?CHECKED:NULL);
	mainmenus[23].nm_Flags=CHECKIT|(SortMode==SORTBYDATE?CHECKED:NULL);
	mainmenus[28].nm_Flags=CHECKIT|MENUTOGGLE|(LogWindow?CHECKED:NULL);
	mainmenus[29].nm_Flags=CHECKIT|MENUTOGGLE|(MainPrefs.mp_Showdotfiles?CHECKED:NULL);
	mainmenus[30].nm_Flags=CHECKIT|MENUTOGGLE|(MainPrefs.mp_ShowAllADTFiles?CHECKED:NULL);

	CopyMem(mainmenus,NewMenu,Count * sizeof(struct NewMenu));
	if (SiteCount) {
	    Count--;
	    SiteCount=0;
	    for (lbn=GetHead(&SiteList);lbn;lbn=GetSucc(lbn)) {
		GetListBrowserNodeAttrs(lbn,
					LBNA_UserData, &ptr,
					TAG_DONE);
		if (ptr) {
		    if (ptr->sn_HotList) {
			if (ptr->sn_MenuType==SLN_CHILD)
			  NewMenu[Count].nm_Type=NM_SUB;
			else 
			  NewMenu[Count].nm_Type=NM_ITEM;

			if (ptr->sn_BarLabel)
			  NewMenu[Count].nm_Label=NM_BARLABEL;
			else
			  NewMenu[Count].nm_Label=ptr->sn_Node.ln_Name;
			NewMenu[Count].nm_UserData=(void *)(SiteCount+1);
			SiteCount++;
			Count++;
		    }
		}
	    }
	    NewMenu[Count].nm_Type=NM_END;
	}
	else
	  NewMenu[Count-2].nm_Type=NM_END;
	if (!(MenuNew = CreateMenus(NewMenu,TAG_DONE))) {
	    FreeVec(NewMenu);
	    return 0;
	    
	}
	if (!LayoutMenus(MenuNew,VisualInfo,GTMN_NewLookMenus,TRUE,TAG_DONE)) {
	    FreeMenus(MenuNew);
	    FreeVec(NewMenu);
	    return 0;
	}
	FreeVec(NewMenu);
	menu=MenuNew;

	return 1;
    }
    else return 0;
}

void UpdateMenus(void)
{
    struct Menu *oldmenu=menu;
    if (!BuildMenu())
      return;
    FreeMenus(oldmenu);
    SetAttrs(MainWin_Object,WINDOW_MenuStrip,menu,TAG_DONE);
a808 1
//	     GA_ReadOnly, TRUE,
a815 1
//	     GA_ReadOnly, FALSE,
d851 1
a851 1
	  ResetMenuStrip(MainWindow,menu);
d872 1
a872 1
    RefreshGList(pagelayout, MainWindow,NULL,1);
a946 1
//	    RefreshGList(MG_List[MG_ListView], MainWindow, NULL, 1);
@


1.607
log
@Cursor up in sitelistwindow works now.
Fixed closing of sitelist-window when the edit-window was opened,
this is probably a CA-bug.
@
text
@d1 2
a2 2
/* RCS Id: $Id: MainWindow.c 1.595 1996/06/18 23:19:14 lilja Exp lilja $
   Locked version: $Revision: 1.595 $
d58 1
d268 4
d307 16
d679 1
a679 1
                       WA_IDCMP,IDCMP_MENUHELP,
d1455 13
@


1.595
log
@Fixed something.
,
@
text
@d1 2
a2 2
/* RCS Id: $Id$
   Locked version: $Revision$
d644 1
@


1.587
log
@currentsite-string can now be 99 chars.
@
text
@d1 4
d1301 1
a1301 1
	     GA_ReadOnly, TRUE,
d1309 1
a1309 1
	     GA_ReadOnly, FALSE,
@


1.585
log
@Changed the parsing of the command line site.
ESC now closes all windows but connect- and transferwindow.
RETURN connects to the current site.
Using the Exec-list functions/macros.
New windowtitle, now with # of files selected and more.
@
text
@d417 1
a417 1
	                   STRINGA_MaxChars, 40,
@


1.541
log
@Fixed bug in UnlockWindow().
@
text
@d284 1
a352 1

d672 1
d679 1
d739 1
a740 1
int AddToSitelist(void);
d749 1
d878 1
d889 1
a889 1
//    UpdateFreeSpace();
d958 1
d987 1
d1008 1
a1008 1

d1067 1
a1072 1
    
d1200 1
d1365 1
a1365 5
struct Hook IDCMPHook;

ULONG __asm __saveds IDCMPHookFunc(register __a0 struct Hook *hook,
					  register __a2 Object *WinObj,
					  register __a1 struct IntuiMessage *msg)
d1367 7
a1373 5
    extern Object *TransferWin_Object;
    extern Object *EditSiteWin_Object;
    extern Object *MainPrefsWin_Object;
    extern Object *ConnectWin_Object;
    extern Object *AboutWin_Object;
d1375 23
a1397 15
    switch (msg->Class) {
      case IDCMP_RAWKEY:
	switch (msg->Code) {
	  case 95:
	    if (WinObj==TransferWin_Object)
	      SendAGMessage(AG_TRANSWIN);
	    else if (WinObj==EditSiteWin_Object)
	      SendAGMessage(AG_SITECONF);
	    else if (WinObj==MainPrefsWin_Object)
	      SendAGMessage(AG_GLOBPREFS);
	    else if (WinObj==ConnectWin_Object)
	      SendAGMessage(AG_CONNECTWIN);
	    else if (WinObj==AboutWin_Object)
	      SendAGMessage(AG_ABOUTWIN);
	    break;
a1398 1
	break;
a1399 2
    return 0;
}
d1401 21
a1421 21
#if 0
static void UpdateFreeSpace(void)
{
    struct InfoData info;
    long size;
    char *by;
    Printf("Updating\n");
    if (!getdfs(0, &info)) {
	size=(info.id_NumBlocks - info.id_NumBlocksUsed)*info.id_BytesPerBlock;
	if (size < 1000000) {
	    size/=1024;
	    by="KB";
	}
	else if (size < 1000000000) {
	    size/=(1024*1024);
	    by="MB";
	}
	freeargs[0]=size;
	freeargs[1]=by;
	if (SetAttrs(MG_List[MG_FreeDisk], BUTTON_VarArgs, &freeargs[0], TAG_DONE)) 
	  RefreshGList(MG_List[MG_FreeDisk], MainWindow, NULL, 1);
d1423 5
a1428 1
#endif
@


1.531
log
@Lots of stuff
@
text
@d1333 6
a1338 2

	ResetMenuStrip(MainWindow,menu);
@


1.430
log
@Fixed name/date-sorting in ADT-mode.
@
text
@d3 1
d12 2
a13 2
struct TextAttr AmiFTPAttr = {NULL,0,FS_NORMAL,FPF_PROPORTIONAL};
struct TextAttr ListViewAttr = {NULL,0,FS_NORMAL,FPF_PROPORTIONAL};
d31 6
a36 6
    {0,"Name",0},
    {0,"Size",0},
    {0,"Type",0},
    {0,"Date",0},
    {0,"Owner",0},
    {0,"Group",0},
d52 3
d59 1
d269 12
d302 51
d409 3
a411 1

d474 13
d492 1
d554 69
d633 5
a637 1

d658 2
d679 4
d731 2
a732 2
int menu_BinaryTransferMode(void);
int menu_AsciiTransferMode(void);
d885 1
d904 1
a904 1
int menu_SortByName(void)
d906 6
d915 1
a915 1
	FileList=sort_filelist(FileList,SORTBYNAME,ASCENDING);
d929 1
a929 1
int menu_SortByDate(void)
d931 6
d940 1
a940 1
	FileList=sort_filelist(FileList,SORTBYDATE,DESCENDING);
d969 1
a969 1
	    GetListBrowserNodeAttrs(node,LBNA_Flags,&flags,TAG_DONE);
d972 1
a972 1
					LBNA_Selected,TRUE,
d978 1
a978 1
	  RefreshGList(MG_List[MG_ListView],MainWindow,NULL,1);
d994 1
a994 1
				    LBNA_Selected,FALSE,
d999 1
a999 1
	  RefreshGList(MG_List[MG_ListView],MainWindow,NULL,1);
d1012 6
a1017 1
    static ULONG tags[]={RTEZ_ReqTitle,NULL,RT_Window,NULL,RT_LockWindow,TRUE,RT_ReqPos,REQPOS_CENTERWIN,TAG_END};
a1036 2
			    /* Fix: Add disconnect/connect of listview */
			    kprintf("foo\n");
a1037 3
			    kprintf("bar\n");
/*			    DetachToolList(); 
			    Remove(node);*/
d1039 9
a1047 2
/*			    FreeListBrowserNode(node);
			    AttachToolList(FALSE);*/
d1084 1
a1084 1
int menu_BinaryTransferMode(void)
d1086 6
a1091 1
    TransferMode=BINARY;
d1095 1
a1095 1
int menu_AsciiTransferMode(void)
d1097 6
a1102 1
    TransferMode=ASCII;
a1159 1
		    extern char *nonewfiles;
d1161 12
a1172 12
					      LBNA_Column,0,
					      LBNCA_Text,nonewfiles,
					      LBNA_Column,1,
					      LBNCA_Text,"",
					      LBNA_Column,2,
					      LBNCA_Text,"",
					      LBNA_Column,3,
					      LBNCA_Text,"",
					      LBNA_Column,4,
					      LBNCA_Text,"",
					      LBNA_Column,5,
					      LBNCA_Text,"",
d1220 4
a1223 2
	mainmenus[15].nm_Flags=CHECKIT|MENUTOGGLE|(TransferMode==BINARY?CHECKED:NULL);
	mainmenus[16].nm_Flags=CHECKIT|MENUTOGGLE|(TransferMode==ASCII?CHECKED:NULL);
d1286 2
d1289 2
a1290 2
	     WA_BusyPointer,TRUE,
	     GA_ReadOnly,TRUE,
d1297 2
a1298 2
	     WA_BusyPointer,FALSE,
	     GA_ReadOnly,FALSE,
d1300 1
a1300 1
    /* Workaround for window.class-bug */
d1302 1
a1302 1
	struct Menu *mmenu=menu->NextMenu;
a1303 2
	mmenu=mmenu->NextMenu;
	mmenu=mmenu->NextMenu;
d1306 29
a1334 15
	if (menuitem) {
	    while ((void *)GTMENUITEM_USERDATA(menuitem)!=(void *)&menuhooks[16]) {
		menuitem=menuitem->NextItem;
		if (!menuitem) break;
	    }
	    if (menuitem) {
		ClearMenuStrip(MainWindow);
		menuitem->Flags|=LogWindow?CHECKED:NULL;
		if (menuitem=menuitem->NextItem)
		  menuitem->Flags|=MainPrefs.mp_Showdotfiles?CHECKED:NULL;
		if (menuitem=menuitem->NextItem)
		  menuitem->Flags|=MainPrefs.mp_ShowAllADTFiles?CHECKED:NULL;
		ResetMenuStrip(MainWindow,menu);
	    }
	}
d1336 1
a1340 10
/*    if (CurrentState.ADTMode) {
	if (SetGadgetAttrs(MG_List[MG_DirName],MainWindow,NULL,
			   GA_ReadOnly,TRUE,TAG_DONE))
	  RefreshGList(MG_List[MG_DirName],MainWindow,NULL,1);
    }
    else {
	if (SetGadgetAttrs(MG_List[MG_DirName],MainWindow,NULL,
			   GA_ReadOnly,FALSE,TAG_DONE))
	  RefreshGList(MG_List[MG_DirName],MainWindow,NULL,1);
    }*/
d1387 24
@


1.401
log
@Started on improving the functionnames.
Added Aminet-mode, not 100% finished yet.
Reworked the prefs-window, not everything is finished.
Started using listbrowser v41-functions.
Added parsing of URL-like commandline.
@
text
@d576 1
a576 104
struct CallBackHook menuhooks[]={
    {Reconnect,AG_MENURECONNECT},
    {AddToSitelist,AG_MENUADDTOSITELIST},
    {menu_ResetADT,AG_MENURESETADT},
    {menu_Iconify,AG_MENUICONIFY},
    {About,AG_MENUABOUT},
    {menu_Quit,AG_MENUQUIT},
    {menu_SelectAll,AG_MENUTAGALL},
    {menu_UnselectAll,AG_MENUUNTAGALL},
    {menu_BinaryTransferMode,AG_MENUTRANSFERMODE},
    {menu_AsciiTransferMode,AG_MENUTRANSFERMODE},
    {menu_ClearCache,AG_MENUCLEARCACHE},
    {menu_Delete,AG_MENUDELETE},
    {menu_SortByName,AG_MENUSORT},
    {menu_SortByDate,AG_MENUSORT},
    {OpenPrefsWindow,AG_MENUGLOBAL},
    {menu_HostlistPrefs,AG_MENUSITELIST},
    {menu_LogWindow,AG_MENULOGWINDOW},
    {ToggleDotFiles,AG_MENUTOGGLEDOT},
    {menu_ToggleADT,AG_MENUTOGGLEADT},
    {LoadPrefs,AG_MENULOADSETTINGS},
    {SavePrefs,AG_MENUSAVESETTINGS},
    {SavePrefsAs,AG_MENUSAVESETTINGS}
};

struct NewMenu mainmenus[] = 
{
    {NM_TITLE, NULL, NULL,0,~0,NULL},                    /* Project */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[0]},/*Reconnect},         * Reconnect */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[1]}, /* Add to sitelist */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[2]},
    {NM_ITEM,    NM_BARLABEL,NULL,0,~0,NULL},
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[3]},      /* Iconify */
    {NM_ITEM,    NM_BARLABEL,NULL,0,~0,NULL},
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[4]},            /* About */
    {NM_ITEM,    NM_BARLABEL,NULL,0,~0,NULL},
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[5]},        /* Quit */
    {NM_TITLE, NULL,NULL,0,~0,NULL},                     /* Files */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[6]},   /* Tag all */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[7]}, /* Untag all */
    {NM_ITEM,    NM_BARLABEL,NULL,0,~0,NULL},
    {NM_ITEM,    NULL,NULL,0,~0,NULL},                    /* Transfer mode */
    {NM_SUB,     NULL,NULL,CHECKIT,~1,&menuhooks[8]}, /* Binary */
    {NM_SUB,     NULL,NULL,0,~2,&menuhooks[9]},  /* ASCII */
    {NM_ITEM,    NM_BARLABEL,NULL,0,~0,NULL},
    {NM_ITEM,    NULL,NULL,0,~0,&menuhooks[10]},         /* Clear cache */
    {NM_ITEM,    NM_BARLABEL,NULL,0,~0,NULL},
    {NM_ITEM,    NULL,NULL,0,~0,(APTR) &menuhooks[11]},      /* Delete */
/*    {NM_ITEM,    "Move","M",0,~0,(APTR) &menuhooks[9]},*/
    {NM_TITLE, NULL,NULL,0,~0,NULL},                     /* Sort */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[12]},
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[13]},
    {NM_TITLE, NULL,NULL,0,~0,NULL},                     /* Settings */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[14]},
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[15]},
    {NM_ITEM,    NM_BARLABEL,NULL,0,~0,NULL},
    {NM_ITEM,    NULL,NULL,CHECKIT|MENUTOGGLE,0,(APTR)&menuhooks[16]}, /* Log window */
    {NM_ITEM,    NULL,NULL,CHECKIT|MENUTOGGLE,0,(APTR)&menuhooks[17]}, /* Log window */
    {NM_ITEM,    NULL,NULL,CHECKIT|MENUTOGGLE,0,(APTR)&menuhooks[18]}, /* Log window */
    {NM_ITEM,    NM_BARLABEL,NULL,0,~0,NULL},
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[19]},                   /* Load settings... */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[20]},                   /* Save settings */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[21]},                   /* Save settings as...*/
    {NM_TITLE, NULL,NULL,0,~0,NULL},                     /* HotList */
    {NM_END}
};

LONG MenuLabels[] =
{
    (LONG)MENU_Project,
    (LONG)MENU_Reconnect,
    (LONG)MENU_AddToSiteList,
    (LONG)MENU_ResetADT,
    (LONG)MENU_Iconify,
    (LONG)MENU_About,
    (LONG)MENU_Quit,

    (LONG)MENU_Files,
    (LONG)MENU_TagAll,
    (LONG)MENU_UntagAll,
    (LONG)MENU_TransferMode,
    (LONG)MENU_Binary,
    (LONG)MENU_ASCII,
    (LONG)MENU_ClearCache,
    (LONG)MENU_Delete,
    /*MENU_Move,*/

    (LONG)MENU_Sort,
    (LONG)MENU_SortbyName,
    (LONG)MENU_SortbyDate,

    (LONG)MENU_Settings,
    (LONG)MENU_Global,
    (LONG)MENU_Hostlist,
    (LONG)MENU_LogWindow,
    (LONG)MENU_ToggleDotFiles,
    (LONG)MENU_ToggleADTFiles,
    (LONG)MENU_LoadSettings,
    (LONG)MENU_SaveSettings,
    (LONG)MENU_SaveSettingsAs,

    (LONG)MENU_HotList
  };

d702 1
a702 7
/*
void RefreshWinGad(void)
{
    if(MainWindow)
      RefreshGList(MG_List[MG_ListView],MainWindow,NULL,-1);
}
*/
d749 7
d768 7
a829 2
void plong(void);

d940 6
a945 1
		AttachToolList(FALSE);
d985 6
a990 1
		AttachToolList(FALSE);
a1082 1
    /* Probably has to do oldmenu=menu;... FreeMenu(oldmenu); */
@


1.265
log
@Groups added. Bugs fixed.
@
text
@d19 1
a19 1

d154 1
d158 1
d162 2
a163 1
		View_clicked();
d168 3
d337 1
a337 1
	               LAYOUT_DeferLayout, FALSE,
a340 1
//                       LAYOUT_BevelStyle,BVS_THIN,
a345 1
//                           GA_UserData,(ULONG)Site_clicked,
a356 1
//                             GA_UserData,(ULONG)Dir_clicked,
a364 1
//	                   GA_UserData, (ULONG)Dir_clicked,
d385 1
a385 1
                       EndGroup,
d388 1
a388 1
  	                 StartHGroup, Spacing(FALSE),
a392 1
//                             GA_UserData,(ULONG)&DLPathString_clicked,
a400 1
//                             GA_UserData, (ULONG)&DLPath_clicked,
d405 1
a405 1
                         CHILD_WeightedHeight,0,
d407 1
d410 3
a416 1
//	                     GA_UserData, (ULONG)Parent_clicked,
d420 11
a434 1
//	                     GA_UserData,(ULONG)Get_Clicked,
a440 1
//	                     GA_UserData,(ULONG)Put_clicked,
a446 1
//	                     GA_UserData,(ULONG)View_clicked,
d450 2
a451 2
	                 CHILD_WeightMinimum,TRUE,
                
a457 1
//	                     GA_UserData,(ULONG)Connect_clicked,
d459 1
a463 1
//	                     GA_UserData,(ULONG)Disconnect_clicked,
d467 1
a467 1
	                 CHILD_WeightMinimum, TRUE,
d469 1
a469 1
	               CHILD_WeightedHeight,0,
d572 2
d579 1
d595 1
d606 1
d608 1
a608 1
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[2]},      /* Iconify */
d610 1
a610 1
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[3]},            /* About */
d612 1
a612 1
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[4]},        /* Quit */
d614 2
a615 2
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[5]},   /* Tag all */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[6]}, /* Untag all */
d618 2
a619 2
    {NM_SUB,     NULL,NULL,CHECKIT,~1,&menuhooks[7]}, /* Binary */
    {NM_SUB,     NULL,NULL,0,~2,&menuhooks[8]},  /* ASCII */
d621 1
a621 1
    {NM_ITEM,    NULL,NULL,0,~0,&menuhooks[9]},         /* Clear cache */
d623 1
a623 1
    {NM_ITEM,    NULL,NULL,0,~0,(APTR) &menuhooks[10]},      /* Delete */
a625 1
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[11]},
d627 1
a628 1
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[13]},
d630 1
a631 1
    {NM_ITEM,    NULL,NULL,CHECKIT|MENUTOGGLE,0,(APTR)&menuhooks[15]}, /* Log window */
d633 2
d636 3
a638 3
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[17]},                   /* Load settings... */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[18]},                   /* Save settings */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[19]},                   /* Save settings as...*/
d648 1
d672 1
d693 8
a700 2
	if (SetGadgetAttrs(MG_List[MG_Parent],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_Parent],MainWindow,NULL,1);
d720 16
a735 2
	if (SetGadgetAttrs(MG_List[MG_Parent],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_Parent],MainWindow,NULL,1);
a741 4
	if (SetGadgetAttrs(MG_List[MG_DirName],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_DirName],MainWindow,NULL,1);
	if (SetGadgetAttrs(MG_List[MG_Reload],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_Reload],MainWindow,NULL,1);
d747 16
a762 2
	if (SetGadgetAttrs(MG_List[MG_Parent],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_Parent],MainWindow,NULL,1);
a768 4
	if (SetGadgetAttrs(MG_List[MG_DirName],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_DirName],MainWindow,NULL,1);
	if (SetGadgetAttrs(MG_List[MG_Reload],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE) && MainWindow)
	  RefreshGList(MG_List[MG_Reload],MainWindow,NULL,1);
d800 1
a800 1
			 LISTBROWSER_Labels,~0,TAG_DONE))
d851 1
a851 1
    if (FileList) {
d863 1
a863 1
    if (FileList) {
d954 5
a958 2
			    DetachToolList();
			    Remove(node);
d960 2
a961 2
			    FreeListBrowserNode(node);
			    AttachToolList(FALSE);
d1010 82
d1115 5
a1119 4
	mainmenus[14].nm_Flags=CHECKIT|MENUTOGGLE|(TransferMode==BINARY?CHECKED:NULL);
	mainmenus[15].nm_Flags=CHECKIT|MENUTOGGLE|(TransferMode==ASCII?CHECKED:NULL);
	mainmenus[27].nm_Flags=CHECKIT|MENUTOGGLE|(LogWindow?CHECKED:NULL);
	mainmenus[28].nm_Flags=CHECKIT|MENUTOGGLE|(MainPrefs.mp_Showdotfiles?CHECKED:NULL);
d1201 1
a1201 1
	    while ((void *)GTMENUITEM_USERDATA(menuitem)!=(void *)&menuhooks[15]) {
d1210 2
d1220 21
@


1.200
log
@GETATTR-hit fixed.
@
text
@d98 1
a98 1
					  else if(head=read_remote_dir()) {
d141 3
a143 1
				  else {DownloadFile(FileList,NULL,TransferMode,0);}
d219 1
a219 1
		      if (ptr && (i==hnum)) {
a275 76
/*      case IDCMP_GADGETUP:
	{
	    ULONG id=GetTagData(GA_ID,0,msg->IAddress);
	    struct Node *node=NULL,*node1;

	    if (id==MG_ListView && FileList && msg->Code !=-1) {
		ULONG attr=0;
		ULONG action=0;
		GetAttrs(MG_List[MG_ListView],LISTBROWSER_NumSelected,&attr,
			 LISTBROWSER_RelEvent,&action,
			 LISTBROWSER_SelectedNode,&node,TAG_DONE);
		if (attr && node) {
		    if (action&LBRE_DOUBLECLICK && lsel==msg->Code) {
			struct dirlist *curr=(void *)node->ln_Name;
			struct List *head;

			APTR wlock=rtLockWindow(MainWindow);
			if (curr->mode&0x4000) {
			    if (!change_remote_dir(curr->name,0)) {
				if (head=LookupCache(CurrentState.CurrentRemoteDir)) {
				    DetachToolList();
				    FileList=head;
				    AttachToolList(TRUE);
				    UpdateMainButtons(MB_NONESELECTED);
				}
				else if(head=read_remote_dir()) {
				    DetachToolList();
				    AddCacheEntry(head,CurrentState.CurrentRemoteDir);
				    FileList=head;
				    AttachToolList(TRUE);
				    UpdateMainButtons(MB_NONESELECTED);
				}
				else
				  ShowErrorReq(Str_ErrorReadingDir);
			    }
			    else {
				RemoteCDFailed();
			    }
			}
			else if (S_ISLNK(curr->mode)) {
			    char *name;
			    struct List *head;
			    name = linkname(curr->name);
			    
			    if (name) {
				if (change_remote_dir(name,0)==ENOTDIR) {
				    DownloadFile(FileList,NULL,TransferMode,0);
				}
				else {
				    if (head=LookupCache(CurrentState.CurrentRemoteDir)) {
					DetachToolList();
					FileList=head;
					AttachToolList(TRUE);
					UpdateMainButtons(MB_NONESELECTED);
				    }
				    else if (head=read_remote_dir()) {
					DetachToolList();
					AddCacheEntry(head,CurrentState.CurrentRemoteDir);
					FileList=head;
					AttachToolList(TRUE);
					UpdateMainButtons(MB_NONESELECTED);
				    }
				    else
				      ShowErrorReq(GetAmiFTPString(Str_ErrorReadingDir));
				}
				free(name);
			    }
			}
			else {DownloadFile(FileList,NULL,TransferMode,0);}
			rtUnlockWindow(MainWindow,wlock);
		    }
		}
		lsel=msg->Code;
	    }
	}
	break;*/
d907 1
a907 1
		    if (!S_ISDIR(curr->mode) && !S_ISLNK(curr->mode)) {
d1001 9
a1009 2
			NewMenu[Count].nm_Type=ptr->sn_SubItem?NM_SUB:NM_ITEM;
			NewMenu[Count].nm_Label=ptr->sn_Node.ln_Name;
d1026 1
a1027 1
	    FreeMenus(MenuNew);
d1041 1
a1041 1
//    struct Menu *oldmenu=menu;
d1044 1
d1062 26
@


1.173
log
@bugversion
@
text
@d51 1
a51 1
ULONG HandleMainWindowIDCMP(BOOL AllowIconify)
d256 1
a256 1
    return (done);
d351 1
a351 1
    return (0);
d355 1
a355 1
struct Window *OpenFTPWindow(BOOL StartIconified)
d537 1
a537 1
	return (0);
d574 1
a574 1
	return (0);
d580 1
a580 1
	return (1);
d584 1
a584 1
	return (MainWindow);
d600 1
a600 1
    return (NULL);
d738 1
a738 1
void UpdateMainButtons(int state)
d807 1
a807 1
void AttachToolList(BOOL NoneSelected)
d842 1
a842 1
void UpdateRemoteDir(char *dir)
d853 1
a853 1
void UpdateLocalDir(char *dir)
d863 1
a863 1
void UpdateSiteName(char *site)
d876 1
a876 1
    return(0);
d888 1
a888 1
    return(1);
d900 1
a900 1
    return(1);
d907 1
a907 1
    return(2);
d931 1
a931 1
    return(1);
d952 1
a952 1
    return(1);
d971 1
a971 1
	    return(1);
d1002 1
a1002 1
    return(1);
d1008 1
a1008 1
    return(1);
d1014 1
a1014 1
    return(1);
d1022 1
a1022 1
    return(1);
d1028 1
a1028 1
    return (1);
d1034 1
a1034 1
    return (1);
d1089 1
a1089 1
	    return(0);
d1095 1
a1095 1
	    return(0);
d1100 1
a1100 1
	return(1);
d1102 1
a1102 1
    else return(0);
d1105 1
a1105 1
void UpdateMenus()
d1108 1
a1108 1
    struct Menu *oldmenu=menu;
d1160 1
a1160 1
    return (0);
@


1.150
log
@Iconify while transferring added.
Nicer update of fuelgauge.
@
text
@d160 23
d415 1
a415 1
                           GA_UserData,(ULONG)Site_clicked,
d427 1
a427 1
                             GA_UserData,(ULONG)Dir_clicked,
d436 1
a436 1
	                   GA_UserData, (ULONG)Dir_clicked,
d465 1
a465 1
                             GA_UserData,(ULONG)&DLPathString_clicked,
d474 1
a474 1
                             GA_UserData, (ULONG)&DLPath_clicked,
d487 1
a487 1
	                     GA_UserData, (ULONG)Parent_clicked,
d521 1
a521 1
	                     GA_UserData,(ULONG)Connect_clicked,
d527 1
a527 1
	                     GA_UserData,(ULONG)Disconnect_clicked,
d566 1
a566 1
                       WINDOW_InterpretUserData, WGUD_FUNC,
@


1.124
log
@AmiTCP and AS225r2 support in the same binary.
ARexx-command VIEW added.
New option to SETATTR, QUIET.
SETATTR LOCALDIR didn't update the download dir-gadget.
GETATTR STEM=bar didn't work since bar is in lowercase.
Enforcer hits when trying to open AmiFTP on a non-existing screen removed.
Moved 'Show dot-files?' to the Settings-menu.
Icelandic and Spanish catalogs added.
@
text
@d18 2
d78 70
d149 10
a159 1
	      }
d204 14
a217 1
	  case WMHI_MENUHELP:
a224 1
	    Printf("Unicon\n");
a237 1
static ULONG lsel=-1;
d251 1
a251 16
      case IDCMP_MENUHELP:
	if (msg->IAddress) {
	    struct CallBackHook *cbh;
	    struct MenuItem *menuitem=ItemAddress(menu,msg->Code);
	    
	    cbh = (void *)GTMENUITEM_USERDATA(menuitem);
//	    Printf("%lx\n",cbh);
	    if (cbh) {
		if ((LONG)cbh>100)
		  SendAGMessage(cbh->cbh_aguide);
		else
		  SendAGMessage(AG_MENUHOTLIST);
	    }
	}
	break;
      case IDCMP_GADGETUP:
d326 1
a326 1
	break;
d330 1
d370 4
d472 1
a472 1
	                     GA_UserData,(ULONG)Get_Clicked,
d479 1
a479 1
	                     GA_UserData,(ULONG)Put_clicked,
d486 1
a486 1
	                     GA_UserData,(ULONG)View_clicked,
d513 1
a513 1
	Printf("Failed to create layout\n");
d537 1
d545 1
a545 1
                       WINDOW_IDCMPHookBits,IDCMP_RAWKEY|IDCMP_MENUHELP|IDCMP_GADGETUP,
d549 1
a549 1
	Printf("Failed to create WinObject\n");
d563 1
a563 1
    Printf("CA_OpenWindow() failed\n");
d726 1
a726 1
	if (SetGadgetAttrs(MG_List[MG_Parent],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE))
d728 1
a728 1
	if (SetGadgetAttrs(MG_List[MG_Get],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE))
d730 1
a730 1
	if (SetGadgetAttrs(MG_List[MG_Put],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE))
d732 1
a732 1
	if (SetGadgetAttrs(MG_List[MG_Disconnect],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE))
d734 1
a734 1
	if (SetGadgetAttrs(MG_List[MG_DirName],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE))
d736 1
a736 1
	if (SetGadgetAttrs(MG_List[MG_Reload],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE))
d738 1
a738 1
	if (SetGadgetAttrs(MG_List[MG_View],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE))
d742 1
a742 1
			   TAG_DONE))
d747 1
a747 1
	if (SetGadgetAttrs(MG_List[MG_Parent],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE))
d749 1
a749 1
	if (SetGadgetAttrs(MG_List[MG_Get],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE))
d751 1
a751 1
	if (SetGadgetAttrs(MG_List[MG_Put],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE))
d753 1
a753 1
	if (SetGadgetAttrs(MG_List[MG_Disconnect],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE))
d755 1
a755 1
	if (SetGadgetAttrs(MG_List[MG_DirName],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE))
d757 1
a757 1
	if (SetGadgetAttrs(MG_List[MG_Reload],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE))
d759 1
a759 1
	if (SetGadgetAttrs(MG_List[MG_View],MainWindow,NULL,GA_Disabled,TRUE,TAG_DONE))
d764 1
a764 1
	if (SetGadgetAttrs(MG_List[MG_Parent],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE))
d766 1
a766 1
	if (SetGadgetAttrs(MG_List[MG_Get],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE))
d768 1
a768 1
	if (SetGadgetAttrs(MG_List[MG_Put],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE))
d770 1
a770 1
	if (SetGadgetAttrs(MG_List[MG_Disconnect],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE))
d772 1
a772 1
	if (SetGadgetAttrs(MG_List[MG_DirName],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE))
d774 1
a774 1
	if (SetGadgetAttrs(MG_List[MG_Reload],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE))
d776 1
a776 1
	if (SetGadgetAttrs(MG_List[MG_View],MainWindow,NULL,GA_Disabled,FALSE,TAG_DONE))
a857 2
    APTR wlock;

d859 1
a859 1
	wlock=rtLockWindow(MainWindow);
d863 1
a863 1
	rtUnlockWindow(MainWindow,wlock);
a869 2
    APTR wlock;

d871 1
a871 1
	wlock=rtLockWindow(MainWindow);
d875 1
a875 1
	rtUnlockWindow(MainWindow,wlock);
a940 1
    APTR wlock;
d945 1
a945 1
	wlock=rtLockWindow(MainWindow);
d947 1
a947 1
	    rtUnlockWindow(MainWindow,wlock);
d977 1
a977 1
	rtUnlockWindow(MainWindow,wlock);
d996 1
a996 2
    APTR wlock;
    wlock=rtLockWindow(MainWindow);
d998 1
a998 1
    rtUnlockWindow(MainWindow,wlock);
d1089 16
@


0.1343
log
@Removed some redudant things from AllocListbrowserNode()
Gadgets no longer flicker since I keep track of the state. Thought ClassAct did that, but no...
Added one tick to the fuelgauge, now 11 ticks => 10 intervals.
@
text
@d8 10
a17 1
struct TextFont *ScreenFont;
d131 1
d165 1
d258 3
d262 29
a290 1
    ScreenFont=OpenFont(Screen->Font);
d299 1
d342 1
a342 1
                         GA_ReadOnly,TRUE,
d351 1
a351 1
                       CHILD_MinHeight,ScreenFont->tf_YSize*6,
d488 6
d509 8
a522 34


#if 0
UWORD MinWide,MinHigh;
/* Nonproportional font info */
struct RastPort *NonPropRPort,nonprop_rp;
UWORD NonPropFHigh,NonPropBLine;
struct TextAttr *NonPropFont=NULL,NonPropta;
struct TextFont *NonPropdfont=NULL;
char *NonPropFontName;
int NonPropFontSize;

/* Proprortional font info */
UWORD PropFHigh,PropBLine;
struct RastPort *PropRPort=NULL,prop_rp;
struct TextAttr *PropFont=NULL,Propta;
struct TextFont *Propdfont=NULL;
char *PropFontName;
int PropFontSize;

struct Window *mainWin;
APTR myVisualInfo;
struct Screen *myScn;
struct IntuiMessage mainMsg;
struct Gadget *glist=NULL;
struct Menu *menu;
UWORD OldWin1Wide;
UWORD OldWin1High;
BOOL GadgetsRemoved=FALSE;
BOOL ShowFiles=FALSE;

long lvord=-1;
#endif

d529 1
d549 1
d586 1
d588 3
a590 3
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[16]},                   /* Load settings... */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[17]},                   /* Save settings */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[18]},                   /* Save settings as...*/
d622 1
a628 864
#if 0
struct Gadget *mainGadgets[NumGadgets_main];

struct GadGroup main_Group1;
extern int DLPathString_clicked(void);
static struct CallBackHook maingadhooks[]={
    {File_clicked,AG_MAINWIN},
    {Site_clicked,AG_MAINWIN},
    {Dir_clicked,AG_MAINWIN},
    {DLPathString_clicked,AG_MAINWIN},
    {Parent_clicked,AG_MAINWIN},
    {Get_clicked,AG_MAINWIN},
    {Put_clicked,AG_MAINWIN},
    {View_clicked,AG_MAINWIN},
    {DLPath_clicked,AG_MAINWIN},
    {Connect_clicked,AG_MAINWIN},
    {Disconnect_clicked,AG_MAINWIN}
};

struct NewGadget main_NewGadgets[]=
{
    {0,0,250,104,NULL,NULL,1,NULL,NULL,(APTR)&maingadhooks[0]},             /* Files listview */
    {0,0,250,0,NULL,NULL,2,PLACETEXT_LEFT,NULL,(APTR)&maingadhooks[1]},     /* Current site */
    {0,0,250,0,NULL,NULL,3,PLACETEXT_LEFT,NULL,(APTR)&maingadhooks[2]},      /* Directory */
    {0,0,250,0,NULL,NULL,4,NULL,NULL,(APTR)&maingadhooks[3]},       /* DLPathstring */
    {3,1,77,17,NULL,NULL,10,PLACETEXT_IN,NULL,(APTR)&maingadhooks[4]},    /* Parent */
    {3,1,77,17,NULL,NULL,11,PLACETEXT_IN,NULL,(APTR)&maingadhooks[5]},       /* Get */
    {3,1,77,17,NULL,NULL,12,PLACETEXT_IN,NULL,(APTR)&maingadhooks[6]},       /* Put */
    {3,1,77,17,NULL,NULL,13,NULL,NULL,(APTR)&maingadhooks[7]},              /* View */
    {0,0,250,0,NULL,NULL,5,PLACETEXT_IN,NULL,(APTR)&maingadhooks[8]},     /* DLPath */
    {0,0,250,0,NULL,NULL,14,PLACETEXT_IN,NULL,(APTR)&maingadhooks[9]},   /* Connect to */
    {0,0,250,0,NULL,NULL,15,PLACETEXT_IN,NULL,(APTR)&maingadhooks[10]} /* Disconnect */
};
struct GadGroup main_Group2;

LONG main_GadgetLabels[]= 
{
    NULL,
    (LONG)MW_SiteName,
    (LONG)MW_DirName,
    NULL,
    (LONG)MW_Parent,
    (LONG)MW_Get,
    (LONG)MW_Put,
    (LONG)MW_View,
    (LONG)MW_DownloadDir,
    (LONG)MW_Connect,
    (LONG)MW_Disconnect,
    -1
};


static char main_FastKeys[NumGadgets_main+1];

//extern ULONG __asm renderHook(register __a1 struct LVDrawMsg *msg,register __a2 struct Node *node);

/* Erase any part of "oldExtent" which is not covered by "newExtent" */
VOID FillOldExtent(struct RastPort *rp,
                   struct Rectangle *oldExtent,
                   struct Rectangle *newExtent)
{
    if (oldExtent->MinX < newExtent->MinX)
      RectFill(rp,oldExtent->MinX,
	       oldExtent->MinY,
	       newExtent->MinX-1,
	       oldExtent->MaxY);

    if (oldExtent->MaxX > newExtent->MaxX)
      RectFill(rp,newExtent->MaxX+1,
	       oldExtent->MinY,
	       oldExtent->MaxX,
	       oldExtent->MaxY);

    if (oldExtent->MaxY > newExtent->MaxY)
      RectFill(rp,oldExtent->MinX,
	       newExtent->MaxY+1,
	       oldExtent->MaxX,
	       oldExtent->MaxY);

    if (oldExtent->MinY < newExtent->MinY)
      RectFill(rp,oldExtent->MinX,
	       oldExtent->MinY,
	       oldExtent->MaxX,
	       newExtent->MinY-1);
}

/*****************************************************************************/


/* This function is called whenever an item of the listview needs to be drawn
 * by gadtools. The function must fill every pixel of the area described in
 * the LVDrawMsg structure. This function does the exact same rendering as
 * the built-in rendering function in gadtools, except that it render the
 * normal items using the highlight text pen instead of simply text pen.
 */
struct Hook renderHook;
static ULONG __asm RenderHook(register __a1 struct LVDrawMsg *msg,
                              register __a2 struct Node *node)
{
    struct RastPort   *rp;
    UBYTE              state;
    struct TextExtent  extent;
    ULONG              fit;
    WORD               x,y;
    WORD               slack;
    ULONG              apen;
    ULONG              bpen;
    UWORD             *pens;
    STRPTR             name;
    struct dirlist *dptr=(struct dirlist *)node;

    geta4();

    if (msg->lvdm_MethodID != LV_DRAW)
      return(LVCB_UNKNOWN);

    rp    = msg->lvdm_RastPort;
    state = msg->lvdm_State;
    pens  = msg->lvdm_DrawInfo->dri_Pens;

    apen = dptr->mode&0x4000?pens[HIGHLIGHTTEXTPEN]:pens[FILLTEXTPEN];
    bpen = pens[FILLPEN];
    if ((state == LVR_NORMAL) || (state == LVR_NORMALDISABLED))
      {
	  apen = dptr->mode&0x4000?pens[HIGHLIGHTTEXTPEN]:pens[TEXTPEN];
	  bpen = pens[BACKGROUNDPEN];
      }
    if (node->ln_Type) {
	apen=dptr->mode&0x4000?pens[HIGHLIGHTTEXTPEN]:pens[FILLTEXTPEN];
	bpen=pens[FILLPEN];
    }
    SetABPenDrMd(rp,apen,bpen,JAM2);

    name = node->ln_Name;

    fit = TextFit(rp,name,strlen(name),&extent,NULL,1,
                  msg->lvdm_Bounds.MaxX-msg->lvdm_Bounds.MinX-3,
                  msg->lvdm_Bounds.MaxY-msg->lvdm_Bounds.MinY+1);

    slack = (msg->lvdm_Bounds.MaxY - msg->lvdm_Bounds.MinY) - (extent.te_Extent.MaxY - extent.te_Extent.MinY);

    x = msg->lvdm_Bounds.MinX - extent.te_Extent.MinX + 2;
    y = msg->lvdm_Bounds.MinY - extent.te_Extent.MinY + ((slack+1) / 2);

    extent.te_Extent.MinX += x;
    extent.te_Extent.MaxX += x;
    extent.te_Extent.MinY += y;
    extent.te_Extent.MaxY += y;

    Move(rp,x,y);
    Text(rp,name,fit);

    SetAPen(rp,bpen);
    FillOldExtent(rp,&msg->lvdm_Bounds,&extent.te_Extent);

    return(LVCB_OK);
}

char FindVanillaKey(char *gadtext)
{
    unsigned char *cp;		/* unsigned is important for the toupper() macro! */

    /* Scan gadget text */
    if (cp=strchr(gadtext,'_'))
      /* Underscore found, return next character */
      return(toupper(*(cp+1)));
    else
      /* No underscore found, return dummy character */
      return(-1);
}

/* Match a given vanilla key with the key array */
ULONG MatchVanillaKey(unsigned char key, char *array)
{
    char *cp;

    /* Scan array */
    if (cp=strchr(array,toupper(key)))
      /* Key found, return index */
      return(cp-array);
    else
      /* Key not found, return illegal value */
      return(-1);
}

void StripIntuiMessages(struct MsgPort *mp, struct Window *win)
{
    struct IntuiMessage *msg;
    struct Node *succ;

    msg = (struct IntuiMessage *) mp->mp_MsgList.lh_Head;
    while(succ = msg->ExecMessage.mn_Node.ln_Succ)
      {
	  if(msg->IDCMPWindow == win)
	    {
		Remove((struct Node *)msg);
		ReplyMsg((struct Message *)msg);
	    }
	  msg = (struct IntuiMessage *) succ;
      }
}

void ComputeMinSize(UWORD *minwidth,UWORD *minheight)
{
    UWORD n1,n2,n3,n4;

    main_Group1.Height = 2*INTERHEIGHT + 10*NonPropFHigh + 3*NonPropFHigh + 9*INTERHEIGHT;
    n1 = TextLength(NonPropRPort,www,65)+16;
    main_Group1.Width  = max(n1,main_NewGadgets[GD_Files_LV].ng_Width) + INTERWIDTH;

    main_Group2.Height = 2*PropFHigh + 3*INTERHEIGHT;
    n1 = GadgetTextLength(PropRPort,main_NewGadgets[GD_Parent_gadget]);
    n2 = GadgetTextLength(PropRPort,main_NewGadgets[GD_Get_gadget]);
    n3 = GadgetTextLength(PropRPort,main_NewGadgets[GD_Put_gadget]);
    n4 = GadgetTextLength(PropRPort,main_NewGadgets[GD_View_gadget]);
    n1 = max(n1,n2);
    n3 = max(n3,n4);
    n1 = 4*max(n1,n3) + 7*INTERWIDTH;;
    n3 = GadgetTextLength(PropRPort,main_NewGadgets[GD_Connect_gadget]);
    n4 = GadgetTextLength(PropRPort,main_NewGadgets[GD_Disconnect_gadget]);
    n2 = 2*max(n3,n4) + 3*INTERWIDTH;

    main_Group2.Width = max(n1,n2);
    *minwidth = max(main_Group1.Width,main_Group2.Width);
    *minheight = main_Group1.Height+main_Group2.Height+INTERHEIGHT;
    main_FastKeys[GD_SiteName]= FindVanillaKey(main_NewGadgets[GD_SiteName].ng_GadgetText);
    main_FastKeys[GD_DirName] = FindVanillaKey(main_NewGadgets[GD_DirName].ng_GadgetText);
    main_FastKeys[GD_Parent_gadget] = FindVanillaKey(main_NewGadgets[GD_Parent_gadget].ng_GadgetText);
    main_FastKeys[GD_Get_gadget] = FindVanillaKey(main_NewGadgets[GD_Get_gadget].ng_GadgetText);
    main_FastKeys[GD_Put_gadget] = FindVanillaKey(main_NewGadgets[GD_Put_gadget].ng_GadgetText);
    main_FastKeys[GD_View_gadget] = FindVanillaKey(main_NewGadgets[GD_View_gadget].ng_GadgetText);
    main_FastKeys[GD_DLPath_gadget] = FindVanillaKey(main_NewGadgets[GD_DLPath_gadget].ng_GadgetText);
    main_FastKeys[GD_Connect_gadget] = FindVanillaKey(main_NewGadgets[GD_Connect_gadget].ng_GadgetText);
    main_FastKeys[GD_Disconnect_gadget] = FindVanillaKey(main_NewGadgets[GD_Disconnect_gadget].ng_GadgetText);
    main_FastKeys[GD_Files_LV] = -1;
    main_FastKeys[GD_DLPathName] = -1;
    for (n1=0;n1<NumGadgets_main;n1++)
      if (!main_FastKeys[n1])
	main_FastKeys[n1]=-1;
}

int Layout(struct Gadget **gadg,struct Window *window,struct NewGadget *gadgets,ULONG *tags,ULONG *kinds,struct Gadget **ngadgets, int numgadgets)
{
    int i;

    for (i=0;i<numgadgets;i++) {
	gadgets[i].ng_TopEdge+=window->BorderTop;
	gadgets[i].ng_LeftEdge+=window->BorderLeft;
	if (!gadgets[i].ng_VisualInfo) gadgets[i].ng_VisualInfo=myVisualInfo;
	if (!gadgets[i].ng_TextAttr) gadgets[i].ng_TextAttr=PropFont;
	if (!(ngadgets[i]=*gadg=CreateGadgetA(kinds[i],*gadg,&gadgets[i],(struct TagItem *)tags)))
	  return(FALSE);
	while(*tags!=TAG_DONE)
	  tags+=2;
	tags++;
    }
    return(TRUE);
}


BOOL LayoutElements(struct Gadget **gadg,UWORD Width,UWORD Height)
{
    extern struct List *FileList;
    extern long lvord;

    main_NewGadgets[GD_Connect_gadget].ng_Height    = PropFHigh + 2*INTERHEIGHT;
    main_NewGadgets[GD_Connect_gadget].ng_TopEdge   = mainWin->BorderTop+Height-main_NewGadgets[GD_Connect_gadget].ng_Height-INTERHEIGHT/2-INTERHEIGHT;
    main_NewGadgets[GD_Connect_gadget].ng_LeftEdge  = INTERWIDTH+mainWin->BorderLeft;
    main_NewGadgets[GD_Connect_gadget].ng_Width     = (Width-2*(INTERWIDTH/2)-2*INTERWIDTH)/2;
    main_NewGadgets[GD_Connect_gadget].ng_VisualInfo= myVisualInfo;
    main_NewGadgets[GD_Connect_gadget].ng_TextAttr  = PropFont;

    main_NewGadgets[GD_Disconnect_gadget].ng_TopEdge = main_NewGadgets[GD_Connect_gadget].ng_TopEdge;
    main_NewGadgets[GD_Disconnect_gadget].ng_Height  = main_NewGadgets[GD_Connect_gadget].ng_Height;
    main_NewGadgets[GD_Disconnect_gadget].ng_Width   = main_NewGadgets[GD_Connect_gadget].ng_Width;
    main_NewGadgets[GD_Disconnect_gadget].ng_LeftEdge = mainWin->BorderLeft+Width-main_NewGadgets[GD_Disconnect_gadget].ng_Width-INTERWIDTH;
    main_NewGadgets[GD_Disconnect_gadget].ng_VisualInfo = myVisualInfo;
    main_NewGadgets[GD_Disconnect_gadget].ng_TextAttr = PropFont;

    main_NewGadgets[GD_Parent_gadget].ng_Height     = PropFHigh + 2*INTERHEIGHT;
    main_NewGadgets[GD_Parent_gadget].ng_TopEdge    = main_NewGadgets[GD_Connect_gadget].ng_TopEdge-INTERHEIGHT-main_NewGadgets[GD_Parent_gadget].ng_Height;
    main_NewGadgets[GD_Parent_gadget].ng_LeftEdge   = INTERWIDTH + mainWin->BorderLeft;
    main_NewGadgets[GD_Parent_gadget].ng_Width      = (Width-3*(INTERWIDTH/2)-2*INTERWIDTH)/4;
    main_NewGadgets[GD_Parent_gadget].ng_VisualInfo = myVisualInfo;
    main_NewGadgets[GD_Parent_gadget].ng_TextAttr   = PropFont;

    main_NewGadgets[GD_Put_gadget].ng_Height = main_NewGadgets[GD_View_gadget].ng_Height =main_NewGadgets[GD_Get_gadget].ng_Height = main_NewGadgets[GD_Parent_gadget].ng_Height;
    main_NewGadgets[GD_Put_gadget].ng_Width = main_NewGadgets[GD_View_gadget].ng_Width = main_NewGadgets[GD_Get_gadget].ng_Width = main_NewGadgets[GD_Parent_gadget].ng_Width;
    main_NewGadgets[GD_Put_gadget].ng_TopEdge = main_NewGadgets[GD_View_gadget].ng_TopEdge = main_NewGadgets[GD_Get_gadget].ng_TopEdge = main_NewGadgets[GD_Parent_gadget].ng_TopEdge;
    main_NewGadgets[GD_Get_gadget].ng_LeftEdge = main_NewGadgets[GD_Parent_gadget].ng_LeftEdge + main_NewGadgets[GD_Parent_gadget].ng_Width + INTERWIDTH/2;
    main_NewGadgets[GD_Put_gadget].ng_LeftEdge = main_NewGadgets[GD_Get_gadget].ng_LeftEdge + main_NewGadgets[GD_Get_gadget].ng_Width + INTERWIDTH/2;
    main_NewGadgets[GD_View_gadget].ng_LeftEdge = mainWin->BorderLeft+Width-main_NewGadgets[GD_View_gadget].ng_Width-INTERWIDTH;
    main_NewGadgets[GD_Put_gadget].ng_VisualInfo = main_NewGadgets[GD_View_gadget].ng_VisualInfo = main_NewGadgets[GD_Get_gadget].ng_VisualInfo = myVisualInfo;
    main_NewGadgets[GD_Put_gadget].ng_TextAttr = main_NewGadgets[GD_View_gadget].ng_TextAttr = main_NewGadgets[GD_Get_gadget].ng_TextAttr = PropFont;

    main_NewGadgets[GD_Connect_gadget].ng_Width   = main_NewGadgets[GD_Get_gadget].ng_LeftEdge+main_NewGadgets[GD_Get_gadget].ng_Width-main_NewGadgets[GD_Connect_gadget].ng_LeftEdge;
    main_NewGadgets[GD_Disconnect_gadget].ng_LeftEdge=main_NewGadgets[GD_Put_gadget].ng_LeftEdge;
    main_NewGadgets[GD_Disconnect_gadget].ng_Width=main_NewGadgets[GD_View_gadget].ng_LeftEdge+main_NewGadgets[GD_View_gadget].ng_Width-main_NewGadgets[GD_Disconnect_gadget].ng_LeftEdge;

    main_NewGadgets[GD_SiteName].ng_TopEdge = mainWin->BorderTop + INTERHEIGHT;
    main_NewGadgets[GD_SiteName].ng_LeftEdge = mainWin->BorderLeft + INTERWIDTH + GadgetTextLength(PropRPort,main_NewGadgets[GD_SiteName]) + TextLength(PropRPort," ",1) + INTERWIDTH;
    main_NewGadgets[GD_SiteName].ng_Height = PropFHigh + 2*INTERHEIGHT;
    main_NewGadgets[GD_SiteName].ng_VisualInfo = myVisualInfo;
    main_NewGadgets[GD_SiteName].ng_TextAttr = PropFont;

    main_NewGadgets[GD_DirName].ng_TopEdge = main_NewGadgets[GD_SiteName].ng_TopEdge + 2*INTERHEIGHT + INTERHEIGHT/2+ PropFHigh;
    main_NewGadgets[GD_DirName].ng_LeftEdge = main_NewGadgets[GD_SiteName].ng_LeftEdge;
    main_NewGadgets[GD_DirName].ng_Height = main_NewGadgets[GD_SiteName].ng_Height;
    main_NewGadgets[GD_DirName].ng_VisualInfo = myVisualInfo;
    main_NewGadgets[GD_DirName].ng_TextAttr = PropFont;
    
    main_NewGadgets[GD_DLPath_gadget].ng_Height    = PropFHigh +2*INTERHEIGHT;
    main_NewGadgets[GD_DLPath_gadget].ng_TopEdge   = main_NewGadgets[GD_Parent_gadget].ng_TopEdge - main_NewGadgets[GD_DLPath_gadget].ng_Height - INTERHEIGHT;
    main_NewGadgets[GD_DLPath_gadget].ng_LeftEdge  = main_NewGadgets[GD_Parent_gadget].ng_LeftEdge;
    main_NewGadgets[GD_DLPath_gadget].ng_Width     = INTERWIDTH+GadgetTextLength(PropRPort,main_NewGadgets[GD_DLPath_gadget]);
    main_NewGadgets[GD_DLPath_gadget].ng_VisualInfo = myVisualInfo;
    main_NewGadgets[GD_DLPath_gadget].ng_TextAttr = PropFont;

    main_NewGadgets[GD_DLPathName].ng_Height   = main_NewGadgets[GD_DLPath_gadget].ng_Height;
    main_NewGadgets[GD_DLPathName].ng_TopEdge  = main_NewGadgets[GD_DLPath_gadget].ng_TopEdge;
    main_NewGadgets[GD_DLPathName].ng_LeftEdge = main_NewGadgets[GD_DLPath_gadget].ng_LeftEdge+main_NewGadgets[GD_DLPath_gadget].ng_Width+INTERWIDTH;
    main_NewGadgets[GD_DLPathName].ng_VisualInfo = myVisualInfo;
    main_NewGadgets[GD_DLPathName].ng_TextAttr = PropFont;

    main_NewGadgets[GD_Files_LV].ng_TopEdge    = main_NewGadgets[GD_DirName].ng_TopEdge + 2*INTERHEIGHT+ INTERHEIGHT/2+PropFHigh;
    main_NewGadgets[GD_Files_LV].ng_LeftEdge   = main_NewGadgets[GD_Parent_gadget].ng_LeftEdge;
    main_NewGadgets[GD_Files_LV].ng_Width      = Width-2*INTERWIDTH;
    main_NewGadgets[GD_Files_LV].ng_Height     = ((main_NewGadgets[GD_DLPathName].ng_TopEdge-main_NewGadgets[GD_DirName].ng_TopEdge-INTERHEIGHT-main_NewGadgets[GD_DirName].ng_Height)/NonPropFHigh)*NonPropFHigh-INTERHEIGHT;
    main_NewGadgets[GD_Files_LV].ng_VisualInfo = myVisualInfo;
    main_NewGadgets[GD_Files_LV].ng_TextAttr   = NonPropFont;

    main_NewGadgets[GD_DLPath_gadget].ng_TopEdge = main_NewGadgets[GD_DLPathName].ng_TopEdge  = main_NewGadgets[GD_Files_LV].ng_TopEdge + main_NewGadgets[GD_Files_LV].ng_Height+INTERHEIGHT;

    main_NewGadgets[GD_SiteName].ng_Width = main_NewGadgets[GD_Files_LV].ng_Width - GadgetTextLength(PropRPort,main_NewGadgets[GD_SiteName])-TextLength(PropRPort," ",1)-INTERWIDTH;
    main_NewGadgets[GD_DirName].ng_Width = main_NewGadgets[GD_SiteName].ng_Width;
    main_NewGadgets[GD_DLPathName].ng_Width = main_NewGadgets[GD_Files_LV].ng_Width - main_NewGadgets[GD_DLPath_gadget].ng_Width-INTERWIDTH;
    if (!(mainGadgets[GD_Files_LV] = *gadg = CreateGadget(LISTVIEW_KIND,*gadg,&main_NewGadgets[GD_Files_LV],
							  GTLV_ShowSelected,NULL,
							  GTLV_Labels,FileList,
							  V39?GTLV_MakeVisible:GTLV_Top,lvord,
							  GTLV_Selected,~0,
							  GTLV_CallBack,&renderHook,
							  TAG_DONE)))
      return(FALSE);

    if (!(mainGadgets[GD_SiteName] = *gadg = CreateGadget(STRING_KIND,*gadg,&main_NewGadgets[GD_SiteName],
							  GA_TabCycle,FALSE,
							  GTST_String,CurrentState.CurrentSite,
							  GTST_MaxChars,100,
							  GT_Underscore,'_',
							  TAG_END)))
      return(FALSE);
    if (!(mainGadgets[GD_DirName] = *gadg = CreateGadget (STRING_KIND,*gadg,&main_NewGadgets[GD_DirName],
							  GA_TabCycle,FALSE,
							  GTST_String,CurrentState.CurrentRemoteDir,
							  GTST_MaxChars,100,
							  GT_Underscore,'_',
							  GA_Disabled,connected?FALSE:TRUE,
							  TAG_END)))
      return(FALSE);

    if (!(mainGadgets[GD_DLPathName] = *gadg = CreateGadget(STRING_KIND,*gadg,&main_NewGadgets[GD_DLPathName],
							    GTST_String,CurrentState.CurrentDLDir,
							    GT_Underscore,'_',
							    TAG_END)))
      return(FALSE);

    if (!(mainGadgets[GD_Parent_gadget] = *gadg = CreateGadget(BUTTON_KIND,*gadg,&main_NewGadgets[GD_Parent_gadget],
							       GT_Underscore,'_',
							       GA_Disabled,connected?FALSE:TRUE,
							       TAG_END)))
      return(FALSE);
    if (!(mainGadgets[GD_Get_gadget] = *gadg = CreateGadget(BUTTON_KIND,*gadg,&main_NewGadgets[GD_Get_gadget],
							    GT_Underscore,'_',
							    GA_Disabled,lvord==-1?TRUE:FALSE,
							    TAG_END)))
      return(FALSE);
    if (!(mainGadgets[GD_Put_gadget] = *gadg = CreateGadget(BUTTON_KIND,*gadg,&main_NewGadgets[GD_Put_gadget],
							    GA_Disabled,connected?FALSE:TRUE,
							    GT_Underscore,'_',
							    TAG_END)))
      return(FALSE);
    if (!(mainGadgets[GD_View_gadget] = *gadg = CreateGadget(BUTTON_KIND,*gadg,&main_NewGadgets[GD_View_gadget],
							     GA_Disabled,TRUE,
							     GT_Underscore,'_',
							     TAG_END)))
      return(FALSE);
    if (!(mainGadgets[GD_DLPath_gadget] = *gadg = CreateGadget(BUTTON_KIND,*gadg,&main_NewGadgets[GD_DLPath_gadget],
							       GT_Underscore,'_',
							       TAG_END)))
      return(FALSE);
    if (!(mainGadgets[GD_Connect_gadget] = *gadg = CreateGadget(BUTTON_KIND,*gadg,&main_NewGadgets[GD_Connect_gadget],
								GT_Underscore,'_',
								TAG_END)))
      return(FALSE);
    if (!(mainGadgets[GD_Disconnect_gadget] = *gadg = CreateGadget(BUTTON_KIND,*gadg,&main_NewGadgets[GD_Disconnect_gadget],
								   GT_Underscore,'_',
								   GA_Disabled,connected?FALSE:TRUE,
								   TAG_END)))
      return(FALSE);

    return(TRUE);
}


int OpenFTPWindow()
{
    long w,h;
    UWORD x_vis,y_vis;
    struct Gadget *gad;

    renderHook.h_Entry= (HOOKFUNC)RenderHook;
    if (myScn = LockPubScreen(strlen(CurrentState.ScreenName)?CurrentState.ScreenName:NULL)) {
	struct TextFont *nonpropfont=GfxBase->DefaultFont;
	struct Rectangle *r;
	UWORD x, y;

	r = &myScn->ViewPort.ColorMap->cm_vpe->DisplayClip;
	x = r->MaxX - r->MinX + 1;
	y = r->MaxY - r->MinY + 1;
	x_vis=(x > myScn->Width ? myScn->Width : x);
	y_vis=(y > myScn->Height ? myScn->Height : y);


	myVisualInfo = GetVisualInfo(myScn,TAG_DONE);

	if (CurrentState.FixedFontSize) {
	    NonPropta.ta_Name=CurrentState.FixedFontName;
	    NonPropta.ta_YSize=CurrentState.FixedFontSize;
	    NonPropta.ta_Style=FS_NORMAL;
	    NonPropta.ta_Flags=FPF_DESIGNED|FPF_DISKFONT;

	    if (NonPropdfont) {
		CloseFont(NonPropdfont);
		NonPropdfont=NULL;
	    }
	    NonPropdfont=OpenDiskFont(&NonPropta);
	    if (NonPropdfont) {
		if (!(NonPropdfont->tf_Flags&FPF_PROPORTIONAL)) {
		    InitRastPort(&nonprop_rp);
		    NonPropFont=&NonPropta;
		    SetFont(&nonprop_rp,NonPropdfont);
		    NonPropRPort=&nonprop_rp;
		    NonPropFHigh=NonPropRPort->Font->tf_YSize;
		    NonPropBLine=NonPropRPort->Font->tf_Baseline;
		}
		else {
		    CloseFont(NonPropdfont);
		    NonPropdfont=NULL;
		}
	    }
	}
	if (!NonPropdfont) {
	    NonPropta.ta_Name=nonpropfont->tf_Message.mn_Node.ln_Name;
	    NonPropta.ta_YSize=nonpropfont->tf_YSize;
	    NonPropta.ta_Flags=nonpropfont->tf_Flags;
	    NonPropta.ta_Style=nonpropfont->tf_Style;
	    if (NonPropdfont) {
		CloseFont(NonPropdfont);
		NonPropdfont=NULL;
	    }
	    //	Printf("Fixed font: %s/%ld\n",NonPropta.ta_Name,NonPropta.ta_YSize);
	    NonPropdfont=OpenDiskFont(&NonPropta);
	    if (NonPropdfont) {
		InitRastPort(&nonprop_rp);
		NonPropFont=&NonPropta;
		SetFont(&nonprop_rp,NonPropdfont);
		NonPropRPort=&nonprop_rp;
		NonPropFHigh=NonPropRPort->Font->tf_YSize;
		NonPropBLine=NonPropRPort->Font->tf_Baseline;
	    }
	    else return(2);
	}
	if (CurrentState.PropFontSize) {
	    Propta.ta_Name=CurrentState.PropFontName;
	    Propta.ta_YSize=CurrentState.PropFontSize;
	    Propta.ta_Style=FS_NORMAL;
	    Propta.ta_Flags=FPF_DESIGNED|FPF_DISKFONT|FPF_PROPORTIONAL;
	    if (Propdfont) {
		CloseFont(Propdfont);
		Propdfont=NULL;
	    }
	    Propdfont=OpenDiskFont(&Propta);
	    if (Propdfont) {
		InitRastPort(&prop_rp);
		PropFont=&Propta;
		SetFont(&prop_rp,Propdfont);
		PropRPort=&prop_rp;
		PropFHigh=PropRPort->Font->tf_YSize;
		PropBLine=PropRPort->Font->tf_Baseline;
	    }
	}
	if (!Propdfont) {
	    Propta.ta_Name=myScn->Font->ta_Name;
	    Propta.ta_YSize=myScn->Font->ta_YSize;
	    Propta.ta_Flags=myScn->Font->ta_Flags;
	    Propta.ta_Style=myScn->Font->ta_Style;
	    if (Propdfont) {
		CloseFont(Propdfont);
		Propdfont=NULL;
	    }
	    Propdfont=OpenDiskFont(&Propta);
	    if (Propdfont) {
		InitRastPort(&prop_rp);
		PropFont=&Propta;
		SetFont(&prop_rp,Propdfont);
		PropRPort=&prop_rp;
		PropFHigh=PropRPort->Font->tf_YSize;
		PropBLine=PropRPort->Font->tf_Baseline;
	    }
	    else {
		Printf("Failed to open propfont\n");
		return (2);
	    }
	}

	ComputeMinSize(&MinWide,&MinHigh);
	w=myScn->Width-MinWide;
	h=myScn->Height-MinHigh;

	if ((w<0)||(h<0)) {
	    CloseFont(Propdfont);
	    CloseFont(NonPropdfont);
	    Propdfont=NonPropdfont=NULL;
	    memset(&Propta,0,sizeof(Propta));
	    Propta.ta_Name="topaz.font";
	    Propta.ta_YSize=8;
	    Propta.ta_Style=FS_NORMAL;
	    Propta.ta_Flags=FPF_DESIGNED|FPF_DISKFONT;
	    Propdfont=OpenDiskFont(&Propta);
	    if (Propdfont) {
		InitRastPort(&prop_rp);
		PropFont=&Propta;
		SetFont(&prop_rp,Propdfont);
		PropRPort=&prop_rp;
		PropFHigh=PropRPort->Font->tf_YSize;
		PropBLine=PropRPort->Font->tf_Baseline;

		memset(&NonPropta,0,sizeof(NonPropta));
		NonPropta.ta_Name="topaz.font";
		NonPropta.ta_YSize=8;
		NonPropta.ta_Style=FS_NORMAL;
		NonPropta.ta_Flags=FPF_DESIGNED|FPF_DISKFONT;
		NonPropdfont=OpenDiskFont(&NonPropta);
		if (NonPropdfont) {
		    InitRastPort(&nonprop_rp);
		    NonPropFont=&NonPropta;
		    SetFont(&nonprop_rp,NonPropdfont);
		    NonPropRPort=&nonprop_rp;
		    NonPropFHigh=NonPropRPort->Font->tf_YSize;
		    NonPropBLine=NonPropRPort->Font->tf_Baseline;
		}
		else return(1);
	    }
	    else
	      return(1);

	    ComputeMinSize(&MinWide,&MinHigh);
	    if (MinWide>myScn->Width||MinHigh>myScn->Height)
	      return(2);
	}

	/* Now we know we have a font that will fit this screen */

	OldWin1Wide=myScn->Width-myScn->WBorLeft-myScn->WBorRight-20;
	OldWin1Wide=max(OldWin1Wide,MinWide);
	OldWin1High=2*(y_vis/3)-myScn->WBorTop-myScn->WBorBottom-PropFHigh-3;
	OldWin1High=max(OldWin1High,MinHigh);

	if (!BuildMenu())
	  return(2);

	mainWin = OpenWindowTags(NULL,
				 WA_AutoAdjust, TRUE,
				 WA_PubScreen, myScn,
				 WA_Top,CurrentState.TopEdge?CurrentState.TopEdge:MainPrefs.mp_TopEdge - myScn->ViewPort.DyOffset,
				 WA_Left,CurrentState.LeftEdge?CurrentState.LeftEdge:MainPrefs.mp_LeftEdge - myScn->ViewPort.DxOffset,
				 WA_Width, MinWide + myScn->WBorLeft + myScn->WBorRight,
				 CurrentState.Height?WA_Height:WA_InnerHeight,CurrentState.Height?CurrentState.Height:OldWin1High,
				 WA_MinWidth, MinWide + myScn->WBorLeft + myScn->WBorRight,
				 WA_MinHeight, MinHigh + myScn->WBorTop + myScn->WBorBottom + PropFHigh +3,
				 WA_MaxWidth, MinWide + myScn->WBorLeft + myScn->WBorRight,
				 WA_MaxHeight, ~0,
				 WA_Title, wintitle,
				 WA_NewLookMenus,TRUE,
				 WA_MenuHelp,TRUE,
				 WA_IDCMP,IDCMP_SIZEVERIFY|IDCMP_NEWSIZE|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW|IDCMP_GADGETDOWN|IDCMP_GADGETUP|IDCMP_VANILLAKEY|LISTVIEWIDCMP|IDCMP_MENUPICK|IDCMP_MENUHELP|IDCMP_GADGETHELP|IDCMP_RAWKEY,
				 WA_Flags,WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_SIZEGADGET|WFLG_ACTIVATE,
				 TAG_DONE
				 );

	/* Since we either opened the window or failed */
	UnlockPubScreen(NULL,myScn);

	if (!mainWin) {
	    return(3);
	}

	SetMenuStrip(mainWin,menu);
	OldWin1Wide=mainWin->Width;
	OldWin1High=mainWin->Height;

	SetFont(mainWin->RPort,NonPropdfont);
	gad = CreateContext(&glist);
	if (!gad) {
	    ClearMenuStrip(mainWin);
	    CloseWindow(mainWin);
	    FreeMenus(menu);
	    return(4);
	}

	if (!LayoutElements(&gad,
			    mainWin->Width - mainWin->BorderRight - mainWin->BorderLeft,
			    mainWin->Height - mainWin->BorderTop - mainWin->BorderBottom
			    )) {
	    StripIntuiMessages(mainWin->UserPort,mainWin);
	    ClearMenuStrip(mainWin);
	    CloseWindow(mainWin);
	    FreeMenus(menu);
	    FreeGadgets(glist);
	    return(5);
	}

	AddGList(mainWin,glist,~0,-1,NULL);
	RefreshGList(mainWin->FirstGadget,mainWin,NULL,-1);
	GT_RefreshWindow(mainWin,NULL);
	HelpControl(mainWin,HC_GADGETHELP);
	return(0);
    }
    else
      return(6);
}

int HandleFTPIDCMP()
{
    struct IntuiMessage *imsg;
    int Continue=1;
    ULONG MsgClass;
    UWORD Code;
    struct Gadget *gad;

    while (imsg = GT_GetIMsg(mainWin->UserPort)) {
	CopyMem((char *)imsg,(char *)&mainMsg,(long)sizeof(mainMsg));
	MsgClass = imsg->Class;
	Code = imsg->Code;

	switch(MsgClass) {
	  case IDCMP_SIZEVERIFY:
	    RemoveGList( mainWin, glist, -1 );
	    GadgetsRemoved = TRUE;
	    break;

	  case IDCMP_NEWSIZE:
	    if( (OldWin1Wide == mainWin->Width) &&
	       (OldWin1High == mainWin->Height) ) {
		/* NOT ACTUALLY RESIZED */
		if (GadgetsRemoved ) {
		    AddGList( mainWin, glist, ~0, -1, NULL );
		}
	    } else {
		/* The window has REALLY been resized; time to
		 * get rid of GadTools gadgets, blank the window
		 * and then add the gadgets again, including the
		 * GadTools gadgets which is done with a call to
		 * our LayoutElements() function.
		 */
		if( !GadgetsRemoved ) {
		    RemoveGList( mainWin, glist, -1 );
		    /*		    AddGList( mainWin, glist, ~0, -1, NULL );*/
		}
		if( glist ) {
		    FreeGadgets(glist);
		    glist = NULL;
		}
		SetAPen( mainWin->RPort, 0 );
		RectFill(mainWin->RPort,
			 mainWin->BorderLeft + 1, mainWin->BorderTop + 1,
			 mainWin->Width - mainWin->BorderRight - 1,
			 mainWin->Height - mainWin->BorderBottom - 1);
		OldWin1Wide = mainWin->Width; /* grab new size */
		OldWin1High = mainWin->Height;

		/* Add the GadTools gadgets */
		if( gad = CreateContext( &glist ) ) {
		    if (!LayoutElements( &gad,
					mainWin->Width -
					mainWin->BorderRight -
					mainWin->BorderLeft,
					mainWin->Height -
					mainWin->BorderBottom -
					mainWin->BorderTop
					)) {
			ClearMenuStrip(mainWin);
			StripIntuiMessages(mainWin->UserPort,mainWin);
			CloseWindow(mainWin);
			FreeMenus(menu);
			if (glist)
			  FreeGadgets(glist);
			CleanUp();
			exit(10);
		    }
		    AddGList( mainWin, glist, ~0, -1, NULL );

		}		/* if */
	    }
	    RefreshGList(mainWin->FirstGadget,mainWin,NULL,-1);
	    //	    DetachToolList();
	    //	    AttachToolList();
	    GT_RefreshWindow( mainWin, NULL );
	    GadgetsRemoved = FALSE;
	    break;
	}

	GT_ReplyIMsg(imsg);
	
	/* Now we can handle less critical stuff, i.e. things
	 * to which we can reply before handling it
	 */
	switch( MsgClass ) {
	  case IDCMP_CLOSEWINDOW:
	    Continue = 0;
	    break;
	  case IDCMP_REFRESHWINDOW:
	    GT_BeginRefresh( mainWin );
	    GT_EndRefresh( mainWin, TRUE );
	    break;
	  case IDCMP_MENUHELP:
	    if (mainMsg.IAddress) {
		struct CallBackHook *cbh;
		struct MenuItem *menuitem=ItemAddress(menu,mainMsg.Code);

		cbh = (void *)GTMENUITEM_USERDATA(menuitem);
		if (cbh) {
		    if ((LONG)cbh>100)
		      SendAGMessage(cbh->cbh_aguide);
		    else
		      SendAGMessage(AG_MENUHOTLIST);
		}
	    }
	    break;
	  case IDCMP_GADGETHELP:
	    ag.ag_region=-1;
	    if (mainMsg.IAddress==(APTR)mainWin) {
		ag.ag_region=0;
	    }
	    break;
	  case IDCMP_RAWKEY:
	    if (mainMsg.Code==95) {
		SendAGMessage(AG_MAINWIN);
	    }
	    break;
	  case IDCMP_GADGETUP:
/*	    func = (void *)((struct Gadget *)mainMsg.IAddress)->UserData;
	    func();
	    break;*/
	  case IDCMP_GADGETDOWN:
	    {
		struct CallBackHook *cbh;
		cbh = (void *)((struct Gadget *)mainMsg.IAddress)->UserData;
		if (cbh)
		  if (cbh->cbh_func)
		    cbh->cbh_func();
	    }
	    break;
	  case IDCMP_MENUPICK:
	    {
		USHORT menunum=mainMsg.Code;
		struct CallBackHook *cbh;
		while (menunum!=MENUNULL) {
		    struct MenuItem *menuitem=ItemAddress(menu,menunum);
		    cbh = (void *)GTMENUITEM_USERDATA(menuitem);
		    if ((ULONG)cbh>100)
		      Continue=cbh->cbh_func();
		    else { /* Hotlist item selected*/
			int hnum=(int)cbh,i;
			struct SiteNode *ptr;
			struct Node *lbn;
			hnum--;
			for (i=0,lbn=GetHead(&SiteList);lbn;lbn=GetSucc(lbn)) {
			    GetListBrowserNodeAttrs(lbn,
						    LBNA_UserData,&ptr,
						    TAG_DONE);
			    if (ptr) {
				if (ptr->sn_HotList) {
				    if (i==hnum)
				      break;
				    i++;
				}
			    }
			}
			if (ptr && (i==hnum)) {
			    ConnectSite(ptr,0);
			    if (connected)
			      strncpy(CurrentState.LastLVSite,ptr->sn_Node.ln_Name,60);
			}
		    }
		    if (!Continue)
		      break;
		    menunum=menuitem->NextSelect;
		}
	    }
	    break;
	  case IDCMP_VANILLAKEY:
	    {
		ULONG num;
		struct CallBackHook *cbh;
		num=MatchVanillaKey((unsigned char)Code,main_FastKeys);
		
		if (num!=-1) {
		    if (num==GD_SiteName)
		      ActivateGadget(mainGadgets[num],mainWin,NULL);
		    else if (num==GD_DirName)
		      ActivateGadget(mainGadgets[num],mainWin,NULL);
		    else {
			cbh = (void *)mainGadgets[num]->UserData;
			if (cbh)
			  if (cbh->cbh_func)
			    cbh->cbh_func();
		    }
		}
	    }
	    break;
	  default:
	    break;
	}
    }
    if (MenuNeedsUpdate) {
	UpdateMenus();
	MenuNeedsUpdate=FALSE;
    }
    return(Continue);
}

int CloseFTPWindow(void)
{
    if (mainWin) {
	CurrentState.LeftEdge=mainWin->LeftEdge;
	CurrentState.TopEdge=mainWin->TopEdge;
	CurrentState.Width=mainWin->Width;
	CurrentState.Height=mainWin->Height;
	StripIntuiMessages(mainWin->UserPort,mainWin);
	ClearMenuStrip(mainWin);
	CloseWindow(mainWin);
	FreeMenus(menu);
	mainWin=NULL;
    }
    if (glist) {
      FreeGadgets(glist);
    }
    if (myVisualInfo) {
	FreeVisualInfo(myVisualInfo);
	myVisualInfo=NULL;
    }
    if (Propdfont) {
	CloseFont(Propdfont);
	Propdfont=NULL;
    }
    if (NonPropdfont) {
	CloseFont(NonPropdfont);
	NonPropdfont=NULL;
    }
    return (1);
}
#endif
d634 1
a634 1
    if (!MainWindow)
d636 1
a636 1

d657 1
a657 1
	if (SetGadgetAttrs(MG_List[MG_ListView],MainWindow,NULL,GA_ReadOnly,TRUE,
a677 2
	if (SetGadgetAttrs(MG_List[MG_ListView],MainWindow,NULL,GA_ReadOnly,FALSE,TAG_DONE))
	  RefreshGList(MG_List[MG_ListView],MainWindow,NULL,1);
a694 2
	if (SetGadgetAttrs(MG_List[MG_ListView],MainWindow,NULL,GA_ReadOnly,FALSE,TAG_DONE))
	  RefreshGList(MG_List[MG_ListView],MainWindow,NULL,1);
d811 1
a811 1
    ULONG n=0;
d816 7
a822 4
	    SetListBrowserNodeAttrs(node,
				    LBNA_Selected,TRUE,
				    TAG_DONE);
	    n=1;
d959 6
a964 2
	mainmenus[14].nm_Flags=CHECKIT|(TransferMode==BINARY?CHECKED:NULL);
	mainmenus[15].nm_Flags=CHECKIT|(TransferMode==ASCII?CHECKED:NULL);
a1047 1

@


0.1300
log
@Added Reload-gadget.
Added Sort-gadget to sitelist-window.
AmiFTP now show the correct size of links during transfer.
@
text
@d295 2
a296 1
	               StartMember, MG_List[MG_ListView]=ListBrowserObject,
d309 1
a309 1

d1467 2
d1474 4
d1616 2
d1619 1
d1623 1
d1630 2
d1633 1
d1637 1
d1700 1
d1705 5
a1709 2
	if (!rtEZRequest(GetAmiFTPString(MW_DeleteRequest),GetAmiFTPString(MW_DeleteCancel),NULL,(struct TagItem *)tags))
	  return(1);
d1735 3
a1737 2
    if (t==0)
      UpdateMainButtons(MB_NONESELECTED);
@


0.857
log
@Log-window function working. Only thing missing a to control it from ARexx.
@
text
@d4 32
d37 1
a37 1
char www[]="WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW";
d39 429
d497 1
a506 1
void UpdateMenus(void);
d601 1
a601 1

d1377 1
d1379 10
a1388 5
			for (i=0,ptr=(struct SiteNode *)GetHead(&SiteList);ptr;ptr=(struct SiteNode *)GetSucc((struct Node *)ptr)) {
			    if (ptr->sn_HotList) {
				if (i==hnum)
				  break;
				i++;
d1464 1
d1468 1
a1468 1
    if (!mainWin)
d1473 19
a1491 6
	GT_SetGadgetAttrs(mainGadgets[GD_Parent_gadget],mainWin,NULL,GA_Disabled,TRUE,TAG_DONE);
	GT_SetGadgetAttrs(mainGadgets[GD_Get_gadget],mainWin,NULL,GA_Disabled,TRUE,TAG_DONE);
	GT_SetGadgetAttrs(mainGadgets[GD_Put_gadget],mainWin,NULL,GA_Disabled,TRUE,TAG_DONE);
	GT_SetGadgetAttrs(mainGadgets[GD_Disconnect_gadget],mainWin,NULL,GA_Disabled,TRUE,TAG_DONE);
	GT_SetGadgetAttrs(mainGadgets[GD_DirName],mainWin,NULL,GA_Disabled,TRUE,TAG_DONE);
	GT_SetGadgetAttrs(mainGadgets[GD_View_gadget],mainWin,NULL,GA_Disabled,TRUE,TAG_DONE);
d1494 17
a1510 6
	GT_SetGadgetAttrs(mainGadgets[GD_Parent_gadget],mainWin,NULL,GA_Disabled,FALSE,TAG_DONE);
	GT_SetGadgetAttrs(mainGadgets[GD_Get_gadget],mainWin,NULL,GA_Disabled,TRUE,TAG_DONE);
	GT_SetGadgetAttrs(mainGadgets[GD_Put_gadget],mainWin,NULL,GA_Disabled,FALSE,TAG_DONE);
	GT_SetGadgetAttrs(mainGadgets[GD_Disconnect_gadget],mainWin,NULL,GA_Disabled,FALSE,TAG_DONE);
	GT_SetGadgetAttrs(mainGadgets[GD_DirName],mainWin,NULL,GA_Disabled,FALSE,TAG_DONE);
	GT_SetGadgetAttrs(mainGadgets[GD_View_gadget],mainWin,NULL,GA_Disabled,TRUE,TAG_DONE);
d1513 16
a1528 6
	GT_SetGadgetAttrs(mainGadgets[GD_Parent_gadget],mainWin,NULL,GA_Disabled,FALSE,TAG_DONE);
	GT_SetGadgetAttrs(mainGadgets[GD_Get_gadget],mainWin,NULL,GA_Disabled,FALSE,TAG_DONE);
	GT_SetGadgetAttrs(mainGadgets[GD_Put_gadget],mainWin,NULL,GA_Disabled,FALSE,TAG_DONE);
	GT_SetGadgetAttrs(mainGadgets[GD_Disconnect_gadget],mainWin,NULL,GA_Disabled,FALSE,TAG_DONE);
	GT_SetGadgetAttrs(mainGadgets[GD_DirName],mainWin,NULL,GA_Disabled,FALSE,TAG_DONE);
	GT_SetGadgetAttrs(mainGadgets[GD_View_gadget],mainWin,NULL,GA_Disabled,FALSE,TAG_DONE);
d1535 1
a1535 1
void AttachToolList(void)
d1537 15
a1551 2
    if(mainWin)
      GT_SetGadgetAttrs(mainGadgets[GD_Files_LV],mainWin,NULL,GTLV_Labels,FileList,TAG_DONE);
d1556 6
a1561 2
    if (mainWin) 
      GT_SetGadgetAttrs(mainGadgets[GD_Files_LV],mainWin,NULL,GTLV_Labels,NULL,TAG_DONE);
d1563 1
d1566 2
a1567 2
    if(mainWin)
      RefreshGList(mainGadgets[GD_Files_LV],mainWin,NULL,-1);
d1569 1
a1569 1

d1575 3
a1577 3
    if (mainWin) {
	GT_SetGadgetAttrs(mainGadgets[GD_DirName],mainWin,NULL,GTST_String,dir,TAG_END);
	RefreshGList(mainGadgets[GD_DirName],mainWin,NULL,1);
d1585 3
a1587 3
    if (mainWin) {
	GT_SetGadgetAttrs(mainGadgets[GD_DLPathName],mainWin,NULL,GTST_String,dir,TAG_END);
	RefreshGList(mainGadgets[GD_DLPathName],mainWin,NULL,1);
d1595 3
a1597 3
    if (mainWin) {
	GT_SetGadgetAttrs(mainGadgets[GD_SiteName],mainWin,NULL,GTST_String,site,TAG_END);
	RefreshGList(mainGadgets[GD_SiteName],mainWin,NULL,1);
d1603 1
d1612 1
a1612 1
	AttachToolList();
d1622 1
a1622 1
	AttachToolList();
d1629 2
d1636 4
a1639 1
    struct dirlist *curr;
d1641 10
a1650 5
	for (curr=(struct dirlist *)GetHead(FileList);curr;curr=(struct dirlist *)GetSucc((struct Node *)curr))
	  if (!S_ISDIR(curr->mode))
	    curr->dl_Node.ln_Type=1;
	GT_SetGadgetAttrs(mainGadgets[GD_Files_LV],mainWin,NULL,GTLV_Labels,FileList,GTLV_Selected,~0,TAG_DONE);
	UpdateMainButtons(MB_FILESELECTED);
d1657 4
a1660 1
    struct dirlist *curr;
d1662 9
a1670 4
	for (curr=(struct dirlist *)GetHead(FileList);curr;curr=(struct dirlist *)GetSucc((struct Node *)curr))
	  curr->dl_Node.ln_Type=0;
	GT_SetGadgetAttrs(mainGadgets[GD_Files_LV],mainWin,NULL,GTLV_Labels,FileList,GTLV_Selected,~0,TAG_DONE);
	UpdateMainButtons(MB_FILESELECTED);
d1676 2
d1681 1
d1683 1
d1685 1
d1687 1
a1687 1
    tags[3]=(ULONG)mainWin;
d1691 21
a1711 9
	for (curr=(struct dirlist *)GetHead(FileList);curr;curr=(struct dirlist *)GetSucc((struct Node *)curr)) {
	    if (!S_ISDIR(curr->mode) && !S_ISLNK(curr->mode) && curr->dl_Node.ln_Type) {
		if (delete_remote(curr->name,"DELE")) {
		    Remove(curr);
		    free_direntry(curr);
		    GT_SetGadgetAttrs(mainGadgets[GD_Files_LV],mainWin,NULL,GTLV_Labels,FileList,GTLV_Selected,~0,TAG_DONE);
		}
		else {
		    t=1;
d1714 1
a1715 1
    }
d1718 1
d1737 1
a1737 1
    wlock=rtLockWindow(mainWin);
d1739 1
a1739 1
    rtUnlockWindow(mainWin,wlock);
d1762 1
d1766 8
a1773 3
    for (ptr=(struct SiteNode *)GetHead(&SiteList);ptr;ptr=(struct SiteNode *)GetSucc((struct Node *)ptr)) {
	if (ptr->sn_HotList)
	  SiteCount++;
d1783 12
a1794 7
	    for (ptr=(struct SiteNode *)GetHead(&SiteList);ptr;ptr=(struct SiteNode *)GetSucc((struct Node *)ptr)) {
		if (ptr->sn_HotList) {
		    NewMenu[Count].nm_Type=NM_ITEM;
		    NewMenu[Count].nm_Label=ptr->sn_Node.ln_Name;
		    NewMenu[Count].nm_UserData=(void *)(SiteCount+1);
		    SiteCount++;
		    Count++;
d1806 1
a1806 1
	if (!LayoutMenus(MenuNew,myVisualInfo,GTMN_NewLookMenus,TRUE,TAG_DONE)) {
d1825 32
a1856 5
    if (mainWin) {
	ClearMenuStrip(mainWin);
	if (oldmenu)
	  FreeMenus(oldmenu);
	SetMenuStrip(mainWin,menu);
d1858 1
d1862 1
@


0.827
log
@Add Current to sitelist added.
More rtLockWindow()'s
Leeching seems to work, but is not finished yet.
@
text
@d42 2
d62 1
d98 5
a102 3
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[15]},                   /* Load settings... */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[16]},                   /* Save settings */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[17]},                   /* Save settings as...*/
d133 1
d1214 2
a1215 2
	mainmenus[13].nm_Flags=CHECKIT|(TransferMode==BINARY?CHECKED:NULL);
	mainmenus[14].nm_Flags=CHECKIT|(TransferMode==ASCII?CHECKED:NULL);
@


0.814
log
@Added default download-dir.
@
text
@d42 1
d46 1
d69 1
d71 1
a71 1
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[1]},      /* Iconify */
d73 1
a73 1
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[2]},            /* About */
d75 1
a75 1
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[3]},        /* Quit */
d77 2
a78 2
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[4]},   /* Tag all */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[5]}, /* Untag all */
d81 2
a82 2
    {NM_SUB,     NULL,NULL,CHECKIT,~1,&menuhooks[6]}, /* Binary */
    {NM_SUB,     NULL,NULL,0,~2,&menuhooks[7]},  /* ASCII */
d84 1
a84 1
    {NM_ITEM,    NULL,NULL,0,~0,&menuhooks[8]},         /* Clear cache */
d86 1
a86 1
    {NM_ITEM,    NULL,NULL,0,~0,(APTR) &menuhooks[9]},      /* Delete */
a88 1
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[10]},
d90 1
a91 1
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[12]},
d93 1
d95 3
a97 3
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[14]},                   /* Load settings... */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[15]},                   /* Save settings */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)&menuhooks[16]},                   /* Save settings as...*/
d106 1
@


0.807
log
@Added AmigaGuide on-line help.
@
text
@d4 1
d42 1
a42 1
void UpdateMenus();
d985 1
d1214 1
a1214 1
		    NewMenu[Count].nm_UserData=SiteCount+1;
@


0.774
log
@Now handles filenames up to 128 chars, atleast in DownloadFile().
@
text
@d42 19
d65 1
a65 1
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)Reconnect},         /* Reconnect */
d67 1
a67 1
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)menu_Iconify},      /* Iconify */
d69 1
a69 1
    {NM_ITEM,    NULL,NULL,0,~0,(APTR) About},            /* About */
d71 1
a71 1
    {NM_ITEM,    NULL,NULL,0,~0,(APTR) menu_Quit},        /* Quit */
d73 2
a74 2
    {NM_ITEM,    NULL,NULL,0,~0,(APTR) menu_SelectAll},   /* Tag all */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR) menu_UnselectAll}, /* Untag all */
d77 2
a78 2
    {NM_SUB,     NULL,NULL,CHECKIT,~1,menu_BinaryTransferMode}, /* Binary */
    {NM_SUB,     NULL,NULL,0,~2,menu_AsciiTransferMode},  /* ASCII */
d80 1
a80 1
    {NM_ITEM,    NULL,NULL,0,~0,menu_ClearCache},         /* Clear cache */
d82 2
a83 2
    {NM_ITEM,    NULL,NULL,0,~0,(APTR) menu_Delete},      /* Delete */
/*    {NM_ITEM,    "Move","M",0,~0,(APTR) menu_Move},*/
d85 2
a86 2
    {NM_ITEM,    NULL,NULL,0,~0,(APTR) menu_SortByName},
    {NM_ITEM,    NULL,NULL,0,~0,(APTR) menu_SortByDate},
d88 2
a89 2
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)OpenPrefsWindow},
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)menu_HostlistPrefs},
d91 3
a93 3
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)LoadPrefs},                   /* Load settings... */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)SavePrefs},                   /* Save settings */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)SavePrefsAs},                   /* Save settings as...*/
d134 14
d150 11
a160 11
    {0,0,250,104,NULL,NULL,1,NULL,NULL,(APTR)File_clicked},             /* Files listview */
    {0,0,250,0,NULL,NULL,2,PLACETEXT_LEFT,NULL,(APTR)Site_clicked},     /* Current site */
    {0,0,250,0,NULL,NULL,3,PLACETEXT_LEFT,NULL,(APTR)Dir_clicked},      /* Directory */
    {0,0,250,0,NULL,NULL,4,NULL,NULL,(APTR)DLPathString_clicked},       /* DLPathstring */
    {3,1,77,17,NULL,NULL,10,PLACETEXT_IN,NULL,(APTR)Parent_clicked},    /* Parent */
    {3,1,77,17,NULL,NULL,11,PLACETEXT_IN,NULL,(APTR)Get_clicked},       /* Get */
    {3,1,77,17,NULL,NULL,12,PLACETEXT_IN,NULL,(APTR)Put_clicked},       /* Put */
    {3,1,77,17,NULL,NULL,13,NULL,NULL,(APTR)View_clicked},              /* View */
    {0,0,250,0,NULL,NULL,5,PLACETEXT_IN,NULL,(APTR)DLPath_clicked},     /* DLPath */
    {0,0,250,0,NULL,NULL,14,PLACETEXT_IN,NULL,(APTR)Connect_clicked},   /* Connect to */
    {0,0,250,0,NULL,NULL,15,PLACETEXT_IN,NULL,(APTR)Disconnect_clicked} /* Disconnect */
d714 2
a715 1
				 WA_IDCMP,IDCMP_SIZEVERIFY|IDCMP_NEWSIZE|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW|IDCMP_GADGETDOWN|IDCMP_GADGETUP|IDCMP_VANILLAKEY|LISTVIEWIDCMP|IDCMP_MENUPICK,
d755 1
a755 1

a770 2
	int (*func)();

d855 25
d885 7
a891 3
	    func = (void *)((struct Gadget *)mainMsg.IAddress)->UserData;
	    if (func)
	      func();
d896 1
d899 3
a901 3
		    func = (void *)GTMENUITEM_USERDATA(menuitem);
		    if ((ULONG)func>100)
		      Continue=func();
d903 1
a903 1
			int hnum=(int)func,i;
d928 1
a928 1

d937 4
a940 3
			func = (void *)mainGadgets[num]->UserData;
			if (func)
			  func();
@


0.765
log
@FIXEDFONTNAME/SIZE should work now. Accidentally copied the PROPNAME/SIZE
@
text
@a522 1
	    Printf("Selecting a new font\n");
a571 1
//	    Printf("%ld %ld\n",Propta.ta_YSize,CurrentState.PropFontSize);
a577 1
//	    Printf("Prop font: %s/%ld\n",Propta.ta_Name,Propta.ta_YSize);
a596 1
//	    Printf("Prop font: %s/%ld\n",Propta.ta_Name,Propta.ta_YSize);
a749 1
	    //Printf("Got IDCMP_NEWSIZE...");
a752 1
		//Printf("no resize needed.(OldWide = %ld, newwide = %ld)\n",OldWin1Wide,mainWin->Width);
a762 1
		//Printf("resize in progress.\n");
@


0.753
log
@Improved fastkeys-handling.
@
text
@d523 1
@


0.728
log
@Save settings also saves the window position.
@
text
@d148 1
a148 1
static char main_FastKeys[NumGadgets_main];
d264 1
a264 1
      return(0);
d303 1
a303 1
    n1 = TextLength(NonPropRPort,www,64)+16;
d332 3
d835 2
a836 1
	    func();
d873 2
a874 1
		num=MatchVanillaKey(Code,main_FastKeys);
d882 2
a883 1
			func();
@


0.671
log
@"View" on links downloaded it twice.
@
text
@d667 1
d669 1
a669 1
				 WA_AutoAdjust, FALSE,
d671 2
a672 2
				 WA_Top,CurrentState.TopEdge?CurrentState.TopEdge:0 - myScn->ViewPort.DyOffset,
				 WA_Left,CurrentState.LeftEdge?CurrentState.LeftEdge:0 - myScn->ViewPort.DxOffset,
@


0.647
log
@Release version, small things fixed.
@
text
@d569 1
a569 1
	    Printf("%ld %ld\n",Propta.ta_YSize,CurrentState.PropFontSize);
@


0.623
log
@Added menuitem TransferMode->Binary/ASCII
@
text
@d519 67
a585 7
	NonPropta.ta_Name=nonpropfont->tf_Message.mn_Node.ln_Name;
	NonPropta.ta_YSize=nonpropfont->tf_YSize;
	NonPropta.ta_Flags=nonpropfont->tf_Flags;
	NonPropta.ta_Style=nonpropfont->tf_Style;
	if (NonPropdfont) {
	    CloseFont(NonPropdfont);
	    NonPropdfont=NULL;
d587 1
a587 10
//	Printf("Fixed font: %s/%ld\n",NonPropta.ta_Name,NonPropta.ta_YSize);
	NonPropdfont=OpenDiskFont(&NonPropta);
	if (NonPropdfont) {
	    InitRastPort(&nonprop_rp);
	    NonPropFont=&NonPropta;
	    SetFont(&nonprop_rp,NonPropdfont);
	    NonPropRPort=&nonprop_rp;
	    NonPropFHigh=NonPropRPort->Font->tf_YSize;
	    NonPropBLine=NonPropRPort->Font->tf_Baseline;
	    
a604 3
		ComputeMinSize(&MinWide,&MinHigh);
		w=myScn->Width-MinWide;
		h=myScn->Height-MinHigh;
a610 5
	else {
	    Printf("Failed to open fixed font\n");
	    return (2);
	}
/* skit i att testa andra fonter...
d612 3
a614 19
	if (PropFontSize) {
	    memset(&ta,0,sizeof(ta));
	    ta.ta_Name=FontName;
	    ta.ta_YSize=FontSize;
	    ta.ta_Style=FS_NORMAL;
	    ta.ta_Flags=FPF_DESIGNED|FPF_DISKFONT;
	    dfont=OpenDiskFont(&ta);
	    if (dfont) {
		InitRastPort(&rp);
		Font=&ta;
		SetFont(&rp,dfont);
		RPort=&rp;
		FHigh=RPort->Font->tf_YSize;
		BLine=RPort->Font->tf_Baseline;
		ComputeMinSize(&MinWide,&MinHigh);
		w=myScn->Width-MinWide;
		h=myScn->Height-MinHigh;
	    }
	}
d617 16
a632 12
	    if (dfont) {
		CloseFont(dfont);
		dfont=NULL;
	    }
	    RPort=&(myScn->RastPort);
	    FHigh=RPort->Font->tf_YSize;
	    BLine=RPort->Font->tf_Baseline;
	    Font=myScn->Font;
	    ComputeMinSize(&MinWide,&MinHigh);
	    w=myScn->Width-MinWide;
	    h=myScn->Height-MinHigh;
	}
d634 15
a648 18
	if ((w<0)||(h<0)) {
	    if (dfont) {
		CloseFont(dfont);
		dfont=NULL;
	    }
	    memset(&ta,0,sizeof(ta));
	    ta.ta_Name="topaz.font";
	    ta.ta_YSize=8;
	    ta.ta_Style=FS_NORMAL;
	    ta.ta_Flags=FPF_DESIGNED|FPF_DISKFONT;
	    dfont=OpenDiskFont(&ta);
	    if (dfont) {
		InitRastPort(&rp);
		Font=&ta;
		SetFont(&rp,dfont);
		RPort=&rp;
		FHigh=RPort->Font->tf_YSize;
		BLine=RPort->Font->tf_Baseline;
d657 1
a657 1
*/
@


0.588
log
@The GUI now handles proportional fonts. Only the main listview is fixed font.
@
text
@d39 2
d57 4
d90 3
d527 1
a527 1
	Printf("Fixed font: %s/%ld\n",NonPropta.ta_Name,NonPropta.ta_YSize);
d545 1
a545 1
	    Printf("Prop font: %s/%ld\n",Propta.ta_Name,Propta.ta_YSize);
d1082 12
d1110 2
@


0.567
log
@Fixed busy loop caused by badly timed SetMenuStrip() (In the NextSelect-loop)
@
text
@d6 17
a22 3
struct RastPort *RPort,rp;
UWORD FHigh,BLine,MinWide,MinHigh;
struct TextAttr *Font,ta;
a24 3
char *FontName;
int FontSize;
struct TextFont *dfont;
d293 2
a294 2
    main_Group1.Height = 2*INTERHEIGHT + 10*FHigh + 3*FHigh + 9*INTERHEIGHT;
    n1 = TextLength(RPort,www,64)+16;
d297 5
a301 5
    main_Group2.Height = 2*FHigh + 3*INTERHEIGHT;
    n1 = GadgetTextLength(RPort,main_NewGadgets[GD_Parent_gadget]);
    n2 = GadgetTextLength(RPort,main_NewGadgets[GD_Get_gadget]);
    n3 = GadgetTextLength(RPort,main_NewGadgets[GD_Put_gadget]);
    n4 = GadgetTextLength(RPort,main_NewGadgets[GD_View_gadget]);
d305 2
a306 2
    n3 = GadgetTextLength(RPort,main_NewGadgets[GD_Connect_gadget]);
    n4 = GadgetTextLength(RPort,main_NewGadgets[GD_Disconnect_gadget]);
d333 1
a333 1
	if (!gadgets[i].ng_TextAttr) gadgets[i].ng_TextAttr=Font;
d349 1
a349 1
    main_NewGadgets[GD_Connect_gadget].ng_Height    = FHigh + 2*INTERHEIGHT;
d354 1
a354 1
    main_NewGadgets[GD_Connect_gadget].ng_TextAttr  = Font;
d361 1
a361 1
    main_NewGadgets[GD_Disconnect_gadget].ng_TextAttr = Font;
d363 1
a363 1
    main_NewGadgets[GD_Parent_gadget].ng_Height     = FHigh + 2*INTERHEIGHT;
d368 1
a368 1
    main_NewGadgets[GD_Parent_gadget].ng_TextAttr   = Font;
d377 1
a377 1
    main_NewGadgets[GD_Put_gadget].ng_TextAttr = main_NewGadgets[GD_View_gadget].ng_TextAttr = main_NewGadgets[GD_Get_gadget].ng_TextAttr = Font;
d384 2
a385 2
    main_NewGadgets[GD_SiteName].ng_LeftEdge = mainWin->BorderLeft + INTERWIDTH + GadgetTextLength(RPort,main_NewGadgets[GD_SiteName]) + TextLength(RPort," ",1) + INTERWIDTH;
    main_NewGadgets[GD_SiteName].ng_Height = FHigh + 2*INTERHEIGHT;
d387 1
a387 1
    main_NewGadgets[GD_SiteName].ng_TextAttr = Font;
d389 1
a389 1
    main_NewGadgets[GD_DirName].ng_TopEdge = main_NewGadgets[GD_SiteName].ng_TopEdge + 2*INTERHEIGHT + INTERHEIGHT/2+ FHigh;
d393 1
a393 1
    main_NewGadgets[GD_DirName].ng_TextAttr = Font;
d395 1
a395 1
    main_NewGadgets[GD_DLPath_gadget].ng_Height    = FHigh +2*INTERHEIGHT;
d398 1
a398 1
    main_NewGadgets[GD_DLPath_gadget].ng_Width     = INTERWIDTH+GadgetTextLength(RPort,main_NewGadgets[GD_DLPath_gadget]);
d400 1
a400 1
    main_NewGadgets[GD_DLPath_gadget].ng_TextAttr = Font;
d406 1
a406 1
    main_NewGadgets[GD_DLPathName].ng_TextAttr = Font;
d408 1
a408 1
    main_NewGadgets[GD_Files_LV].ng_TopEdge    = main_NewGadgets[GD_DirName].ng_TopEdge + 2*INTERHEIGHT+ INTERHEIGHT/2+FHigh;
d411 1
a411 1
    main_NewGadgets[GD_Files_LV].ng_Height     = ((main_NewGadgets[GD_DLPathName].ng_TopEdge-main_NewGadgets[GD_DirName].ng_TopEdge-INTERHEIGHT-main_NewGadgets[GD_DirName].ng_Height)/FHigh)*FHigh-INTERHEIGHT;
d413 1
a413 1
    main_NewGadgets[GD_Files_LV].ng_TextAttr   = Font;
d417 1
a417 1
    main_NewGadgets[GD_SiteName].ng_Width = main_NewGadgets[GD_Files_LV].ng_Width - GadgetTextLength(RPort,main_NewGadgets[GD_SiteName])-TextLength(RPort," ",1)-INTERWIDTH;
d497 1
a497 1
	struct TextFont *tf=GfxBase->DefaultFont;
d509 8
a516 7
	ta.ta_Name=tf->tf_Message.mn_Node.ln_Name;
	ta.ta_YSize=tf->tf_YSize;
	ta.ta_Flags=tf->tf_Flags;
	ta.ta_Style=tf->tf_Style;
	if (dfont) {
	    CloseFont(dfont);
	    dfont=NULL;
d518 39
a556 12
	dfont=OpenDiskFont(&ta);
	if (dfont) {
	    InitRastPort(&rp);
	    Font=&ta;
	    SetFont(&rp,dfont);
	    RPort=&rp;
	    FHigh=RPort->Font->tf_YSize;
	    BLine=RPort->Font->tf_Baseline;

	    ComputeMinSize(&MinWide,&MinHigh);
	    w=myScn->Width-MinWide;
	    h=myScn->Height-MinHigh;
d558 1
d560 1
a560 1
	if (FontSize) {
d620 1
a620 1

d625 1
a625 1
	OldWin1High=2*(y_vis/3)-myScn->WBorTop-myScn->WBorBottom-FHigh-3;
a627 9
/*	menu=CreateMenus(mainmenus,TAG_DONE);
	if (!menu) {
	    return(2);
	}
	if (!LayoutMenus(menu,myVisualInfo,GTMN_NewLookMenus,TRUE,TAG_DONE)) {
	    FreeMenus(menu);
	    return(2);
	}
*/
d638 1
a638 1
				 WA_MinHeight, MinHigh + myScn->WBorTop + myScn->WBorBottom + FHigh +3,
d659 1
a659 1
	SetFont(mainWin->RPort,dfont);
a800 1
		    Printf("Found new menuitem %lx\n",menunum);
d875 7
a881 3
    if (dfont) {
	CloseFont(dfont);
	dfont=NULL;
a1067 1
    Printf("Calling opensitelistwindow()\n");
a1068 1
    Printf("Returned from opensitelistwindow()\n");
@


0.563
log
@AmiFTP now works with AS225r2 and hopefully with mlink.
Fixes concerning the locale.
@
text
@d28 1
d770 1
d818 4
d1034 1
d1036 1
d1094 2
d1100 2
@


0.544
log
@Added gadstrlen() and macro GadgetTextLength() to compute correct strings with _ in labels.
Checks if CTRL-C has been hit before opening window.
@
text
@d988 2
a989 1
    static ULONG tags[]={RTEZ_ReqTitle,(ULONG)"AmiFTP",RT_Window,NULL,RT_LockWindow,TRUE,RT_ReqPos,REQPOS_CENTERWIN,TAG_END};
d1026 2
d1029 1
@


0.486
log
@Recursive getting of directory trees implemented.
Password/Anonymous-gadget added in SiteConfiguration Window
Layout fixes.
@
text
@d286 4
a289 4
    n1 = TextLength(RPort,main_NewGadgets[GD_Parent_gadget].ng_GadgetText,strlen(main_NewGadgets[GD_Parent_gadget].ng_GadgetText)-1);
    n2 = TextLength(RPort,main_NewGadgets[GD_Get_gadget].ng_GadgetText,strlen(main_NewGadgets[GD_Get_gadget].ng_GadgetText)-1);
    n3 = TextLength(RPort,main_NewGadgets[GD_Put_gadget].ng_GadgetText,strlen(main_NewGadgets[GD_Put_gadget].ng_GadgetText)-1);
    n4 = TextLength(RPort,main_NewGadgets[GD_View_gadget].ng_GadgetText,strlen(main_NewGadgets[GD_View_gadget].ng_GadgetText)-1);
d293 2
a294 2
    n3 = TextLength(RPort,main_NewGadgets[GD_Connect_gadget].ng_GadgetText,strlen(main_NewGadgets[GD_Connect_gadget].ng_GadgetText)-1);
    n4 = TextLength(RPort,main_NewGadgets[GD_Disconnect_gadget].ng_GadgetText,strlen(main_NewGadgets[GD_Disconnect_gadget].ng_GadgetText)-1);
d372 1
a372 1
    main_NewGadgets[GD_SiteName].ng_LeftEdge = mainWin->BorderLeft + INTERWIDTH + TextLength(RPort,main_NewGadgets[GD_SiteName].ng_GadgetText,strlen(main_NewGadgets[GD_SiteName].ng_GadgetText)) + TextLength(RPort," ",1) + INTERWIDTH;
d386 1
a386 1
    main_NewGadgets[GD_DLPath_gadget].ng_Width     = INTERWIDTH+TextLength(RPort,main_NewGadgets[GD_DLPath_gadget].ng_GadgetText,strlen(main_NewGadgets[GD_DLPath_gadget].ng_GadgetText));
d405 1
a405 1
    main_NewGadgets[GD_SiteName].ng_Width = main_NewGadgets[GD_Files_LV].ng_Width - TextLength(RPort,main_NewGadgets[GD_SiteName].ng_GadgetText,strlen(main_NewGadgets[GD_SiteName].ng_GadgetText))-TextLength(RPort," ",1)-INTERWIDTH;
@


0.425
log
@Add Settingsmenu with Load/Save settings.
Added Edit hostlist to the settingsmenu.
Changed the search order for the prefs-file.
@
text
@d757 1
a757 2
	    Printf("IDCMP_GADGETUP\n");
	    func = (void *)((struct Gadget *)mainMsg.IAddress)->UserData;
d759 1
a759 1
	    break;
a760 1
	    Printf("IDCMP_GADGETDOWN\n");
@


0.413
log
@Added password-gadget.
@
text
@d27 1
a32 2
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)OpenPrefsWindow},   /* Preferences */
    {NM_ITEM,    NULL,NULL,0,~0,(APTR)SavePrefs},         /* Save prefs */
d50 7
a64 2
    (LONG)MENU_Preferences,
    (LONG)MENU_SavePrefs,
d80 7
d1022 6
@


0.371
log
@Localized source.
@
text
@d746 4
d751 1
d979 1
a979 1
    ULONG tags[]={RTEZ_ReqTitle,(ULONG)"AmiFTP",RT_Window,NULL,RT_LockWindow,TRUE,RT_ReqPos,REQPOS_CENTERWIN,TAG_END};
d982 1
a982 1
	if (!rtEZRequest("Are you sure you want\nto delete these files?","Delete|Cancel",NULL,(struct TagItem *)tags))
@


0.345
log
@Upload via ARexx now works
Entering a remotedir in stringgadget results in re-reading it
@
text
@d30 4
a33 4
    {NM_TITLE, "Project", NULL,0,~0,NULL},
    {NM_ITEM,    "Reconnect",NULL,0,~0,(APTR)Reconnect},
    {NM_ITEM,    "Preferences",NULL,0,~0,(APTR)OpenPrefsWindow},
    {NM_ITEM,    "Save prefs",NULL,0,~0,(APTR)SavePrefs},
d35 1
a35 1
    {NM_ITEM,    "Iconify","I",0,~0,(APTR)menu_Iconify},
d37 1
a37 1
    {NM_ITEM,    "About",NULL,0,~0,(APTR) About},
d39 4
a42 4
    {NM_ITEM,    "Quit","Q",0,~0,(APTR) menu_Quit},
    {NM_TITLE, "Files",NULL,0,~0,NULL},
    {NM_ITEM,    "Tag all",NULL,0,~0,(APTR) menu_SelectAll},
    {NM_ITEM,    "Untag all",NULL,0,~0,(APTR) menu_UnselectAll},
d44 1
a44 1
    {NM_ITEM,    "Clear dir-cache",NULL,0,~0,menu_ClearCache},
d46 1
a46 1
    {NM_ITEM,    "Delete","D",0,~0,(APTR) menu_Delete},
d48 4
a51 4
    {NM_TITLE, "Sort",NULL,0,~0,NULL},
    {NM_ITEM,    "by name",NULL,0,~0,(APTR) menu_SortByName},
    {NM_ITEM,    "by date",NULL,0,~0,(APTR) menu_SortByDate},
    {NM_TITLE, "Hotlist",NULL,0,~0,NULL},
d55 24
d83 14
a96 6
struct NewGadget main_FilesGad  = {0,0,250,104,NULL,NULL,1,NULL,NULL,(APTR)File_clicked};
struct NewGadget main_SiteName  = {0,0,250,0,"Current _site:",NULL,2,PLACETEXT_LEFT,NULL,(APTR)Site_clicked};
struct NewGadget main_DirName   = {0,0,250,0,"D_irectory:",NULL,3,PLACETEXT_LEFT,NULL,(APTR)Dir_clicked};
struct NewGadget main_DLPathName = {0,0,250,0,NULL,NULL,4,NULL,NULL,(APTR)DLPathString_clicked};
struct NewGadget main_DLPathGad  = {0,0,250,0,"D_ownload path...",NULL,5,PLACETEXT_IN,NULL,(APTR)DLPath_clicked};

d99 15
a113 4
struct NewGadget main_ParentGad = {3,1,77,17,"_Parent",NULL,10,PLACETEXT_IN,NULL,(APTR)Parent_clicked};
struct NewGadget main_GetGad    = {3,1,77,17,"_Get",NULL,11,PLACETEXT_IN,NULL,(APTR)Get_clicked};
struct NewGadget main_PutGad    = {3,1,77,17,"P_ut",NULL,12,PLACETEXT_IN,NULL,(APTR)Put_clicked};
struct NewGadget main_ViewGad   = {3,1,77,17,"_View",NULL,13,NULL,NULL,(APTR)View_clicked};
a114 2
struct NewGadget main_ConnectGad = {0,0,250,0,"_Connect to...",NULL,14,PLACETEXT_IN,NULL,(APTR)Connect_clicked};
struct NewGadget main_DisconnectGad = {0,0,250,0,"_Disconnect",NULL,15,PLACETEXT_IN,NULL,(APTR)Disconnect_clicked};
d272 1
a272 1
    main_Group1.Width  = max(n1,main_FilesGad.ng_Width) + INTERWIDTH;
d275 4
a278 4
    n1 = TextLength(RPort,main_ParentGad.ng_GadgetText,strlen(main_ParentGad.ng_GadgetText)-1);
    n2 = TextLength(RPort,main_GetGad.ng_GadgetText,strlen(main_GetGad.ng_GadgetText)-1);
    n3 = TextLength(RPort,main_PutGad.ng_GadgetText,strlen(main_PutGad.ng_GadgetText)-1);
    n4 = TextLength(RPort,main_ViewGad.ng_GadgetText,strlen(main_ViewGad.ng_GadgetText)-1);
d282 2
a283 2
    n3 = TextLength(RPort,main_ConnectGad.ng_GadgetText,strlen(main_ConnectGad.ng_GadgetText)-1);
    n4 = TextLength(RPort,main_DisconnectGad.ng_GadgetText,strlen(main_DisconnectGad.ng_GadgetText)-1);
d289 9
a297 9
    main_FastKeys[GD_SiteName]= FindVanillaKey(main_SiteName.ng_GadgetText);
    main_FastKeys[GD_DirName] = FindVanillaKey(main_DirName.ng_GadgetText);
    main_FastKeys[GD_Parent_gadget] = FindVanillaKey(main_ParentGad.ng_GadgetText);
    main_FastKeys[GD_Get_gadget] = FindVanillaKey(main_GetGad.ng_GadgetText);
    main_FastKeys[GD_Put_gadget] = FindVanillaKey(main_PutGad.ng_GadgetText);
    main_FastKeys[GD_View_gadget] = FindVanillaKey(main_ViewGad.ng_GadgetText);
    main_FastKeys[GD_DLPath_gadget] = FindVanillaKey(main_DLPathGad.ng_GadgetText);
    main_FastKeys[GD_Connect_gadget] = FindVanillaKey(main_ConnectGad.ng_GadgetText);
    main_FastKeys[GD_Disconnect_gadget] = FindVanillaKey(main_DisconnectGad.ng_GadgetText);
d326 45
a370 45
    main_ConnectGad.ng_Height    = FHigh + 2*INTERHEIGHT;
    main_ConnectGad.ng_TopEdge   = mainWin->BorderTop+Height-main_ConnectGad.ng_Height-INTERHEIGHT/2-INTERHEIGHT;
    main_ConnectGad.ng_LeftEdge  = INTERWIDTH+mainWin->BorderLeft;
    main_ConnectGad.ng_Width     = (Width-2*(INTERWIDTH/2)-2*INTERWIDTH)/2;
    main_ConnectGad.ng_VisualInfo= myVisualInfo;
    main_ConnectGad.ng_TextAttr  = Font;

    main_DisconnectGad.ng_TopEdge = main_ConnectGad.ng_TopEdge;
    main_DisconnectGad.ng_Height  = main_ConnectGad.ng_Height;
    main_DisconnectGad.ng_Width   = main_ConnectGad.ng_Width;
    main_DisconnectGad.ng_LeftEdge = mainWin->BorderLeft+Width-main_DisconnectGad.ng_Width-INTERWIDTH;
    main_DisconnectGad.ng_VisualInfo = myVisualInfo;
    main_DisconnectGad.ng_TextAttr = Font;

    main_ParentGad.ng_Height     = FHigh + 2*INTERHEIGHT;
    main_ParentGad.ng_TopEdge    = main_ConnectGad.ng_TopEdge-INTERHEIGHT-main_ParentGad.ng_Height;
    main_ParentGad.ng_LeftEdge   = INTERWIDTH + mainWin->BorderLeft;
    main_ParentGad.ng_Width      = (Width-3*(INTERWIDTH/2)-2*INTERWIDTH)/4;
    main_ParentGad.ng_VisualInfo = myVisualInfo;
    main_ParentGad.ng_TextAttr   = Font;

    main_PutGad.ng_Height = main_ViewGad.ng_Height =main_GetGad.ng_Height = main_ParentGad.ng_Height;
    main_PutGad.ng_Width = main_ViewGad.ng_Width = main_GetGad.ng_Width = main_ParentGad.ng_Width;
    main_PutGad.ng_TopEdge = main_ViewGad.ng_TopEdge = main_GetGad.ng_TopEdge = main_ParentGad.ng_TopEdge;
    main_GetGad.ng_LeftEdge = main_ParentGad.ng_LeftEdge + main_ParentGad.ng_Width + INTERWIDTH/2;
    main_PutGad.ng_LeftEdge = main_GetGad.ng_LeftEdge + main_GetGad.ng_Width + INTERWIDTH/2;
    main_ViewGad.ng_LeftEdge = mainWin->BorderLeft+Width-main_ViewGad.ng_Width-INTERWIDTH;
    main_PutGad.ng_VisualInfo = main_ViewGad.ng_VisualInfo = main_GetGad.ng_VisualInfo = myVisualInfo;
    main_PutGad.ng_TextAttr = main_ViewGad.ng_TextAttr = main_GetGad.ng_TextAttr = Font;

    main_ConnectGad.ng_Width   = main_GetGad.ng_LeftEdge+main_GetGad.ng_Width-main_ConnectGad.ng_LeftEdge;
    main_DisconnectGad.ng_LeftEdge=main_PutGad.ng_LeftEdge;
    main_DisconnectGad.ng_Width=main_ViewGad.ng_LeftEdge+main_ViewGad.ng_Width-main_DisconnectGad.ng_LeftEdge;

    main_SiteName.ng_TopEdge = mainWin->BorderTop + INTERHEIGHT;
    main_SiteName.ng_LeftEdge = mainWin->BorderLeft + INTERWIDTH + TextLength(RPort,main_SiteName.ng_GadgetText,strlen(main_SiteName.ng_GadgetText)) + TextLength(RPort," ",1) + INTERWIDTH;
    main_SiteName.ng_Height = FHigh + 2*INTERHEIGHT;
    main_SiteName.ng_VisualInfo = myVisualInfo;
    main_SiteName.ng_TextAttr = Font;

    main_DirName.ng_TopEdge = main_SiteName.ng_TopEdge + 2*INTERHEIGHT + INTERHEIGHT/2+ FHigh;
    main_DirName.ng_LeftEdge = main_SiteName.ng_LeftEdge;
    main_DirName.ng_Height = main_SiteName.ng_Height;
    main_DirName.ng_VisualInfo = myVisualInfo;
    main_DirName.ng_TextAttr = Font;
d372 26
a397 26
    main_DLPathGad.ng_Height    = FHigh +2*INTERHEIGHT;
    main_DLPathGad.ng_TopEdge   = main_ParentGad.ng_TopEdge - main_DLPathGad.ng_Height - INTERHEIGHT;
    main_DLPathGad.ng_LeftEdge  = main_ParentGad.ng_LeftEdge;
    main_DLPathGad.ng_Width     = INTERWIDTH+TextLength(RPort,main_DLPathGad.ng_GadgetText,strlen(main_DLPathGad.ng_GadgetText));
    main_DLPathGad.ng_VisualInfo = myVisualInfo;
    main_DLPathGad.ng_TextAttr = Font;

    main_DLPathName.ng_Height   = main_DLPathGad.ng_Height;
    main_DLPathName.ng_TopEdge  = main_DLPathGad.ng_TopEdge;
    main_DLPathName.ng_LeftEdge = main_DLPathGad.ng_LeftEdge+main_DLPathGad.ng_Width+INTERWIDTH;
    main_DLPathName.ng_VisualInfo = myVisualInfo;
    main_DLPathName.ng_TextAttr = Font;

    main_FilesGad.ng_TopEdge    = main_DirName.ng_TopEdge + 2*INTERHEIGHT+ INTERHEIGHT/2+FHigh;
    main_FilesGad.ng_LeftEdge   = main_ParentGad.ng_LeftEdge;
    main_FilesGad.ng_Width      = Width-2*INTERWIDTH;
    main_FilesGad.ng_Height     = ((main_DLPathName.ng_TopEdge-main_DirName.ng_TopEdge-INTERHEIGHT-main_DirName.ng_Height)/FHigh)*FHigh-INTERHEIGHT;
    main_FilesGad.ng_VisualInfo = myVisualInfo;
    main_FilesGad.ng_TextAttr   = Font;

    main_DLPathGad.ng_TopEdge = main_DLPathName.ng_TopEdge  = main_FilesGad.ng_TopEdge + main_FilesGad.ng_Height+INTERHEIGHT;

    main_SiteName.ng_Width = main_FilesGad.ng_Width - TextLength(RPort,main_SiteName.ng_GadgetText,strlen(main_SiteName.ng_GadgetText))-TextLength(RPort," ",1)-INTERWIDTH;
    main_DirName.ng_Width = main_SiteName.ng_Width;
    main_DLPathName.ng_Width = main_FilesGad.ng_Width - main_DLPathGad.ng_Width-INTERWIDTH;
    if (!(mainGadgets[GD_Files_LV] = *gadg = CreateGadget(LISTVIEW_KIND,*gadg,&main_FilesGad,
d406 1
a406 1
    if (!(mainGadgets[GD_SiteName] = *gadg = CreateGadget(STRING_KIND,*gadg,&main_SiteName,
d413 1
a413 1
    if (!(mainGadgets[GD_DirName] = *gadg = CreateGadget (STRING_KIND,*gadg,&main_DirName,
d422 1
a422 1
    if (!(mainGadgets[GD_DLPathName] = *gadg = CreateGadget(STRING_KIND,*gadg,&main_DLPathName,
d428 1
a428 1
    if (!(mainGadgets[GD_Parent_gadget] = *gadg = CreateGadget(BUTTON_KIND,*gadg,&main_ParentGad,
d433 1
a433 1
    if (!(mainGadgets[GD_Get_gadget] = *gadg = CreateGadget(BUTTON_KIND,*gadg,&main_GetGad,
d438 1
a438 1
    if (!(mainGadgets[GD_Put_gadget] = *gadg = CreateGadget(BUTTON_KIND,*gadg,&main_PutGad,
d443 1
a443 1
    if (!(mainGadgets[GD_View_gadget] = *gadg = CreateGadget(BUTTON_KIND,*gadg,&main_ViewGad,
d448 1
a448 1
    if (!(mainGadgets[GD_DLPath_gadget] = *gadg = CreateGadget(BUTTON_KIND,*gadg,&main_DLPathGad,
d452 1
a452 1
    if (!(mainGadgets[GD_Connect_gadget] = *gadg = CreateGadget(BUTTON_KIND,*gadg,&main_ConnectGad,
d456 1
a456 1
    if (!(mainGadgets[GD_Disconnect_gadget] = *gadg = CreateGadget(BUTTON_KIND,*gadg,&main_DisconnectGad,
@


0.336
log
@Added AS225-support (via #ifdefs)
Using GetSysTime() instead of time() in transferroutines
@
text
@d315 4
@


0.322
log
@Dir-cache added.
Delete added.
@
text
@d47 1
a47 1
    {NM_ITEM,    "Move","M",0,~0,(APTR) menu_Move},
@


0.305
log
@Added some casts to avoid compiler warnings
@
text
@d26 1
d44 4
a47 1
    {NM_ITEM,    "Delete",NULL,0,~0,(APTR) menu_Delete},
d929 2
d932 2
d949 12
@


0.303
log
@Remembers position/size when uniconifying
@
text
@a277 1
    UWORD n;
d713 1
a713 1
			for (i=0,ptr=GetHead(&SiteList);ptr;ptr=GetSucc(ptr)) {
a758 2
	struct IntuiMessage*imsg;

d837 1
a837 1
      if (dir!=&CurrentState.CurrentRemoteDir)
d954 1
a954 1
    for (ptr=GetHead(&SiteList);ptr;ptr=GetSucc(ptr)) {
d964 1
a964 1
	    for (ptr=GetHead(&SiteList);ptr;ptr=GetSucc(ptr)) {
@


0.284
log
@First RCS version.
@
text
@d5 1
a5 1
char wintitle[]="AmiFTP 1.0 © 1995 Magnus Lilja";
d39 5
d542 2
a543 2
				 WA_Top,0 - myScn->ViewPort.DyOffset,
				 WA_Left,0 - myScn->ViewPort.DxOffset,
d545 1
a545 1
				 WA_InnerHeight, OldWin1High,
d761 5
a765 1
	
d896 49
@
